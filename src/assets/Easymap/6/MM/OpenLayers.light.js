var OpenLayers = { VERSION_NUMBER: "Release 2.13.1", singleFile: !0, _getScriptLocation: function () { for (var e, t, n = new RegExp("(^|(.*?\\/))(OpenLayers[^\\/]*?\\.js)(\\?|$)"), i = document.getElementsByTagName("script"), s = "", r = 0, a = i.length; r < a; r++)if ((e = i[r].getAttribute("src")) && (t = e.match(n))) { s = t[1]; break } return function () { return s } }(), ImgPath: "" }; OpenLayers.String = { startsWith: function (e, t) { return 0 == e.indexOf(t) }, contains: function (e, t) { return -1 != e.indexOf(t) }, trim: function (e) { return e.replace(/^\s\s*/, "").replace(/\s\s*$/, "") }, camelize: function (e) { for (var t = e.split("-"), n = t[0], i = 1, s = t.length; i < s; i++) { var r = t[i]; n += r.charAt(0).toUpperCase() + r.substring(1) } return n }, format: function (e, t, n) { t || (t = window); return e.replace(OpenLayers.String.tokenRegEx, function (e, i) { for (var s, r = i.split(/\.+/), a = 0; a < r.length && (0 == a && (s = t), void 0 !== s); a++)s = s[r[a]]; return "function" == typeof s && (s = n ? s.apply(null, n) : s()), void 0 === s ? "undefined" : s }) }, tokenRegEx: /\$\{([\w.]+?)\}/g, numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/, isNumeric: function (e) { return OpenLayers.String.numberRegEx.test(e) }, numericIf: function (e, t) { var n = e; return !0 === t && null != e && e.replace && (e = e.replace(/^\s*|\s*$/g, "")), OpenLayers.String.isNumeric(e) ? parseFloat(e) : n } }, OpenLayers.Number = { decimalSeparator: ".", thousandsSeparator: ",", limitSigDigs: function (e, t) { var n = 0; return t > 0 && (n = parseFloat(e.toPrecision(t))), n }, format: function (e, t, n, i) { t = void 0 !== t ? t : 0, n = void 0 !== n ? n : OpenLayers.Number.thousandsSeparator, i = void 0 !== i ? i : OpenLayers.Number.decimalSeparator, null != t && (e = parseFloat(e.toFixed(t))); var s = e.toString().split("."); 1 == s.length && null == t && (t = 0); var r, a = s[0]; if (n) for (var o = /(-?[0-9]+)([0-9]{3})/; o.test(a);)a = a.replace(o, "$1" + n + "$2"); if (0 == t) r = a; else { var l = s.length > 1 ? s[1] : "0"; null != t && (l += new Array(t - l.length + 1).join("0")), r = a + i + l } return r }, zeroPad: function (e, t, n) { for (var i = e.toString(n || 10); i.length < t;)i = "0" + i; return i } }, OpenLayers.Function = { bind: function (e, t) { var n = Array.prototype.slice.apply(arguments, [2]); return function () { var i = n.concat(Array.prototype.slice.apply(arguments, [0])); return e.apply(t, i) } }, bindAsEventListener: function (e, t) { return function (n) { return e.call(t, n || window.event) } }, False: function () { return !1 }, True: function () { return !0 }, Void: function () { } }, OpenLayers.Array = { filter: function (e, t, n) { var i = []; if (Array.prototype.filter) i = e.filter(t, n); else { var s = e.length; if ("function" != typeof t) throw new TypeError; for (var r = 0; r < s; r++)if (r in e) { var a = e[r]; t.call(n, a, r, e) && i.push(a) } } return i } }, OpenLayers.Class = function () { var e = arguments.length, t = arguments[0], n = arguments[e - 1], i = "function" == typeof n.initialize ? n.initialize : function () { t.prototype.initialize.apply(this, arguments) }; if (e > 1) { var s = [i, t].concat(Array.prototype.slice.call(arguments).slice(1, e - 1), n); OpenLayers.inherit.apply(null, s) } else i.prototype = n; return i }, OpenLayers.inherit = function (e, t) { var n, i, s, r = function () { }; for (r.prototype = t.prototype, e.prototype = new r, n = 2, i = arguments.length; n < i; n++)"function" == typeof (s = arguments[n]) && (s = s.prototype), OpenLayers.Util.extend(e.prototype, s) }, OpenLayers.Util = OpenLayers.Util || {}, OpenLayers.Util.extend = function (e, t) { if (e = e || {}, t) { for (var n in t) { var i = t[n]; void 0 !== i && (e[n] = i) } !("function" == typeof window.Event && t instanceof window.Event) && t.hasOwnProperty && t.hasOwnProperty("toString") && (e.toString = t.toString) } return e }, OpenLayers.Bounds = OpenLayers.Class({ left: null, bottom: null, right: null, top: null, centerLonLat: null, initialize: function (e, t, n, i) { OpenLayers.Util.isArray(e) && (i = e[3], n = e[2], t = e[1], e = e[0]), null != e && (this.left = OpenLayers.Util.toFloat(e)), null != t && (this.bottom = OpenLayers.Util.toFloat(t)), null != n && (this.right = OpenLayers.Util.toFloat(n)), null != i && (this.top = OpenLayers.Util.toFloat(i)) }, clone: function () { return new OpenLayers.Bounds(this.left, this.bottom, this.right, this.top) }, equals: function (e) { var t = !1; return null != e && (t = this.left == e.left && this.right == e.right && this.top == e.top && this.bottom == e.bottom), t }, toString: function () { return [this.left, this.bottom, this.right, this.top].join(",") }, toArray: function (e) { return !0 === e ? [this.bottom, this.left, this.top, this.right] : [this.left, this.bottom, this.right, this.top] }, toBBOX: function (e, t) { null == e && (e = 6); var n = Math.pow(10, e), i = Math.round(this.left * n) / n, s = Math.round(this.bottom * n) / n, r = Math.round(this.right * n) / n, a = Math.round(this.top * n) / n; return !0 === t ? s + "," + i + "," + a + "," + r : i + "," + s + "," + r + "," + a }, toGeometry: function () { return new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing([new OpenLayers.Geometry.Point(this.left, this.bottom), new OpenLayers.Geometry.Point(this.right, this.bottom), new OpenLayers.Geometry.Point(this.right, this.top), new OpenLayers.Geometry.Point(this.left, this.top)])]) }, getWidth: function () { return this.right - this.left }, getHeight: function () { return this.top - this.bottom }, getSize: function () { return new OpenLayers.Size(this.getWidth(), this.getHeight()) }, getCenterPixel: function () { return new OpenLayers.Pixel((this.left + this.right) / 2, (this.bottom + this.top) / 2) }, getCenterLonLat: function () { return this.centerLonLat || (this.centerLonLat = new OpenLayers.LonLat((this.left + this.right) / 2, (this.bottom + this.top) / 2)), this.centerLonLat }, scale: function (e, t) { var n, i; null == t && (t = this.getCenterLonLat()), "OpenLayers.LonLat" == t.CLASS_NAME ? (n = t.lon, i = t.lat) : (n = t.x, i = t.y); var s = (this.left - n) * e + n, r = (this.bottom - i) * e + i, a = (this.right - n) * e + n, o = (this.top - i) * e + i; return new OpenLayers.Bounds(s, r, a, o) }, add: function (e, t) { if (null == e || null == t) throw new TypeError("Bounds.add cannot receive null values"); return new OpenLayers.Bounds(this.left + e, this.bottom + t, this.right + e, this.top + t) }, extend: function (e) { if (e) switch (e.CLASS_NAME) { case "OpenLayers.LonLat": this.extendXY(e.lon, e.lat); break; case "OpenLayers.Geometry.Point": this.extendXY(e.x, e.y); break; case "OpenLayers.Bounds": this.centerLonLat = null, (null == this.left || e.left < this.left) && (this.left = e.left), (null == this.bottom || e.bottom < this.bottom) && (this.bottom = e.bottom), (null == this.right || e.right > this.right) && (this.right = e.right), (null == this.top || e.top > this.top) && (this.top = e.top) } }, extendXY: function (e, t) { this.centerLonLat = null, (null == this.left || e < this.left) && (this.left = e), (null == this.bottom || t < this.bottom) && (this.bottom = t), (null == this.right || e > this.right) && (this.right = e), (null == this.top || t > this.top) && (this.top = t) }, containsLonLat: function (e, t) { "boolean" == typeof t && (t = { inclusive: t }), t = t || {}; var n = this.contains(e.lon, e.lat, t.inclusive), i = t.worldBounds; if (i && !n) { var s = i.getWidth(), r = (i.left + i.right) / 2, a = Math.round((e.lon - r) / s); n = this.containsLonLat({ lon: e.lon - a * s, lat: e.lat }, { inclusive: t.inclusive }) } return n }, containsPixel: function (e, t) { return this.contains(e.x, e.y, t) }, contains: function (e, t, n) { if (null == n && (n = !0), null == e || null == t) return !1; e = OpenLayers.Util.toFloat(e), t = OpenLayers.Util.toFloat(t); return n ? e >= this.left && e <= this.right && t >= this.bottom && t <= this.top : e > this.left && e < this.right && t > this.bottom && t < this.top }, intersectsBounds: function (e, t) { if ("boolean" == typeof t && (t = { inclusive: t }), (t = t || {}).worldBounds) { var n = this.wrapDateLine(t.worldBounds); e = e.wrapDateLine(t.worldBounds) } else n = this; null == t.inclusive && (t.inclusive = !0); var i = !1, s = n.left == e.right || n.right == e.left || n.top == e.bottom || n.bottom == e.top; if (t.inclusive || !s) { var r = e.bottom >= n.bottom && e.bottom <= n.top || n.bottom >= e.bottom && n.bottom <= e.top, a = e.top >= n.bottom && e.top <= n.top || n.top > e.bottom && n.top < e.top, o = e.left >= n.left && e.left <= n.right || n.left >= e.left && n.left <= e.right, l = e.right >= n.left && e.right <= n.right || n.right >= e.left && n.right <= e.right; i = (r || a) && (o || l) } if (t.worldBounds && !i) { var h = t.worldBounds, p = h.getWidth(), u = !h.containsBounds(n), y = !h.containsBounds(e); u && !y ? (e = e.add(-p, 0), i = n.intersectsBounds(e, { inclusive: t.inclusive })) : y && !u && (n = n.add(-p, 0), i = e.intersectsBounds(n, { inclusive: t.inclusive })) } return i }, containsBounds: function (e, t, n) { null == t && (t = !1), null == n && (n = !0); var i = this.contains(e.left, e.bottom, n), s = this.contains(e.right, e.bottom, n), r = this.contains(e.left, e.top, n), a = this.contains(e.right, e.top, n); return t ? i || s || r || a : i && s && r && a }, determineQuadrant: function (e) { var t = "", n = this.getCenterLonLat(); return t += e.lat < n.lat ? "b" : "t", t += e.lon < n.lon ? "l" : "r" }, transform: function (e, t) { this.centerLonLat = null; var n = OpenLayers.Projection.transform({ x: this.left, y: this.bottom }, e, t), i = OpenLayers.Projection.transform({ x: this.right, y: this.bottom }, e, t), s = OpenLayers.Projection.transform({ x: this.left, y: this.top }, e, t), r = OpenLayers.Projection.transform({ x: this.right, y: this.top }, e, t); return this.left = Math.min(n.x, s.x), this.bottom = Math.min(n.y, i.y), this.right = Math.max(i.x, r.x), this.top = Math.max(s.y, r.y), this }, wrapDateLine: function (e, t) { var n = (t = t || {}).leftTolerance || 0, i = t.rightTolerance || 0, s = this.clone(); if (e) { for (var r = e.getWidth(); s.left < e.left && s.right - i <= e.left;)s = s.add(r, 0); for (; s.left + n >= e.right && s.right > e.right;)s = s.add(-r, 0); var a = s.left + n; a < e.right && a > e.left && s.right - i > e.right && (s = s.add(-r, 0)) } return s }, CLASS_NAME: "OpenLayers.Bounds" }), OpenLayers.Bounds.fromString = function (e, t) { var n = e.split(","); return OpenLayers.Bounds.fromArray(n, t) }, OpenLayers.Bounds.fromArray = function (e, t) { return !0 === t ? new OpenLayers.Bounds(e[1], e[0], e[3], e[2]) : new OpenLayers.Bounds(e[0], e[1], e[2], e[3]) }, OpenLayers.Bounds.fromSize = function (e) { return new OpenLayers.Bounds(0, e.h, e.w, 0) }, OpenLayers.Bounds.oppositeQuadrant = function (e) { var t = ""; return t += "t" == e.charAt(0) ? "b" : "t", t += "l" == e.charAt(1) ? "r" : "l" }, OpenLayers.Element = { visible: function (e) { return "none" != OpenLayers.Util.getElement(e).style.display }, toggle: function () { for (var e = 0, t = arguments.length; e < t; e++) { var n = OpenLayers.Util.getElement(arguments[e]), i = OpenLayers.Element.visible(n) ? "none" : ""; n.style.display = i } }, remove: function (e) { (e = OpenLayers.Util.getElement(e)).parentNode.removeChild(e) }, getHeight: function (e) { return (e = OpenLayers.Util.getElement(e)).offsetHeight }, hasClass: function (e, t) { var n = e.className; return !!n && new RegExp("(^|\\s)" + t + "(\\s|$)").test(n) }, addClass: function (e, t) { return OpenLayers.Element.hasClass(e, t) || (e.className += (e.className ? " " : "") + t), e }, removeClass: function (e, t) { var n = e.className; return n && (e.className = OpenLayers.String.trim(n.replace(new RegExp("(^|\\s+)" + t + "(\\s+|$)"), " "))), e }, toggleClass: function (e, t) { return OpenLayers.Element.hasClass(e, t) ? OpenLayers.Element.removeClass(e, t) : OpenLayers.Element.addClass(e, t), e }, getStyle: function (e, t) { var n = null; if ((e = OpenLayers.Util.getElement(e)) && e.style) { if (!(n = e.style[OpenLayers.String.camelize(t)])) if (document.defaultView && document.defaultView.getComputedStyle) { var i = document.defaultView.getComputedStyle(e, null); n = i ? i.getPropertyValue(t) : null } else e.currentStyle && (n = e.currentStyle[OpenLayers.String.camelize(t)]); window.opera && -1 != OpenLayers.Util.indexOf(["left", "top", "right", "bottom"], t) && "static" == OpenLayers.Element.getStyle(e, "position") && (n = "auto") } return "auto" == n ? null : n } }, OpenLayers.LonLat = OpenLayers.Class({ lon: 0, lat: 0, initialize: function (e, t) { OpenLayers.Util.isArray(e) && (t = e[1], e = e[0]), this.lon = OpenLayers.Util.toFloat(e), this.lat = OpenLayers.Util.toFloat(t) }, toString: function () { return "lon=" + this.lon + ",lat=" + this.lat }, toShortString: function () { return this.lon + ", " + this.lat }, clone: function () { return new OpenLayers.LonLat(this.lon, this.lat) }, add: function (e, t) { if (null == e || null == t) throw new TypeError("LonLat.add cannot receive null values"); return new OpenLayers.LonLat(this.lon + OpenLayers.Util.toFloat(e), this.lat + OpenLayers.Util.toFloat(t)) }, equals: function (e) { var t = !1; return null != e && (t = this.lon == e.lon && this.lat == e.lat || isNaN(this.lon) && isNaN(this.lat) && isNaN(e.lon) && isNaN(e.lat)), t }, transform: function (e, t) { var n = OpenLayers.Projection.transform({ x: this.lon, y: this.lat }, e, t); return this.lon = n.x, this.lat = n.y, this }, wrapDateLine: function (e) { var t = this.clone(); if (e) { for (; t.lon < e.left;)t.lon += e.getWidth(); for (; t.lon > e.right;)t.lon -= e.getWidth() } return t }, CLASS_NAME: "OpenLayers.LonLat" }), OpenLayers.LonLat.fromString = function (e) { var t = e.split(","); return new OpenLayers.LonLat(t[0], t[1]) }, OpenLayers.LonLat.fromArray = function (e) { var t = OpenLayers.Util.isArray(e), n = t && e[0], i = t && e[1]; return new OpenLayers.LonLat(n, i) }, OpenLayers.Pixel = OpenLayers.Class({ x: 0, y: 0, initialize: function (e, t) { this.x = parseFloat(e), this.y = parseFloat(t) }, toString: function () { return "x=" + this.x + ",y=" + this.y }, clone: function () { return new OpenLayers.Pixel(this.x, this.y) }, equals: function (e) { var t = !1; return null != e && (t = this.x == e.x && this.y == e.y || isNaN(this.x) && isNaN(this.y) && isNaN(e.x) && isNaN(e.y)), t }, distanceTo: function (e) { return Math.sqrt(Math.pow(this.x - e.x, 2) + Math.pow(this.y - e.y, 2)) }, add: function (e, t) { if (null == e || null == t) throw new TypeError("Pixel.add cannot receive null values"); return new OpenLayers.Pixel(this.x + e, this.y + t) }, offset: function (e) { var t = this.clone(); return e && (t = this.add(e.x, e.y)), t }, CLASS_NAME: "OpenLayers.Pixel" }), OpenLayers.Size = OpenLayers.Class({ w: 0, h: 0, initialize: function (e, t) { this.w = parseFloat(e), this.h = parseFloat(t) }, toString: function () { return "w=" + this.w + ",h=" + this.h }, clone: function () { return new OpenLayers.Size(this.w, this.h) }, equals: function (e) { var t = !1; return null != e && (t = this.w == e.w && this.h == e.h || isNaN(this.w) && isNaN(this.h) && isNaN(e.w) && isNaN(e.h)), t }, CLASS_NAME: "OpenLayers.Size" }), OpenLayers.Console = { log: function () { }, debug: function () { }, info: function () { }, warn: function () { }, error: function () { }, userError: function (e) { alert(e) }, assert: function () { }, dir: function () { }, dirxml: function () { }, trace: function () { }, group: function () { }, groupEnd: function () { }, time: function () { }, timeEnd: function () { }, profile: function () { }, profileEnd: function () { }, count: function () { }, CLASS_NAME: "OpenLayers.Console" }, function () { for (var e = document.getElementsByTagName("script"), t = 0, n = e.length; t < n; ++t)if (-1 != e[t].src.indexOf("firebug.js") && console) { OpenLayers.Util.extend(OpenLayers.Console, console); break } }(), OpenLayers.Lang = { code: null, defaultCode: "en", getCode: function () { return OpenLayers.Lang.code || OpenLayers.Lang.setCode(), OpenLayers.Lang.code }, setCode: function (e) { var t; e || (e = "msie" == OpenLayers.BROWSER_NAME ? navigator.userLanguage : navigator.language); var n = e.split("-"); if (n[0] = n[0].toLowerCase(), "object" == typeof OpenLayers.Lang[n[0]] && (t = n[0]), n[1]) { var i = n[0] + "-" + n[1].toUpperCase(); "object" == typeof OpenLayers.Lang[i] && (t = i) } t || (OpenLayers.Console.warn("Failed to find OpenLayers.Lang." + n.join("-") + " dictionary, falling back to default language"), t = OpenLayers.Lang.defaultCode), OpenLayers.Lang.code = t }, translate: function (e, t) { var n = OpenLayers.Lang[OpenLayers.Lang.getCode()], i = n && n[e]; return i || (i = e), t && (i = OpenLayers.String.format(i, t)), i } }, OpenLayers.i18n = OpenLayers.Lang.translate, OpenLayers.Util = OpenLayers.Util || {}, OpenLayers.Util.getElement = function () { for (var e = [], t = 0, n = arguments.length; t < n; t++) { var i = arguments[t]; if ("string" == typeof i && (i = document.getElementById(i)), 1 == arguments.length) return i; e.push(i) } return e }, OpenLayers.Util.isElement = function (e) { return !(!e || 1 !== e.nodeType) }, OpenLayers.Util.isArray = function (e) { return "[object Array]" === Object.prototype.toString.call(e) }, OpenLayers.Util.removeItem = function (e, t) { for (var n = e.length - 1; n >= 0; n--)e[n] == t && e.splice(n, 1); return e }, OpenLayers.Util.indexOf = function (e, t) { if ("function" == typeof e.indexOf) return e.indexOf(t); for (var n = 0, i = e.length; n < i; n++)if (e[n] == t) return n; return -1 }, OpenLayers.Util.dotless = /\./g, OpenLayers.Util.modifyDOMElement = function (e, t, n, i, s, r, a, o) { t && (e.id = t.replace(OpenLayers.Util.dotless, "_")), n && (e.style.left = n.x + "px", e.style.top = n.y + "px"), i && (e.style.width = i.w + "px", e.style.height = i.h + "px"), s && (e.style.position = s), r && (e.style.border = r), a && (e.style.overflow = a), parseFloat(o) >= 0 && parseFloat(o) < 1 ? (e.style.filter = "alpha(opacity=" + 100 * o + ")", e.style.opacity = o) : 1 == parseFloat(o) && (e.style.filter = "", e.style.opacity = "") }, OpenLayers.Util.createDiv = function (e, t, n, i, s, r, a, o) { var l = document.createElement("div"); return i && (l.style.backgroundImage = "url(" + i + ")"), e || (e = OpenLayers.Util.createUniqueID("OpenLayersDiv")), s || (s = "absolute"), OpenLayers.Util.modifyDOMElement(l, e, t, n, s, r, a, o), l }, OpenLayers.Util.createImage = function (e, t, n, i, s, r, a, o) { var l = document.createElement("img"); if (e || (e = OpenLayers.Util.createUniqueID("OpenLayersDiv")), s || (s = "relative"), OpenLayers.Util.modifyDOMElement(l, e, t, n, s, r, null, a), o) { function h() { l.style.display = "", OpenLayers.Event.stopObservingElement(l) } l.style.display = "none", OpenLayers.Event.observe(l, "load", h), OpenLayers.Event.observe(l, "error", h) } return l.style.alt = e, l.galleryImg = "no", i && (l.src = i), l }, OpenLayers.IMAGE_RELOAD_ATTEMPTS = 0, OpenLayers.Util.alphaHackNeeded = null, OpenLayers.Util.alphaHack = function () { if (null == OpenLayers.Util.alphaHackNeeded) { var e = navigator.appVersion.split("MSIE"), t = parseFloat(e[1]), n = !1; try { n = !!document.body.filters } catch (e) { } OpenLayers.Util.alphaHackNeeded = n && t >= 5.5 && t < 7 } return OpenLayers.Util.alphaHackNeeded }, OpenLayers.Util.modifyAlphaImageDiv = function (e, t, n, i, s, r, a, o, l) { OpenLayers.Util.modifyDOMElement(e, t, n, i, r, null, null, l); var h = e.childNodes[0]; s && (h.src = s), OpenLayers.Util.modifyDOMElement(h, e.id + "_innerImage", null, i, "relative", a), OpenLayers.Util.alphaHack() && ("none" != e.style.display && (e.style.display = "inline-block"), null == o && (o = "scale"), e.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + h.src + "', sizingMethod='" + o + "')", parseFloat(e.style.opacity) >= 0 && parseFloat(e.style.opacity) < 1 && (e.style.filter += " alpha(opacity=" + 100 * e.style.opacity + ")"), h.style.filter = "alpha(opacity=0)") }, OpenLayers.Util.createAlphaImageDiv = function (e, t, n, i, s, r, a, o, l) { var h = OpenLayers.Util.createDiv(), p = OpenLayers.Util.createImage(null, null, null, null, null, null, null, l); return p.className = "olAlphaImg", h.appendChild(p), OpenLayers.Util.modifyAlphaImageDiv(h, e, t, n, i, s, r, a, o), h }, OpenLayers.Util.upperCaseObject = function (e) { var t = {}; for (var n in e) t[n.toUpperCase()] = e[n]; return t }, OpenLayers.Util.applyDefaults = function (e, t) { e = e || {}; var n = "function" == typeof window.Event && t instanceof window.Event; for (var i in t) (void 0 === e[i] || !n && t.hasOwnProperty && t.hasOwnProperty(i) && !e.hasOwnProperty(i)) && (e[i] = t[i]); return !n && t && t.hasOwnProperty && t.hasOwnProperty("toString") && !e.hasOwnProperty("toString") && (e.toString = t.toString), e }, OpenLayers.Util.getParameterString = function (e) { var t = []; for (var n in e) { var i = e[n]; if (null != i && "function" != typeof i) { var s; if ("object" == typeof i && i.constructor == Array) { for (var r, a = [], o = 0, l = i.length; o < l; o++)r = i[o], a.push(encodeURIComponent(null == r ? "" : r)); s = a.join(",") } else s = encodeURIComponent(i); t.push(encodeURIComponent(n) + "=" + s) } } return t.join("&") }, OpenLayers.Util.urlAppend = function (e, t) { var n = e; if (t) { var i = (e + " ").split(/[?&]/); n += " " === i.pop() ? t : i.length ? "&" + t : "?" + t } return n }, OpenLayers.Util.getImagesLocation = function () { return OpenLayers.ImgPath || OpenLayers._getScriptLocation() + "img/" }, OpenLayers.Util.getImageLocation = function (e) { return OpenLayers.Util.getImagesLocation() + e }, OpenLayers.Util.Try = function () { for (var e = null, t = 0, n = arguments.length; t < n; t++) { var i = arguments[t]; try { e = i(); break } catch (e) { } } return e }, OpenLayers.Util.getXmlNodeValue = function (e) { var t = null; return OpenLayers.Util.Try(function () { (t = e.text) || (t = e.textContent), t || (t = e.firstChild.nodeValue) }, function () { t = e.textContent }), t }, OpenLayers.Util.mouseLeft = function (e, t) { for (var n = e.relatedTarget ? e.relatedTarget : e.toElement; n != t && null != n;)n = n.parentNode; return n != t }, OpenLayers.Util.DEFAULT_PRECISION = 14, OpenLayers.Util.toFloat = function (e, t) { return null == t && (t = OpenLayers.Util.DEFAULT_PRECISION), "number" != typeof e && (e = parseFloat(e)), 0 === t ? e : parseFloat(e.toPrecision(t)) }, OpenLayers.Util.rad = function (e) { return e * Math.PI / 180 }, OpenLayers.Util.deg = function (e) { return 180 * e / Math.PI }, OpenLayers.Util.VincentyConstants = { a: 6378137, b: 6356752.3142, f: 1 / 298.257223563 }, OpenLayers.Util.distVincenty = function (e, t) { for (var n = OpenLayers.Util.VincentyConstants, i = n.a, s = n.b, r = n.f, a = OpenLayers.Util.rad(t.lon - e.lon), o = Math.atan((1 - r) * Math.tan(OpenLayers.Util.rad(e.lat))), l = Math.atan((1 - r) * Math.tan(OpenLayers.Util.rad(t.lat))), h = Math.sin(o), p = Math.cos(o), u = Math.sin(l), y = Math.cos(l), c = a, d = 2 * Math.PI, f = 20; Math.abs(c - d) > 1e-12 && --f > 0;) { var m = Math.sin(c), g = Math.cos(c), L = Math.sqrt(y * m * (y * m) + (p * u - h * y * g) * (p * u - h * y * g)); if (0 == L) return 0; var v = h * u + p * y * g, O = Math.atan2(L, v), x = Math.asin(p * y * m / L), E = Math.cos(x) * Math.cos(x), b = v - 2 * h * u / E, S = r / 16 * E * (4 + r * (4 - 3 * E)); d = c, c = a + (1 - S) * r * Math.sin(x) * (O + S * L * (b + S * v * (2 * b * b - 1))) } if (0 == f) return NaN; var w = E * (i * i - s * s) / (s * s), C = w / 1024 * (256 + w * (w * (74 - 47 * w) - 128)); return (s * (1 + w / 16384 * (4096 + w * (w * (320 - 175 * w) - 768))) * (O - C * L * (b + C / 4 * (v * (2 * b * b - 1) - C / 6 * b * (4 * L * L - 3) * (4 * b * b - 3))))).toFixed(3) / 1e3 }, OpenLayers.Util.destinationVincenty = function (e, t, n) { for (var i = OpenLayers.Util, s = i.VincentyConstants, r = s.a, a = s.b, o = s.f, l = e.lon, h = e.lat, p = n, u = i.rad(t), y = Math.sin(u), c = Math.cos(u), d = (1 - o) * Math.tan(i.rad(h)), f = 1 / Math.sqrt(1 + d * d), m = d * f, g = Math.atan2(d, c), L = f * y, v = 1 - L * L, O = v * (r * r - a * a) / (a * a), x = 1 + O / 16384 * (4096 + O * (O * (320 - 175 * O) - 768)), E = O / 1024 * (256 + O * (O * (74 - 47 * O) - 128)), b = p / (a * x), S = 2 * Math.PI; Math.abs(b - S) > 1e-12;) { var w = Math.cos(2 * g + b), C = Math.sin(b), M = Math.cos(b); S = b, b = p / (a * x) + E * C * (w + E / 4 * (M * (2 * w * w - 1) - E / 6 * w * (4 * C * C - 3) * (4 * w * w - 3))) } var P = m * C - f * M * c, R = Math.atan2(m * M + f * C * c, (1 - o) * Math.sqrt(L * L + P * P)), T = o / 16 * v * (4 + o * (4 - 3 * v)), N = Math.atan2(C * y, f * M - m * C * c) - (1 - T) * o * L * (b + T * C * (w + T * M * (2 * w * w - 1))); Math.atan2(L, -P); return new OpenLayers.LonLat(l + i.deg(N), i.deg(R)) }, OpenLayers.Util.getParameters = function (e, t) { t = t || {}, e = null == e ? window.location.href : e; var n = ""; if (OpenLayers.String.contains(e, "?")) { var i = e.indexOf("?") + 1, s = OpenLayers.String.contains(e, "#") ? e.indexOf("#") : e.length; n = e.substring(i, s) } for (var r = {}, a = n.split(/[&;]/), o = 0, l = a.length; o < l; ++o) { var h = a[o].split("="); if (h[0]) { var p = h[0]; try { p = decodeURIComponent(p) } catch (e) { p = unescape(p) } var u = (h[1] || "").replace(/\+/g, " "); try { u = decodeURIComponent(u) } catch (e) { u = unescape(u) } !1 !== t.splitArgs && (u = u.split(",")), 1 == u.length && (u = u[0]), r[p] = u } } return r }, OpenLayers.Util.lastSeqID = 0, OpenLayers.Util.createUniqueID = function (e) { return e = null == e ? "id_" : e.replace(OpenLayers.Util.dotless, "_"), OpenLayers.Util.lastSeqID += 1, e + OpenLayers.Util.lastSeqID }, OpenLayers.INCHES_PER_UNIT = { inches: 1, ft: 12, mi: 63360, m: 39.37, km: 39370, dd: 4374754, yd: 36 }, OpenLayers.INCHES_PER_UNIT.in = OpenLayers.INCHES_PER_UNIT.inches, OpenLayers.INCHES_PER_UNIT.degrees = OpenLayers.INCHES_PER_UNIT.dd, OpenLayers.INCHES_PER_UNIT.nmi = 1852 * OpenLayers.INCHES_PER_UNIT.m, OpenLayers.METERS_PER_INCH = .0254000508001016, OpenLayers.Util.extend(OpenLayers.INCHES_PER_UNIT, { Inch: OpenLayers.INCHES_PER_UNIT.inches, Meter: 1 / OpenLayers.METERS_PER_INCH, Foot: .3048006096012192 / OpenLayers.METERS_PER_INCH, IFoot: .3048 / OpenLayers.METERS_PER_INCH, ClarkeFoot: .3047972651151 / OpenLayers.METERS_PER_INCH, SearsFoot: .30479947153867626 / OpenLayers.METERS_PER_INCH, GoldCoastFoot: .3047997101815088 / OpenLayers.METERS_PER_INCH, IInch: .0254 / OpenLayers.METERS_PER_INCH, MicroInch: 254e-7 / OpenLayers.METERS_PER_INCH, Mil: 2.54e-8 / OpenLayers.METERS_PER_INCH, Centimeter: .01 / OpenLayers.METERS_PER_INCH, Kilometer: 1e3 / OpenLayers.METERS_PER_INCH, Yard: .9144018288036576 / OpenLayers.METERS_PER_INCH, SearsYard: .914398414616029 / OpenLayers.METERS_PER_INCH, IndianYard: .9143985307444408 / OpenLayers.METERS_PER_INCH, IndianYd37: .91439523 / OpenLayers.METERS_PER_INCH, IndianYd62: .9143988 / OpenLayers.METERS_PER_INCH, IndianYd75: .9143985 / OpenLayers.METERS_PER_INCH, IndianFoot: .30479951 / OpenLayers.METERS_PER_INCH, IndianFt37: .30479841 / OpenLayers.METERS_PER_INCH, IndianFt62: .3047996 / OpenLayers.METERS_PER_INCH, IndianFt75: .3047995 / OpenLayers.METERS_PER_INCH, Mile: 1609.3472186944373 / OpenLayers.METERS_PER_INCH, IYard: .9144 / OpenLayers.METERS_PER_INCH, IMile: 1609.344 / OpenLayers.METERS_PER_INCH, NautM: 1852 / OpenLayers.METERS_PER_INCH, "Lat-66": 110943.31648893273 / OpenLayers.METERS_PER_INCH, "Lat-83": 110946.25736872235 / OpenLayers.METERS_PER_INCH, Decimeter: .1 / OpenLayers.METERS_PER_INCH, Millimeter: .001 / OpenLayers.METERS_PER_INCH, Dekameter: 10 / OpenLayers.METERS_PER_INCH, Decameter: 10 / OpenLayers.METERS_PER_INCH, Hectometer: 100 / OpenLayers.METERS_PER_INCH, GermanMeter: 1.0000135965 / OpenLayers.METERS_PER_INCH, CaGrid: .999738 / OpenLayers.METERS_PER_INCH, ClarkeChain: 20.1166194976 / OpenLayers.METERS_PER_INCH, GunterChain: 20.11684023368047 / OpenLayers.METERS_PER_INCH, BenoitChain: 20.116782494375872 / OpenLayers.METERS_PER_INCH, SearsChain: 20.11676512155 / OpenLayers.METERS_PER_INCH, ClarkeLink: .201166194976 / OpenLayers.METERS_PER_INCH, GunterLink: .2011684023368047 / OpenLayers.METERS_PER_INCH, BenoitLink: .20116782494375873 / OpenLayers.METERS_PER_INCH, SearsLink: .2011676512155 / OpenLayers.METERS_PER_INCH, Rod: 5.02921005842012 / OpenLayers.METERS_PER_INCH, IntnlChain: 20.1168 / OpenLayers.METERS_PER_INCH, IntnlLink: .201168 / OpenLayers.METERS_PER_INCH, Perch: 5.02921005842012 / OpenLayers.METERS_PER_INCH, Pole: 5.02921005842012 / OpenLayers.METERS_PER_INCH, Furlong: 201.1684023368046 / OpenLayers.METERS_PER_INCH, Rood: 3.778266898 / OpenLayers.METERS_PER_INCH, CapeFoot: .3047972615 / OpenLayers.METERS_PER_INCH, Brealey: 375 / OpenLayers.METERS_PER_INCH, ModAmFt: .304812252984506 / OpenLayers.METERS_PER_INCH, Fathom: 1.8288 / OpenLayers.METERS_PER_INCH, "NautM-UK": 1853.184 / OpenLayers.METERS_PER_INCH, "50kilometers": 5e4 / OpenLayers.METERS_PER_INCH, "150kilometers": 15e4 / OpenLayers.METERS_PER_INCH }), OpenLayers.Util.extend(OpenLayers.INCHES_PER_UNIT, { mm: OpenLayers.INCHES_PER_UNIT.Meter / 1e3, cm: OpenLayers.INCHES_PER_UNIT.Meter / 100, dm: 100 * OpenLayers.INCHES_PER_UNIT.Meter, km: 1e3 * OpenLayers.INCHES_PER_UNIT.Meter, kmi: OpenLayers.INCHES_PER_UNIT.nmi, fath: OpenLayers.INCHES_PER_UNIT.Fathom, ch: OpenLayers.INCHES_PER_UNIT.IntnlChain, link: OpenLayers.INCHES_PER_UNIT.IntnlLink, "us-in": OpenLayers.INCHES_PER_UNIT.inches, "us-ft": OpenLayers.INCHES_PER_UNIT.Foot, "us-yd": OpenLayers.INCHES_PER_UNIT.Yard, "us-ch": OpenLayers.INCHES_PER_UNIT.GunterChain, "us-mi": OpenLayers.INCHES_PER_UNIT.Mile, "ind-yd": OpenLayers.INCHES_PER_UNIT.IndianYd37, "ind-ft": OpenLayers.INCHES_PER_UNIT.IndianFt37, "ind-ch": 20.11669506 / OpenLayers.METERS_PER_INCH }), OpenLayers.DOTS_PER_INCH = 72, OpenLayers.Util.normalizeScale = function (e) { return e > 1 ? 1 / e : e }, OpenLayers.Util.getResolutionFromScale = function (e, t) { var n; e && (null == t && (t = "degrees"), n = 1 / (OpenLayers.Util.normalizeScale(e) * OpenLayers.INCHES_PER_UNIT[t] * OpenLayers.DOTS_PER_INCH)); return n }, OpenLayers.Util.getScaleFromResolution = function (e, t) { return null == t && (t = "degrees"), e * OpenLayers.INCHES_PER_UNIT[t] * OpenLayers.DOTS_PER_INCH }, OpenLayers.Util.pagePosition = function (e) { var t = [0, 0], n = OpenLayers.Util.getViewportElement(); if (!e || e == window || e == n) return t; var i, s = OpenLayers.IS_GECKO && document.getBoxObjectFor && "absolute" == OpenLayers.Element.getStyle(e, "position") && ("" == e.style.top || "" == e.style.left), r = null; if (e.getBoundingClientRect) { i = e.getBoundingClientRect(); var a = window.pageYOffset || n.scrollTop, o = window.pageXOffset || n.scrollLeft; t[0] = i.left + o, t[1] = i.top + a } else if (document.getBoxObjectFor && !s) { i = document.getBoxObjectFor(e); var l = document.getBoxObjectFor(n); t[0] = i.screenX - l.screenX, t[1] = i.screenY - l.screenY } else { if (t[0] = e.offsetLeft, t[1] = e.offsetTop, (r = e.offsetParent) != e) for (; r;)t[0] += r.offsetLeft, t[1] += r.offsetTop, r = r.offsetParent; var h = OpenLayers.BROWSER_NAME; for (("opera" == h || "safari" == h && "absolute" == OpenLayers.Element.getStyle(e, "position")) && (t[1] -= document.body.offsetTop), r = e.offsetParent; r && r != document.body;)t[0] -= r.scrollLeft, "opera" == h && "TR" == r.tagName || (t[1] -= r.scrollTop), r = r.offsetParent } return t }, OpenLayers.Util.getViewportElement = function () { var e = arguments.callee.viewportElement; return null == e && (e = "msie" == OpenLayers.BROWSER_NAME && "CSS1Compat" != document.compatMode ? document.body : document.documentElement, arguments.callee.viewportElement = e), e }, OpenLayers.Util.isEquivalentUrl = function (e, t, n) { n = n || {}, OpenLayers.Util.applyDefaults(n, { ignoreCase: !0, ignorePort80: !0, ignoreHash: !0, splitArgs: !1 }); var i = OpenLayers.Util.createUrlObject(e, n), s = OpenLayers.Util.createUrlObject(t, n); for (var r in i) if ("args" !== r && i[r] != s[r]) return !1; for (var r in i.args) { if (i.args[r] != s.args[r]) return !1; delete s.args[r] } for (var r in s.args) return !1; return !0 }, OpenLayers.Util.createUrlObject = function (e, t) { if (t = t || {}, !/^\w+:\/\//.test(e)) { var n = window.location, i = n.port ? ":" + n.port : "", s = n.protocol + "//" + n.host.split(":").shift() + i; if (0 === e.indexOf("/")) e = s + e; else { var r = n.pathname.split("/"); r.pop(), e = s + r.join("/") + "/" + e } } t.ignoreCase && (e = e.toLowerCase()); var a = document.createElement("a"); a.href = e; var o = {}; o.host = a.host.split(":").shift(), o.protocol = a.protocol, t.ignorePort80 ? o.port = "80" == a.port || "0" == a.port ? "" : a.port : o.port = "" == a.port || "0" == a.port ? "80" : a.port, o.hash = t.ignoreHash || "#" === a.hash ? "" : a.hash; var l = a.search; if (!l) { var h = e.indexOf("?"); l = -1 != h ? e.substr(h) : "" } return o.args = OpenLayers.Util.getParameters(l, { splitArgs: t.splitArgs }), o.pathname = "/" == a.pathname.charAt(0) ? a.pathname : "/" + a.pathname, o }, OpenLayers.Util.removeTail = function (e) { var t = e.indexOf("?"), n = e.indexOf("#"); return -1 == t ? -1 != n ? e.substr(0, n) : e : -1 != n ? e.substr(0, Math.min(t, n)) : e.substr(0, t) }, OpenLayers.IS_GECKO = function () { var e = navigator.userAgent.toLowerCase(); return -1 == e.indexOf("webkit") && -1 != e.indexOf("gecko") }(), OpenLayers.CANVAS_SUPPORTED = function () { var e = document.createElement("canvas"); return !(!e.getContext || !e.getContext("2d")) }(), OpenLayers.BROWSER_NAME = function () { var e = "", t = navigator.userAgent.toLowerCase(); return -1 != t.indexOf("opera") ? e = "opera" : -1 != t.indexOf("msie") ? e = "msie" : -1 != t.indexOf("safari") ? e = "safari" : -1 != t.indexOf("mozilla") && (e = -1 != t.indexOf("firefox") ? "firefox" : "mozilla"), e }(), OpenLayers.Util.getBrowserName = function () { return OpenLayers.BROWSER_NAME }, OpenLayers.Util.getRenderedDimensions = function (e, t, n) { var i, s, r = document.createElement("div"); r.style.visibility = "hidden"; for (var a = n && n.containerElement ? n.containerElement : document.body, o = !1, l = null, h = a; h && "body" != h.tagName.toLowerCase();) { var p = OpenLayers.Element.getStyle(h, "position"); if ("absolute" == p) { o = !0; break } if (p && "static" != p) break; h = h.parentNode } !o || 0 !== a.clientHeight && 0 !== a.clientWidth || ((l = document.createElement("div")).style.visibility = "hidden", l.style.position = "absolute", l.style.overflow = "visible", l.style.width = document.body.clientWidth + "px", l.style.height = document.body.clientHeight + "px", l.appendChild(r)), r.style.position = "absolute", t && (t.w ? (i = t.w, r.style.width = i + "px") : t.h && (s = t.h, r.style.height = s + "px")), n && n.displayClass && (r.className = n.displayClass); var u = document.createElement("div"); if (u.innerHTML = e, u.style.overflow = "visible", u.childNodes) for (var y = 0, c = u.childNodes.length; y < c; y++)u.childNodes[y].style && (u.childNodes[y].style.overflow = "visible"); return r.appendChild(u), l ? a.appendChild(l) : a.appendChild(r), i || (i = parseInt(u.scrollWidth), r.style.width = i + "px"), s || (s = parseInt(u.scrollHeight)), r.removeChild(u), l ? (l.removeChild(r), a.removeChild(l)) : a.removeChild(r), new OpenLayers.Size(i, s) }, OpenLayers.Util.getScrollbarWidth = function () { var e = OpenLayers.Util._scrollbarWidth; if (null == e) { var t, n, i = null, s = null; (i = document.createElement("div")).style.position = "absolute", i.style.top = "-1000px", i.style.left = "-1000px", i.style.width = "100px", i.style.height = "50px", i.style.overflow = "hidden", (s = document.createElement("div")).style.width = "100%", s.style.height = "200px", i.appendChild(s), document.body.appendChild(i), t = s.offsetWidth, i.style.overflow = "scroll", n = s.offsetWidth, document.body.removeChild(document.body.lastChild), OpenLayers.Util._scrollbarWidth = t - n, e = OpenLayers.Util._scrollbarWidth } return e }, OpenLayers.Util.getFormattedLonLat = function (e, t, n) { n || (n = "dms"), e = (e + 540) % 360 - 180; var i = Math.abs(e), s = Math.floor(i), r = (i - s) / (1 / 60), a = (r - (r = Math.floor(r))) / (1 / 60); a = Math.round(10 * a), (a /= 10) >= 60 && (a -= 60, (r += 1) >= 60 && (r -= 60, s += 1)), s < 10 && (s = "0" + s); var o = s + "°"; return n.indexOf("dm") >= 0 && (r < 10 && (r = "0" + r), o += r + "'", n.indexOf("dms") >= 0 && (a < 10 && (a = "0" + a), o += a + '"')), o += "lon" == t ? e < 0 ? OpenLayers.i18n("W") : OpenLayers.i18n("E") : e < 0 ? OpenLayers.i18n("S") : OpenLayers.i18n("N") }, OpenLayers.Event = { observers: !1, KEY_SPACE: 32, KEY_BACKSPACE: 8, KEY_TAB: 9, KEY_RETURN: 13, KEY_ESC: 27, KEY_LEFT: 37, KEY_UP: 38, KEY_RIGHT: 39, KEY_DOWN: 40, KEY_DELETE: 46, element: function (e) { return e.target || e.srcElement }, isSingleTouch: function (e) { return e.touches && 1 == e.touches.length }, isMultiTouch: function (e) { return e.touches && e.touches.length > 1 }, isLeftClick: function (e) { return e.which && 1 == e.which || e.button && 1 == e.button }, isRightClick: function (e) { return e.which && 3 == e.which || e.button && 2 == e.button }, stop: function (e, t) { t || OpenLayers.Event.preventDefault(e), e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0 }, preventDefault: function (e) { e.preventDefault ? e.preventDefault() : e.returnValue = !1 }, findElement: function (e, t) { for (var n = OpenLayers.Event.element(e); n.parentNode && (!n.tagName || n.tagName.toUpperCase() != t.toUpperCase());)n = n.parentNode; return n }, observe: function (e, t, n, i) { var s = OpenLayers.Util.getElement(e); if (i = i || !1, "keypress" == t && (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || s.attachEvent) && (t = "keydown"), this.observers || (this.observers = {}), !s._eventCacheID) { var r = "eventCacheID_"; s.id && (r = s.id + "_" + r), s._eventCacheID = OpenLayers.Util.createUniqueID(r) } var a = s._eventCacheID; this.observers[a] || (this.observers[a] = []), this.observers[a].push({ element: s, name: t, observer: n, useCapture: i }), s.addEventListener ? s.addEventListener(t, n, { passive: !1 }) : s.attachEvent && s.attachEvent("on" + t, n) }, stopObservingElement: function (e) { var t = OpenLayers.Util.getElement(e)._eventCacheID; this._removeElementObservers(OpenLayers.Event.observers[t]) }, _removeElementObservers: function (e) { if (e) for (var t = e.length - 1; t >= 0; t--) { var n = e[t]; OpenLayers.Event.stopObserving.apply(this, [n.element, n.name, n.observer, n.useCapture]) } }, stopObserving: function (e, t, n, i) { i = i || !1; var s = OpenLayers.Util.getElement(e), r = s._eventCacheID; "keypress" == t && (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || s.detachEvent) && (t = "keydown"); var a = !1, o = OpenLayers.Event.observers[r]; if (o) for (var l = 0; !a && l < o.length;) { var h = o[l]; if (h.name == t && h.observer == n && h.useCapture == i) { o.splice(l, 1), 0 == o.length && delete OpenLayers.Event.observers[r], a = !0; break } l++ } return a && (s.removeEventListener ? s.removeEventListener(t, n, i) : s && s.detachEvent && s.detachEvent("on" + t, n)), a }, unloadCache: function () { if (OpenLayers.Event && OpenLayers.Event.observers) { for (var e in OpenLayers.Event.observers) { var t = OpenLayers.Event.observers[e]; OpenLayers.Event._removeElementObservers.apply(this, [t]) } OpenLayers.Event.observers = !1 } }, CLASS_NAME: "OpenLayers.Event" }, OpenLayers.Event.observe(window, "unload", OpenLayers.Event.unloadCache, !1), OpenLayers.Events = OpenLayers.Class({ BROWSER_EVENTS: ["mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "click", "dblclick", "rightclick", "dblrightclick", "resize", "focus", "blur", "touchstart", "touchmove", "touchend", "keydown"], listeners: null, object: null, element: null, eventHandler: null, fallThrough: null, includeXY: !1, extensions: null, extensionCount: null, clearMouseListener: null, initialize: function (e, t, n, i, s) { OpenLayers.Util.extend(this, s), this.object = e, this.fallThrough = i, this.listeners = {}, this.extensions = {}, this.extensionCount = {}, this._msTouches = [], null != t && this.attachToElement(t) }, destroy: function () { for (var e in this.extensions) "boolean" != typeof this.extensions[e] && this.extensions[e].destroy(); this.extensions = null, this.element && (OpenLayers.Event.stopObservingElement(this.element), this.element.hasScrollEvent && OpenLayers.Event.stopObserving(window, "scroll", this.clearMouseListener)), this.element = null, this.listeners = null, this.object = null, this.fallThrough = null, this.eventHandler = null }, addEventType: function (e) { }, attachToElement: function (e) { this.element ? OpenLayers.Event.stopObservingElement(this.element) : (this.eventHandler = OpenLayers.Function.bindAsEventListener(this.handleBrowserEvent, this), this.clearMouseListener = OpenLayers.Function.bind(this.clearMouseCache, this)), this.element = e; for (var t, n = !!window.navigator.msMaxTouchPoints, i = 0, s = this.BROWSER_EVENTS.length; i < s; i++)t = this.BROWSER_EVENTS[i], OpenLayers.Event.observe(e, t, this.eventHandler), n && 0 === t.indexOf("touch") && this.addMsTouchListener(e, t, this.eventHandler); OpenLayers.Event.observe(e, "dragstart", OpenLayers.Event.stop) }, on: function (e) { for (var t in e) "scope" != t && e.hasOwnProperty(t) && this.register(t, e.scope, e[t]) }, register: function (e, t, n, i) { if (e in OpenLayers.Events && !this.extensions[e] && (this.extensions[e] = new OpenLayers.Events[e](this)), null != n) { null == t && (t = this.object); var s = this.listeners[e]; s || (s = [], this.listeners[e] = s, this.extensionCount[e] = 0); var r = { obj: t, func: n }; i ? (s.splice(this.extensionCount[e], 0, r), "object" == typeof i && i.extension && this.extensionCount[e]++) : s.push(r) } }, registerPriority: function (e, t, n) { this.register(e, t, n, !0) }, un: function (e) { for (var t in e) "scope" != t && e.hasOwnProperty(t) && this.unregister(t, e.scope, e[t]) }, unregister: function (e, t, n) { null == t && (t = this.object); var i = this.listeners[e]; if (null != i) for (var s = 0, r = i.length; s < r; s++)if (i[s].obj == t && i[s].func == n) { i.splice(s, 1); break } }, remove: function (e) { null != this.listeners[e] && (this.listeners[e] = []) }, triggerEvent: function (e, t) { var n = this.listeners[e]; if (n && 0 != n.length) { var i; null == t && (t = {}), t.object = this.object, t.element = this.element, t.type || (t.type = e); for (var s = 0, r = (n = n.slice()).length; s < r; s++) { var a = n[s]; if (null != (i = a.func.apply(a.obj, [t])) && 0 == i) break } return this.fallThrough || OpenLayers.Event.stop(t, !0), i } }, handleBrowserEvent: function (e) { var t = e.type, n = this.listeners[t]; if (n && 0 != n.length) { var i = e.touches; if (i && i[0]) { for (var s, r = 0, a = 0, o = i.length, l = 0; l < o; ++l)r += (s = this.getTouchClientXY(i[l])).clientX, a += s.clientY; e.clientX = r / o, e.clientY = a / o } this.includeXY && (e.xy = this.getMousePosition(e)), this.triggerEvent(t, e) } }, getTouchClientXY: function (e) { var t = window.olMockWin || window, n = t.pageXOffset, i = t.pageYOffset, s = e.clientX, r = e.clientY; return 0 === e.pageY && Math.floor(r) > Math.floor(e.pageY) || 0 === e.pageX && Math.floor(s) > Math.floor(e.pageX) ? (s -= n, r -= i) : (r < e.pageY - i || s < e.pageX - n) && (s = e.pageX - n, r = e.pageY - i), e.olClientX = s, e.olClientY = r, { clientX: s, clientY: r } }, clearMouseCache: function () { this.element.scrolls = null, this.element.lefttop = null, this.element.offsets = null }, getMousePosition: function (e) { if (this.includeXY ? this.element.hasScrollEvent || (OpenLayers.Event.observe(window, "scroll", this.clearMouseListener), this.element.hasScrollEvent = !0) : this.clearMouseCache(), !this.element.scrolls) { var t = OpenLayers.Util.getViewportElement(); this.element.scrolls = [window.pageXOffset || t.scrollLeft, window.pageYOffset || t.scrollTop] } return this.element.lefttop || (this.element.lefttop = [document.documentElement.clientLeft || 0, document.documentElement.clientTop || 0]), this.element.offsets || (this.element.offsets = OpenLayers.Util.pagePosition(this.element)), new OpenLayers.Pixel(e.clientX + this.element.scrolls[0] - this.element.offsets[0] - this.element.lefttop[0], e.clientY + this.element.scrolls[1] - this.element.offsets[1] - this.element.lefttop[1]) }, addMsTouchListener: function (e, t, n) { this.eventHandler; var i = this._msTouches; function s(e) { n(OpenLayers.Util.applyDefaults({ stopPropagation: function () { for (var e = i.length - 1; e >= 0; --e)i[e].stopPropagation() }, preventDefault: function () { for (var e = i.length - 1; e >= 0; --e)i[e].preventDefault() }, type: t }, e)) } switch (t) { case "touchstart": return this.addMsTouchListenerStart(e, t, s); case "touchend": return this.addMsTouchListenerEnd(e, t, s); case "touchmove": return this.addMsTouchListenerMove(e, t, s); default: throw "Unknown touch event type" } }, addMsTouchListenerStart: function (e, t, n) { var i = this._msTouches; OpenLayers.Event.observe(e, "MSPointerDown", function (e) { for (var t = !1, s = 0, r = i.length; s < r; ++s)if (i[s].pointerId == e.pointerId) { t = !0; break } t || i.push(e), e.touches = i.slice(), n(e) }); OpenLayers.Event.observe(e, "MSPointerUp", function (e) { for (var t = 0, n = i.length; t < n; ++t)if (i[t].pointerId == e.pointerId) { i.splice(t, 1); break } }) }, addMsTouchListenerMove: function (e, t, n) { var i = this._msTouches; OpenLayers.Event.observe(e, "MSPointerMove", function (e) { if (!(e.pointerType == e.MSPOINTER_TYPE_MOUSE && 0 == e.buttons || 1 == i.length && i[0].pageX == e.pageX && i[0].pageY == e.pageY)) { for (var t = 0, s = i.length; t < s; ++t)if (i[t].pointerId == e.pointerId) { i[t] = e; break } e.touches = i.slice(), n(e) } }) }, addMsTouchListenerEnd: function (e, t, n) { var i = this._msTouches; OpenLayers.Event.observe(e, "MSPointerUp", function (e) { for (var t = 0, s = i.length; t < s; ++t)if (i[t].pointerId == e.pointerId) { i.splice(t, 1); break } e.touches = i.slice(), n(e) }) }, CLASS_NAME: "OpenLayers.Events" }), OpenLayers.Events.buttonclick = OpenLayers.Class({ target: null, events: ["mousedown", "mouseup", "click", "dblclick", "touchstart", "touchmove", "touchend", "keydown"], startRegEx: /^mousedown|touchstart$/, cancelRegEx: /^touchmove$/, completeRegEx: /^mouseup|touchend$/, initialize: function (e) { this.target = e; for (var t = this.events.length - 1; t >= 0; --t)this.target.register(this.events[t], this, this.buttonClick, { extension: !0 }) }, destroy: function () { for (var e = this.events.length - 1; e >= 0; --e)this.target.unregister(this.events[e], this, this.buttonClick); delete this.target }, getPressedButton: function (e) { var t, n = 3; do { if (OpenLayers.Element.hasClass(e, "olButton")) { t = e; break } e = e.parentNode } while (--n > 0 && e); return t }, ignore: function (e) { var t = 3, n = !1; do { if ("a" === e.nodeName.toLowerCase()) { n = !0; break } e = e.parentNode } while (--t > 0 && e); return n }, buttonClick: function (e) { var t = !0, n = OpenLayers.Event.element(e); if (n && (OpenLayers.Event.isLeftClick(e) || !~e.type.indexOf("mouse"))) { var i = this.getPressedButton(n); if (i) { if ("keydown" === e.type) switch (e.keyCode) { case OpenLayers.Event.KEY_RETURN: case OpenLayers.Event.KEY_SPACE: this.target.triggerEvent("buttonclick", { buttonElement: i }), OpenLayers.Event.stop(e), t = !1 } else if (this.startEvt) { if (this.completeRegEx.test(e.type)) { var s = OpenLayers.Util.pagePosition(i), r = OpenLayers.Util.getViewportElement(), a = window.pageYOffset || r.scrollTop, o = window.pageXOffset || r.scrollLeft; s[0] = s[0] - o, s[1] = s[1] - a, this.target.triggerEvent("buttonclick", { buttonElement: i, buttonXY: { x: this.startEvt.clientX - s[0], y: this.startEvt.clientY - s[1] } }) } this.cancelRegEx.test(e.type) && delete this.startEvt, OpenLayers.Event.stop(e), t = !1 } this.startRegEx.test(e.type) && (this.startEvt = e, OpenLayers.Event.stop(e), t = !1) } else t = !this.ignore(OpenLayers.Event.element(e)), delete this.startEvt } return t } }), OpenLayers.Util = OpenLayers.Util || {}, OpenLayers.Util.vendorPrefix = function () { "use strict"; var e = ["", "O", "ms", "Moz", "Webkit"], t = document.createElement("div").style, n = {}, i = {}; function s(t, n) { if (void 0 === i[n]) { var s, r, a = 0, o = e.length, l = void 0 !== t.cssText; for (i[n] = null; a < o; a++)if ((r = e[a]) ? (l || (r = r.toLowerCase()), s = r + n.charAt(0).toUpperCase() + n.slice(1)) : s = n, void 0 !== t[s]) { i[n] = s; break } } return i[n] } function r(e) { return s(t, e) } return { css: function (e) { if (void 0 === n[e]) { var t = r(e.replace(/(-[\s\S])/g, function (e) { return e.charAt(1).toUpperCase() })); n[e] = function (e) { return e ? e.replace(/([A-Z])/g, function (e) { return "-" + e.toLowerCase() }).replace(/^ms-/, "-ms-") : null }(t) } return n[e] }, js: s, style: r, cssCache: n, jsCache: i } }(), OpenLayers.Animation = function (e) { var t, n = OpenLayers.Util.vendorPrefix.js(e, "requestAnimationFrame"), i = !!n, s = (t = e[n] || function (t, n) { e.setTimeout(t, 16) }, function (n, i) { t.apply(e, [n, i]) }), r = 0, a = {}; return { isNative: i, requestFrame: s, start: function (e, t, n) { t = t > 0 ? t : Number.POSITIVE_INFINITY; var i = ++r, o = +new Date; return a[i] = function () { a[i] && +new Date - o <= t ? (e(), a[i] && s(a[i], n)) : delete a[i] }, s(a[i], n), i }, stop: function (e) { delete a[e] } } }(window), OpenLayers.Tween = OpenLayers.Class({ easing: null, begin: null, finish: null, duration: null, callbacks: null, time: null, minFrameRate: null, startTime: null, animationId: null, playing: !1, initialize: function (e) { this.easing = e || OpenLayers.Easing.Expo.easeOut }, start: function (e, t, n, i) { this.playing = !0, this.begin = e, this.finish = t, this.duration = n, this.callbacks = i.callbacks, this.minFrameRate = i.minFrameRate || 30, this.time = 0, this.startTime = (new Date).getTime(), OpenLayers.Animation.stop(this.animationId), this.animationId = null, this.callbacks && this.callbacks.start && this.callbacks.start.call(this, this.begin), this.animationId = OpenLayers.Animation.start(OpenLayers.Function.bind(this.play, this)) }, stop: function () { this.playing && (this.callbacks && this.callbacks.done && this.callbacks.done.call(this, this.finish), OpenLayers.Animation.stop(this.animationId), this.animationId = null, this.playing = !1) }, play: function () { var e = {}; for (var t in this.begin) { var n = this.begin[t], i = this.finish[t]; if (null == n || null == i || isNaN(n) || isNaN(i)) throw new TypeError("invalid value for Tween"); var s = i - n; e[t] = this.easing.apply(this, [this.time, n, s, this.duration]) } this.time++ , this.callbacks && this.callbacks.eachStep && ((new Date).getTime() - this.startTime) / this.time <= 1e3 / this.minFrameRate && this.callbacks.eachStep.call(this, e), this.time > this.duration && this.stop() }, CLASS_NAME: "OpenLayers.Tween" }), OpenLayers.Easing = { CLASS_NAME: "OpenLayers.Easing" }, OpenLayers.Easing.Linear = { easeIn: function (e, t, n, i) { return n * e / i + t }, easeOut: function (e, t, n, i) { return n * e / i + t }, easeInOut: function (e, t, n, i) { return n * e / i + t }, CLASS_NAME: "OpenLayers.Easing.Linear" }, OpenLayers.Easing.Expo = { easeIn: function (e, t, n, i) { return 0 == e ? t : n * Math.pow(2, 10 * (e / i - 1)) + t }, easeOut: function (e, t, n, i) { return e == i ? t + n : n * (1 - Math.pow(2, -10 * e / i)) + t }, easeInOut: function (e, t, n, i) { return 0 == e ? t : e == i ? t + n : (e /= i / 2) < 1 ? n / 2 * Math.pow(2, 10 * (e - 1)) + t : n / 2 * (2 - Math.pow(2, -10 * --e)) + t }, CLASS_NAME: "OpenLayers.Easing.Expo" }, OpenLayers.Easing.Quad = { easeIn: function (e, t, n, i) { return n * (e /= i) * e + t }, easeOut: function (e, t, n, i) { return -n * (e /= i) * (e - 2) + t }, easeInOut: function (e, t, n, i) { return (e /= i / 2) < 1 ? n / 2 * e * e + t : -n / 2 * (--e * (e - 2) - 1) + t }, CLASS_NAME: "OpenLayers.Easing.Quad" }, OpenLayers.Projection = OpenLayers.Class({ proj: null, projCode: null, titleRegEx: /\+title=[^\+]*/, initialize: function (e, t) { OpenLayers.Util.extend(this, t), this.projCode = e, "object" == typeof Proj4js && (this.proj = new Proj4js.Proj(e)) }, getCode: function () { return this.proj ? this.proj.srsCode : this.projCode }, getUnits: function () { return this.proj ? this.proj.units : null }, toString: function () { return this.getCode() }, equals: function (e) { var t = e, n = !1; if (t) if (t instanceof OpenLayers.Projection || (t = new OpenLayers.Projection(t)), "object" == typeof Proj4js && this.proj.defData && t.proj.defData) n = this.proj.defData.replace(this.titleRegEx, "") == t.proj.defData.replace(this.titleRegEx, ""); else if (t.getCode) { var i = this.getCode(), s = t.getCode(); n = i == s || !!OpenLayers.Projection.transforms[i] && OpenLayers.Projection.transforms[i][s] === OpenLayers.Projection.nullTransform } return n }, destroy: function () { delete this.proj, delete this.projCode }, CLASS_NAME: "OpenLayers.Projection" }), OpenLayers.Projection.transforms = {}, OpenLayers.Projection.defaults = { "EPSG:4326": { units: "degrees", maxExtent: [-180, -90, 180, 90], yx: !0 }, "CRS:84": { units: "degrees", maxExtent: [-180, -90, 180, 90] }, "EPSG:900913": { units: "m", maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34] } }, OpenLayers.Projection.addTransform = function (e, t, n) { if (n === OpenLayers.Projection.nullTransform) { var i = OpenLayers.Projection.defaults[e]; i && !OpenLayers.Projection.defaults[t] && (OpenLayers.Projection.defaults[t] = i) } OpenLayers.Projection.transforms[e] || (OpenLayers.Projection.transforms[e] = {}), OpenLayers.Projection.transforms[e][t] = n }, OpenLayers.Projection.transform = function (e, t, n) { if (t && n) if (t instanceof OpenLayers.Projection || (t = new OpenLayers.Projection(t)), n instanceof OpenLayers.Projection || (n = new OpenLayers.Projection(n)), t.proj && n.proj) e = Proj4js.transform(t.proj, n.proj, e); else { var i = t.getCode(), s = n.getCode(), r = OpenLayers.Projection.transforms; r[i] && r[i][s] && r[i][s](e) } return e }, OpenLayers.Projection.nullTransform = function (e) { return e }, function () { var e = 20037508.34; function t(t) { return t.x = 180 * t.x / e, t.y = 180 / Math.PI * (2 * Math.atan(Math.exp(t.y / e * Math.PI)) - Math.PI / 2), t } function n(t) { t.x = t.x * e / 180; var n = Math.log(Math.tan((90 + t.y) * Math.PI / 360)) / Math.PI * e; return t.y = Math.max(-20037508.34, Math.min(n, 20037508.34)), t } function i(e, i) { var s, r, a, o, l, h = OpenLayers.Projection.addTransform, p = OpenLayers.Projection.nullTransform; for (s = 0, r = i.length; s < r; ++s)for (h(e, a = i[s], n), h(a, e, t), l = s + 1; l < r; ++l)h(a, o = i[l], p), h(o, a, p) } var s, r = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100"], a = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"]; for (s = r.length - 1; s >= 0; --s)i(r[s], a); for (s = a.length - 1; s >= 0; --s)i(a[s], r) }(), OpenLayers.Map = OpenLayers.Class({ Z_INDEX_BASE: { BaseLayer: 100, Overlay: 325, Feature: 725, Popup: 750, Control: 1e3 }, id: null, fractionalZoom: !1, events: null, allOverlays: !1, div: null, dragging: !1, size: null, viewPortDiv: null, layerContainerOrigin: null, layerContainerDiv: null, layers: null, controls: null, popups: null, baseLayer: null, center: null, resolution: null, zoom: 0, panRatio: 1.5, options: null, tileSize: null, projection: "EPSG:4326", units: null, resolutions: null, maxResolution: null, minResolution: null, maxScale: null, minScale: null, maxExtent: null, minExtent: null, restrictedExtent: null, numZoomLevels: 16, theme: null, displayProjection: null, fallThrough: !1, autoUpdateSize: !0, eventListeners: null, panTween: null, panMethod: OpenLayers.Easing.Expo.easeOut, panDuration: 50, zoomTween: null, zoomMethod: OpenLayers.Easing.Quad.easeOut, zoomDuration: 20, paddingForPopups: null, layerContainerOriginPx: null, minPx: null, maxPx: null, initialize: function (e, t) { 1 === arguments.length && "object" == typeof e && (e = (t = e) && t.div), this.tileSize = new OpenLayers.Size(OpenLayers.Map.TILE_WIDTH, OpenLayers.Map.TILE_HEIGHT), this.paddingForPopups = new OpenLayers.Bounds(15, 15, 15, 15), this.theme = OpenLayers._getScriptLocation() + "theme/default/style.css", this.options = OpenLayers.Util.extend({}, t), OpenLayers.Util.extend(this, t); var n = this.projection instanceof OpenLayers.Projection ? this.projection.projCode : this.projection; OpenLayers.Util.applyDefaults(this, OpenLayers.Projection.defaults[n]), !this.maxExtent || this.maxExtent instanceof OpenLayers.Bounds || (this.maxExtent = new OpenLayers.Bounds(this.maxExtent)), !this.minExtent || this.minExtent instanceof OpenLayers.Bounds || (this.minExtent = new OpenLayers.Bounds(this.minExtent)), !this.restrictedExtent || this.restrictedExtent instanceof OpenLayers.Bounds || (this.restrictedExtent = new OpenLayers.Bounds(this.restrictedExtent)), !this.center || this.center instanceof OpenLayers.LonLat || (this.center = new OpenLayers.LonLat(this.center)), this.layers = [], this.id = OpenLayers.Util.createUniqueID("OpenLayers.Map_"), this.div = OpenLayers.Util.getElement(e), this.div || (this.div = document.createElement("div"), this.div.style.height = "1px", this.div.style.width = "1px"), OpenLayers.Element.addClass(this.div, "olMap"); var i = this.id + "_OpenLayers_ViewPort"; if (this.viewPortDiv = OpenLayers.Util.createDiv(i, null, null, null, "relative", null, "hidden"), this.viewPortDiv.style.width = "100%", this.viewPortDiv.style.height = "100%", this.viewPortDiv.className = "olMapViewport", this.div.appendChild(this.viewPortDiv), this.events = new OpenLayers.Events(this, this.viewPortDiv, null, this.fallThrough, { includeXY: !0 }), OpenLayers.TileManager && null !== this.tileManager && (this.tileManager instanceof OpenLayers.TileManager || (this.tileManager = new OpenLayers.TileManager(this.tileManager)), this.tileManager.addMap(this)), i = this.id + "_OpenLayers_Container", this.layerContainerDiv = OpenLayers.Util.createDiv(i), this.layerContainerDiv.style.zIndex = this.Z_INDEX_BASE.Popup - 1, this.layerContainerOriginPx = { x: 0, y: 0 }, this.applyTransform(), this.viewPortDiv.appendChild(this.layerContainerDiv), this.updateSize(), this.eventListeners instanceof Object && this.events.on(this.eventListeners), !0 === this.autoUpdateSize && (this.updateSizeDestroy = OpenLayers.Function.bind(this.updateSize, this), OpenLayers.Event.observe(window, "resize", this.updateSizeDestroy)), this.theme) { for (var s = !0, r = document.getElementsByTagName("link"), a = 0, o = r.length; a < o; ++a)if (OpenLayers.Util.isEquivalentUrl(r.item(a).href, this.theme)) { s = !1; break } if (s) { var l = document.createElement("link"); l.setAttribute("rel", "stylesheet"), l.setAttribute("type", "text/css"), l.setAttribute("href", this.theme), document.getElementsByTagName("head")[0].appendChild(l) } } null == this.controls && (this.controls = [], null != OpenLayers.Control && (OpenLayers.Control.Navigation ? this.controls.push(new OpenLayers.Control.Navigation) : OpenLayers.Control.TouchNavigation && this.controls.push(new OpenLayers.Control.TouchNavigation), OpenLayers.Control.Zoom ? this.controls.push(new OpenLayers.Control.Zoom) : OpenLayers.Control.PanZoom && this.controls.push(new OpenLayers.Control.PanZoom), OpenLayers.Control.ArgParser && this.controls.push(new OpenLayers.Control.ArgParser), OpenLayers.Control.Attribution && this.controls.push(new OpenLayers.Control.Attribution))); for (a = 0, o = this.controls.length; a < o; a++)this.addControlToMap(this.controls[a]); this.popups = [], this.unloadDestroy = OpenLayers.Function.bind(this.destroy, this), OpenLayers.Event.observe(window, "unload", this.unloadDestroy), t && t.layers && (delete this.center, delete this.zoom, this.addLayers(t.layers), t.center && !this.getCenter() && this.setCenter(t.center, t.zoom)), this.panMethod && (this.panTween = new OpenLayers.Tween(this.panMethod)), this.zoomMethod && this.applyTransform.transform && (this.zoomTween = new OpenLayers.Tween(this.zoomMethod)) }, getViewport: function () { return this.viewPortDiv }, render: function (e) { this.div = OpenLayers.Util.getElement(e), OpenLayers.Element.addClass(this.div, "olMap"), this.viewPortDiv.parentNode.removeChild(this.viewPortDiv), this.div.appendChild(this.viewPortDiv), this.updateSize() }, unloadDestroy: null, updateSizeDestroy: null, destroy: function () { if (!this.unloadDestroy) return !1; if (this.panTween && (this.panTween.stop(), this.panTween = null), this.zoomTween && (this.zoomTween.stop(), this.zoomTween = null), OpenLayers.Event.stopObserving(window, "unload", this.unloadDestroy), this.unloadDestroy = null, this.updateSizeDestroy && OpenLayers.Event.stopObserving(window, "resize", this.updateSizeDestroy), this.paddingForPopups = null, null != this.controls) { for (var e = this.controls.length - 1; e >= 0; --e)this.controls[e].destroy(); this.controls = null } if (null != this.layers) { for (e = this.layers.length - 1; e >= 0; --e)this.layers[e].destroy(!1); this.layers = null } this.viewPortDiv && this.viewPortDiv.parentNode && this.viewPortDiv.parentNode.removeChild(this.viewPortDiv), this.viewPortDiv = null, this.tileManager && (this.tileManager.removeMap(this), this.tileManager = null), this.eventListeners && (this.events.un(this.eventListeners), this.eventListeners = null), this.events.destroy(), this.events = null, this.options = null }, setOptions: function (e) { var t = this.minPx && e.restrictedExtent != this.restrictedExtent; OpenLayers.Util.extend(this, e), t && this.moveTo(this.getCachedCenter(), this.zoom, { forceZoomChange: !0 }) }, getTileSize: function () { return this.tileSize }, getBy: function (e, t, n) { var i = "function" == typeof n.test; return OpenLayers.Array.filter(this[e], function (e) { return e[t] == n || i && n.test(e[t]) }) }, getLayersBy: function (e, t) { return this.getBy("layers", e, t) }, getLayersByName: function (e) { return this.getLayersBy("name", e) }, getLayersByClass: function (e) { return this.getLayersBy("CLASS_NAME", e) }, getControlsBy: function (e, t) { return this.getBy("controls", e, t) }, getControlsByClass: function (e) { return this.getControlsBy("CLASS_NAME", e) }, getLayer: function (e) { for (var t = null, n = 0, i = this.layers.length; n < i; n++) { var s = this.layers[n]; if (s.id == e) { t = s; break } } return t }, setLayerZIndex: function (e, t) { e.setZIndex(this.Z_INDEX_BASE[e.isBaseLayer ? "BaseLayer" : "Overlay"] + 5 * t) }, resetLayersZIndex: function () { for (var e = 0, t = this.layers.length; e < t; e++) { var n = this.layers[e]; this.setLayerZIndex(n, e) } }, addLayer: function (e) { for (var t = 0, n = this.layers.length; t < n; t++)if (this.layers[t] == e) return !1; return !1 !== this.events.triggerEvent("preaddlayer", { layer: e }) && (this.allOverlays && (e.isBaseLayer = !1), e.div.className = "olLayerDiv", e.div.style.overflow = "", this.setLayerZIndex(e, this.layers.length), e.isFixed ? this.viewPortDiv.appendChild(e.div) : this.layerContainerDiv.appendChild(e.div), this.layers.push(e), e.setMap(this), e.isBaseLayer || this.allOverlays && !this.baseLayer ? null == this.baseLayer ? this.setBaseLayer(e) : e.setVisibility(!1) : e.redraw(), this.events.triggerEvent("addlayer", { layer: e }), e.events.triggerEvent("added", { map: this, layer: e }), e.afterAdd(), !0) }, addLayers: function (e) { for (var t = 0, n = e.length; t < n; t++)this.addLayer(e[t]) }, removeLayer: function (e, t) { if (!1 !== this.events.triggerEvent("preremovelayer", { layer: e })) { if (null == t && (t = !0), e.isFixed ? this.viewPortDiv.removeChild(e.div) : this.layerContainerDiv.removeChild(e.div), OpenLayers.Util.removeItem(this.layers, e), e.removeMap(this), e.map = null, this.baseLayer == e && (this.baseLayer = null, t)) for (var n = 0, i = this.layers.length; n < i; n++) { var s = this.layers[n]; if (s.isBaseLayer || this.allOverlays) { this.setBaseLayer(s); break } } this.resetLayersZIndex(), this.events.triggerEvent("removelayer", { layer: e }), e.events.triggerEvent("removed", { map: this, layer: e }) } }, getNumLayers: function () { return this.layers.length }, getLayerIndex: function (e) { return OpenLayers.Util.indexOf(this.layers, e) }, setLayerIndex: function (e, t) { var n = this.getLayerIndex(e); if (t < 0 ? t = 0 : t > this.layers.length && (t = this.layers.length), n != t) { this.layers.splice(n, 1), this.layers.splice(t, 0, e); for (var i = 0, s = this.layers.length; i < s; i++)this.setLayerZIndex(this.layers[i], i); this.events.triggerEvent("changelayer", { layer: e, property: "order" }), this.allOverlays && (0 === t ? this.setBaseLayer(e) : this.baseLayer !== this.layers[0] && this.setBaseLayer(this.layers[0])) } }, raiseLayer: function (e, t) { var n = this.getLayerIndex(e) + t; this.setLayerIndex(e, n) }, setBaseLayer: function (e) { if (e != this.baseLayer && -1 != OpenLayers.Util.indexOf(this.layers, e)) { var t = this.getCachedCenter(), n = OpenLayers.Util.getResolutionFromScale(this.getScale(), e.units); if (null == this.baseLayer || this.allOverlays || this.baseLayer.setVisibility(!1), this.baseLayer = e, this.allOverlays && !this.baseLayer.visibility || (this.baseLayer.setVisibility(!0), !1 === this.baseLayer.inRange && this.baseLayer.redraw()), null != t) { var i = this.getZoomForResolution(n || this.resolution, !0); this.setCenter(t, i, !1, !0) } this.events.triggerEvent("changebaselayer", { layer: this.baseLayer }) } }, addControl: function (e, t) { this.controls.push(e), this.addControlToMap(e, t) }, addControls: function (e, t) { for (var n = 1 === arguments.length ? [] : t, i = 0, s = e.length; i < s; i++) { var r = e[i], a = n[i] ? n[i] : null; this.addControl(r, a) } }, addControlToMap: function (e, t) { e.outsideViewport = null != e.div, this.displayProjection && !e.displayProjection && (e.displayProjection = this.displayProjection), e.setMap(this); var n = e.draw(t); n && (e.outsideViewport || (n.style.zIndex = this.Z_INDEX_BASE.Control + this.controls.length, this.viewPortDiv.appendChild(n))), e.autoActivate && e.activate() }, getControl: function (e) { for (var t = null, n = 0, i = this.controls.length; n < i; n++) { var s = this.controls[n]; if (s.id == e) { t = s; break } } return t }, removeControl: function (e) { e && e == this.getControl(e.id) && (e.div && e.div.parentNode == this.viewPortDiv && this.viewPortDiv.removeChild(e.div), OpenLayers.Util.removeItem(this.controls, e)) }, addPopup: function (e, t) { if (t) for (var n = this.popups.length - 1; n >= 0; --n)this.removePopup(this.popups[n]); e.map = this, this.popups.push(e); var i = e.draw(); i && (i.style.zIndex = this.Z_INDEX_BASE.Popup + this.popups.length, this.layerContainerDiv.appendChild(i)) }, removePopup: function (e) { if (OpenLayers.Util.removeItem(this.popups, e), e.div) try { this.layerContainerDiv.removeChild(e.div) } catch (e) { } e.map = null }, getSize: function () { var e = null; return null != this.size && (e = this.size.clone()), e }, updateSize: function () { var e = this.getCurrentSize(); if (e && !isNaN(e.h) && !isNaN(e.w)) { this.events.clearMouseCache(); var t = this.getSize(); if (null == t && (this.size = t = e), !e.equals(t)) { this.size = e; for (var n = 0, i = this.layers.length; n < i; n++)this.layers[n].onMapResize(); var s = this.getCachedCenter(); if (null != this.baseLayer && null != s) { var r = this.getZoom(); this.zoom = null, this.setCenter(s, r) } } } this.events.triggerEvent("updatesize") }, getCurrentSize: function () { var e = new OpenLayers.Size(this.div.clientWidth, this.div.clientHeight); return (0 == e.w && 0 == e.h || isNaN(e.w) && isNaN(e.h)) && (e.w = this.div.offsetWidth, e.h = this.div.offsetHeight), (0 == e.w && 0 == e.h || isNaN(e.w) && isNaN(e.h)) && (e.w = parseInt(this.div.style.width), e.h = parseInt(this.div.style.height)), e }, calculateBounds: function (e, t) { var n = null; if (null == e && (e = this.getCachedCenter()), null == t && (t = this.getResolution()), null != e && null != t) { var i = this.size.w * t / 2, s = this.size.h * t / 2; n = new OpenLayers.Bounds(e.lon - i, e.lat - s, e.lon + i, e.lat + s) } return n }, getCenter: function () { var e = null, t = this.getCachedCenter(); return t && (e = t.clone()), e }, getCachedCenter: function () { return !this.center && this.size && (this.center = this.getLonLatFromViewPortPx({ x: this.size.w / 2, y: this.size.h / 2 })), this.center }, getZoom: function () { return this.zoom }, pan: function (e, t, n) { if ((n = OpenLayers.Util.applyDefaults(n, { animate: !0, dragging: !1 })).dragging) 0 == e && 0 == t || this.moveByPx(e, t); else { var i = this.getViewPortPxFromLonLat(this.getCachedCenter()), s = i.add(e, t); if (this.dragging || !s.equals(i)) { var r = this.getLonLatFromViewPortPx(s); n.animate ? this.panTo(r) : (this.moveTo(r), this.dragging && (this.dragging = !1, this.events.triggerEvent("moveend"))) } } }, panTo: function (e) { if (this.panTween && this.getExtent().scale(this.panRatio).containsLonLat(e)) { var t = this.getCachedCenter(); if (e.equals(t)) return; var n = this.getPixelFromLonLat(t), i = this.getPixelFromLonLat(e), s = { x: i.x - n.x, y: i.y - n.y }, r = { x: 0, y: 0 }; this.panTween.start({ x: 0, y: 0 }, s, this.panDuration, { callbacks: { eachStep: OpenLayers.Function.bind(function (e) { var t = e.x - r.x, n = e.y - r.y; this.moveByPx(t, n), r.x = Math.round(e.x), r.y = Math.round(e.y) }, this), done: OpenLayers.Function.bind(function (t) { this.moveTo(e), this.dragging = !1, this.events.triggerEvent("moveend") }, this) } }) } else this.setCenter(e) }, setCenter: function (e, t, n, i) { this.panTween && this.panTween.stop(), this.zoomTween && this.zoomTween.stop(), this.moveTo(e, t, { dragging: n, forceZoomChange: i }) }, moveByPx: function (e, t) { var n = this.size.w / 2, i = this.size.h / 2, s = n + e, r = i + t, a = this.baseLayer.wrapDateLine, o = 0, l = 0; if (this.restrictedExtent && (o = n, l = i, a = !1), e = a || s <= this.maxPx.x - o && s >= this.minPx.x + o ? Math.round(e) : 0, t = r <= this.maxPx.y - l && r >= this.minPx.y + l ? Math.round(t) : 0, e || t) { var h, p, u; for (this.dragging || (this.dragging = !0, this.events.triggerEvent("movestart")), this.center = null, e && (this.layerContainerOriginPx.x -= e, this.minPx.x -= e, this.maxPx.x -= e), t && (this.layerContainerOriginPx.y -= t, this.minPx.y -= t, this.maxPx.y -= t), this.applyTransform(), p = 0, u = this.layers.length; p < u; ++p)(h = this.layers[p]).visibility && (h === this.baseLayer || h.inRange) && (h.moveByPx(e, t), h.events.triggerEvent("move")); this.events.triggerEvent("move") } }, adjustZoom: function (e) { if (this.baseLayer && this.baseLayer.wrapDateLine) { var t = this.baseLayer.resolutions, n = this.getMaxExtent().getWidth() / this.size.w; if (this.getResolutionForZoom(e) > n) if (this.fractionalZoom) e = this.getZoomForResolution(n); else for (var i = 0 | e, s = t.length; i < s; ++i)if (t[i] <= n) { e = i; break } } return e }, getMinZoom: function () { return this.adjustZoom(0) }, moveTo: function (e, t, n) { null == e || e instanceof OpenLayers.LonLat || (e = new OpenLayers.LonLat(e)), n || (n = {}), null != t && (t = parseFloat(t), this.fractionalZoom || (t = Math.round(t))); var i = t; (t = this.adjustZoom(t)) !== i && (e = this.getCenter()); var s = n.dragging || this.dragging, r = n.forceZoomChange; if (this.getCachedCenter() || this.isValidLonLat(e) || (e = this.maxExtent.getCenterLonLat(), this.center = e.clone()), null != this.restrictedExtent) { null == e && (e = this.center), null == t && (t = this.getZoom()); var a = this.getResolutionForZoom(t), o = this.calculateBounds(e, a); if (!this.restrictedExtent.containsBounds(o)) { var l = this.restrictedExtent.getCenterLonLat(); o.getWidth() > this.restrictedExtent.getWidth() ? e = new OpenLayers.LonLat(l.lon, e.lat) : o.left < this.restrictedExtent.left ? e = e.add(this.restrictedExtent.left - o.left, 0) : o.right > this.restrictedExtent.right && (e = e.add(this.restrictedExtent.right - o.right, 0)), o.getHeight() > this.restrictedExtent.getHeight() ? e = new OpenLayers.LonLat(e.lon, l.lat) : o.bottom < this.restrictedExtent.bottom ? e = e.add(0, this.restrictedExtent.bottom - o.bottom) : o.top > this.restrictedExtent.top && (e = e.add(0, this.restrictedExtent.top - o.top)) } } var h = r || this.isValidZoomLevel(t) && t != this.getZoom(), p = this.isValidLonLat(e) && !e.equals(this.center); if (h || p || s) { s || this.events.triggerEvent("movestart", { zoomChanged: h }), p && (!h && this.center && this.centerLayerContainer(e), this.center = e.clone()); var u = h ? this.getResolutionForZoom(t) : this.getResolution(); if (h || null == this.layerContainerOrigin) { this.layerContainerOrigin = this.getCachedCenter(), this.layerContainerOriginPx.x = 0, this.layerContainerOriginPx.y = 0, this.applyTransform(); var y = this.getMaxExtent({ restricted: !0 }), c = y.getCenterLonLat(), d = this.center.lon - c.lon, f = c.lat - this.center.lat, m = Math.round(y.getWidth() / u), g = Math.round(y.getHeight() / u); this.minPx = { x: (this.size.w - m) / 2 - d / u, y: (this.size.h - g) / 2 - f / u }, this.maxPx = { x: this.minPx.x + Math.round(y.getWidth() / u), y: this.minPx.y + Math.round(y.getHeight() / u) } } h && (this.zoom = t, this.resolution = u); var L = this.getExtent(); this.baseLayer.visibility && (this.baseLayer.moveTo(L, h, n.dragging), n.dragging || this.baseLayer.events.triggerEvent("moveend", { zoomChanged: h })), L = this.baseLayer.getExtent(); for (var v = this.layers.length - 1; v >= 0; --v) { var O = this.layers[v]; if (O !== this.baseLayer && !O.isBaseLayer) { var x = O.calculateInRange(); O.inRange != x && (O.inRange = x, x || O.display(!1), this.events.triggerEvent("changelayer", { layer: O, property: "visibility" })), x && O.visibility && (O.moveTo(L, h, n.dragging), n.dragging || O.events.triggerEvent("moveend", { zoomChanged: h })) } } if (this.events.triggerEvent("move"), s || this.events.triggerEvent("moveend"), h) { v = 0; for (var E = this.popups.length; v < E; v++)this.popups[v].updatePosition(); this.events.triggerEvent("zoomend") } } }, centerLayerContainer: function (e) { var t = this.getViewPortPxFromLonLat(this.layerContainerOrigin), n = this.getViewPortPxFromLonLat(e); if (null != t && null != n) { var i = this.layerContainerOriginPx.x, s = this.layerContainerOriginPx.y, r = Math.round(t.x - n.x), a = Math.round(t.y - n.y); this.applyTransform(this.layerContainerOriginPx.x = r, this.layerContainerOriginPx.y = a); var o = i - r, l = s - a; this.minPx.x -= o, this.maxPx.x -= o, this.minPx.y -= l, this.maxPx.y -= l } }, isValidZoomLevel: function (e) { return null != e && e >= 0 && e < this.getNumZoomLevels() }, isValidLonLat: function (e) { var t = !1; if (null != e) { var n = this.getMaxExtent(), i = this.baseLayer.wrapDateLine && n; t = n.containsLonLat(e, { worldBounds: i }) } return t }, getProjection: function () { var e = this.getProjectionObject(); return e ? e.getCode() : null }, getProjectionObject: function () { var e = null; return null != this.baseLayer && (e = this.baseLayer.projection), e }, getMaxResolution: function () { var e = null; return null != this.baseLayer && (e = this.baseLayer.maxResolution), e }, getMaxExtent: function (e) { var t = null; return e && e.restricted && this.restrictedExtent ? t = this.restrictedExtent : null != this.baseLayer && (t = this.baseLayer.maxExtent), t }, getNumZoomLevels: function () { var e = null; return null != this.baseLayer && (e = this.baseLayer.numZoomLevels), e }, getExtent: function () { var e = null; return null != this.baseLayer && (e = this.baseLayer.getExtent()), e }, getResolution: function () { var e = null; return null != this.baseLayer ? e = this.baseLayer.getResolution() : !0 === this.allOverlays && this.layers.length > 0 && (e = this.layers[0].getResolution()), e }, getUnits: function () { var e = null; return null != this.baseLayer && (e = this.baseLayer.units), e }, getScale: function () { var e = null; if (null != this.baseLayer) { var t = this.getResolution(), n = this.baseLayer.units; e = OpenLayers.Util.getScaleFromResolution(t, n) } return e }, getZoomForExtent: function (e, t) { var n = null; return null != this.baseLayer && (n = this.baseLayer.getZoomForExtent(e, t)), n }, getResolutionForZoom: function (e) { var t = null; return this.baseLayer && (t = this.baseLayer.getResolutionForZoom(e)), t }, getZoomForResolution: function (e, t) { var n = null; return null != this.baseLayer && (n = this.baseLayer.getZoomForResolution(e, t)), n }, zoomTo: function (e, t) { var n = this; if (n.isValidZoomLevel(e)) if (n.baseLayer.wrapDateLine && (e = n.adjustZoom(e)), n.zoomTween) { var i = { scale: n.getResolution() / n.getResolutionForZoom(e) }; if (n.zoomTween.playing && n.zoomTween.duration < 3 * n.zoomDuration) n.zoomTween.finish = { scale: n.zoomTween.finish.scale * i.scale }; else { if (!t) { var s = n.getSize(); t = { x: s.w / 2, y: s.h / 2 } } n.zoomTween.start({ scale: 1 }, i, n.zoomDuration, { minFrameRate: 50, callbacks: { eachStep: function (e) { var i = n.layerContainerOriginPx, s = e.scale, r = (s - 1) * (i.x - t.x) | 0, a = (s - 1) * (i.y - t.y) | 0; n.applyTransform(i.x + r, i.y + a, s) }, done: function (e) { n.applyTransform(); var i = n.getResolution() / e.scale, s = n.getZoomForResolution(i, !0); n.moveTo(n.getZoomTargetCenter(t, i), s, !0) } } }) } } else { var r = t ? n.getZoomTargetCenter(t, n.getResolutionForZoom(e)) : null; n.setCenter(r, e) } }, zoomIn: function () { this.zoomTo(this.getZoom() + 1) }, zoomOut: function () { this.zoomTo(this.getZoom() - 1) }, zoomToExtent: function (e, t) { e instanceof OpenLayers.Bounds || (e = new OpenLayers.Bounds(e)); var n = e.getCenterLonLat(); if (this.baseLayer.wrapDateLine) { var i = this.getMaxExtent(); for (e = e.clone(); e.right < e.left;)e.right += i.getWidth(); n = e.getCenterLonLat().wrapDateLine(i) } this.setCenter(n, this.getZoomForExtent(e, t)) }, zoomToMaxExtent: function (e) { var t = !e || e.restricted, n = this.getMaxExtent({ restricted: t }); this.zoomToExtent(n) }, zoomToScale: function (e, t) { var n = OpenLayers.Util.getResolutionFromScale(e, this.baseLayer.units), i = this.size.w * n / 2, s = this.size.h * n / 2, r = this.getCachedCenter(), a = new OpenLayers.Bounds(r.lon - i, r.lat - s, r.lon + i, r.lat + s); this.zoomToExtent(a, t) }, getLonLatFromViewPortPx: function (e) { var t = null; return null != this.baseLayer && (t = this.baseLayer.getLonLatFromViewPortPx(e)), t }, getViewPortPxFromLonLat: function (e) { var t = null; return null != this.baseLayer && (t = this.baseLayer.getViewPortPxFromLonLat(e)), t }, getZoomTargetCenter: function (e, t) { var n = null, i = this.getSize(), s = i.w / 2 - e.x, r = e.y - i.h / 2, a = this.getLonLatFromPixel(e); return a && (n = new OpenLayers.LonLat(a.lon + s * t, a.lat + r * t)), n }, getLonLatFromPixel: function (e) { return this.getLonLatFromViewPortPx(e) }, getPixelFromLonLat: function (e) { var t = this.getViewPortPxFromLonLat(e); return t.x = Math.round(t.x), t.y = Math.round(t.y), t }, getGeodesicPixelSize: function (e) { var t = e ? this.getLonLatFromPixel(e) : this.getCachedCenter() || new OpenLayers.LonLat(0, 0), n = this.getResolution(), i = t.add(-n / 2, 0), s = t.add(n / 2, 0), r = t.add(0, -n / 2), a = t.add(0, n / 2), o = new OpenLayers.Projection("EPSG:4326"), l = this.getProjectionObject() || o; return l.equals(o) || (i.transform(l, o), s.transform(l, o), r.transform(l, o), a.transform(l, o)), new OpenLayers.Size(OpenLayers.Util.distVincenty(i, s), OpenLayers.Util.distVincenty(r, a)) }, getViewPortPxFromLayerPx: function (e) { var t = null; if (null != e) { var n = this.layerContainerOriginPx.x, i = this.layerContainerOriginPx.y; t = e.add(n, i) } return t }, getLayerPxFromViewPortPx: function (e) { var t = null; if (null != e) { var n = -this.layerContainerOriginPx.x, i = -this.layerContainerOriginPx.y; t = e.add(n, i), (isNaN(t.x) || isNaN(t.y)) && (t = null) } return t }, getLonLatFromLayerPx: function (e) { return e = this.getViewPortPxFromLayerPx(e), this.getLonLatFromViewPortPx(e) }, getLayerPxFromLonLat: function (e) { var t = this.getPixelFromLonLat(e); return this.getLayerPxFromViewPortPx(t) }, applyTransform: function (e, t, n) { n = n || 1; var i = this.layerContainerOriginPx, s = 1 !== n; e = e || i.x, t = t || i.y; var r = this.layerContainerDiv.style, a = this.applyTransform.transform, o = this.applyTransform.template; if (void 0 === a && (a = OpenLayers.Util.vendorPrefix.style("transform"), this.applyTransform.transform = a, a)) { var l = OpenLayers.Element.getStyle(this.viewPortDiv, OpenLayers.Util.vendorPrefix.css("transform")); l && "none" === l || (o = ["translate3d(", ",0) ", "scale3d(", ",1)"], r[a] = [o[0], "0,0", o[1]].join("")), o && ~r[a].indexOf(o[0]) || (o = ["translate(", ") ", "scale(", ")"]), this.applyTransform.template = o } null === a || "translate3d(" !== o[0] && !0 !== s ? (r.left = e + "px", r.top = t + "px", null !== a && (r[a] = "")) : (!0 === s && "translate(" === o[0] && (e -= i.x, t -= i.y, r.left = i.x + "px", r.top = i.y + "px"), r[a] = [o[0], e, "px,", t, "px", o[1], o[2], n, ",", n, o[3]].join("")) }, CLASS_NAME: "OpenLayers.Map" }), OpenLayers.Map.TILE_WIDTH = 256, OpenLayers.Map.TILE_HEIGHT = 256, OpenLayers.Layer = OpenLayers.Class({ id: null, name: null, div: null, opacity: 1, alwaysInRange: null, RESOLUTION_PROPERTIES: ["scales", "resolutions", "maxScale", "minScale", "maxResolution", "minResolution", "numZoomLevels", "maxZoomLevel"], events: null, map: null, isBaseLayer: !1, alpha: !1, displayInLayerSwitcher: !0, visibility: !0, attribution: null, inRange: !1, imageSize: null, options: null, eventListeners: null, gutter: 0, projection: null, units: null, scales: null, resolutions: null, maxExtent: null, minExtent: null, maxResolution: null, minResolution: null, numZoomLevels: null, minScale: null, maxScale: null, displayOutsideMaxExtent: !1, wrapDateLine: !1, metadata: null, initialize: function (e, t) { this.metadata = {}, t = OpenLayers.Util.extend({}, t), null != this.alwaysInRange && (t.alwaysInRange = this.alwaysInRange), this.addOptions(t), this.name = e, null == this.id && (this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_"), this.div = OpenLayers.Util.createDiv(this.id), this.div.style.width = "100%", this.div.style.height = "100%", this.div.dir = "ltr", this.events = new OpenLayers.Events(this, this.div), this.eventListeners instanceof Object && this.events.on(this.eventListeners)) }, destroy: function (e) { null == e && (e = !0), null != this.map && this.map.removeLayer(this, e), this.projection = null, this.map = null, this.name = null, this.div = null, this.options = null, this.events && (this.eventListeners && this.events.un(this.eventListeners), this.events.destroy()), this.eventListeners = null, this.events = null }, clone: function (e) { return null == e && (e = new OpenLayers.Layer(this.name, this.getOptions())), OpenLayers.Util.applyDefaults(e, this), e.map = null, e }, getOptions: function () { var e = {}; for (var t in this.options) e[t] = this[t]; return e }, setName: function (e) { e != this.name && (this.name = e, null != this.map && this.map.events.triggerEvent("changelayer", { layer: this, property: "name" })) }, addOptions: function (e, t) { if (null == this.options && (this.options = {}), e && ("string" == typeof e.projection && (e.projection = new OpenLayers.Projection(e.projection)), e.projection && OpenLayers.Util.applyDefaults(e, OpenLayers.Projection.defaults[e.projection.getCode()]), !e.maxExtent || e.maxExtent instanceof OpenLayers.Bounds || (e.maxExtent = new OpenLayers.Bounds(e.maxExtent)), !e.minExtent || e.minExtent instanceof OpenLayers.Bounds || (e.minExtent = new OpenLayers.Bounds(e.minExtent))), OpenLayers.Util.extend(this.options, e), OpenLayers.Util.extend(this, e), this.projection && this.projection.getUnits() && (this.units = this.projection.getUnits()), this.map) { var n = this.map.getResolution(), i = this.RESOLUTION_PROPERTIES.concat(["projection", "units", "minExtent", "maxExtent"]); for (var s in e) if (e.hasOwnProperty(s) && OpenLayers.Util.indexOf(i, s) >= 0) { this.initResolutions(), t && this.map.baseLayer === this && (this.map.setCenter(this.map.getCenter(), this.map.getZoomForResolution(n), !1, !0), this.map.events.triggerEvent("changebaselayer", { layer: this })); break } } }, onMapResize: function () { }, redraw: function () { var e = !1; if (this.map) { this.inRange = this.calculateInRange(); var t = this.getExtent(); if (t && this.inRange && this.visibility) { this.moveTo(t, !0, !1), this.events.triggerEvent("moveend", { zoomChanged: !0 }), e = !0 } } return e }, moveTo: function (e, t, n) { var i = this.visibility; this.isBaseLayer || (i = i && this.inRange), this.display(i) }, moveByPx: function (e, t) { }, setMap: function (e) { if (null == this.map) { if (this.map = e, this.maxExtent = this.maxExtent || this.map.maxExtent, this.minExtent = this.minExtent || this.map.minExtent, this.projection = this.projection || this.map.projection, "string" == typeof this.projection && (this.projection = new OpenLayers.Projection(this.projection)), this.units = this.projection.getUnits() || this.units || this.map.units, this.initResolutions(), !this.isBaseLayer) { this.inRange = this.calculateInRange(); var t = this.visibility && this.inRange; this.div.style.display = t ? "" : "none" } this.setTileSize() } }, afterAdd: function () { }, removeMap: function (e) { }, getImageSize: function (e) { return this.imageSize || this.tileSize }, setTileSize: function (e) { var t = e || (this.tileSize ? this.tileSize : this.map.getTileSize()); this.tileSize = t, this.gutter && (this.imageSize = new OpenLayers.Size(t.w + 2 * this.gutter, t.h + 2 * this.gutter)) }, getVisibility: function () { return this.visibility }, setVisibility: function (e) { e != this.visibility && (this.visibility = e, this.display(e), this.redraw(), null != this.map && this.map.events.triggerEvent("changelayer", { layer: this, property: "visibility" }), this.events.triggerEvent("visibilitychanged")) }, display: function (e) { e != ("none" != this.div.style.display) && (this.div.style.display = e && this.calculateInRange() ? "block" : "none") }, calculateInRange: function () { var e = !1; if (this.alwaysInRange) e = !0; else if (this.map) { var t = this.map.getResolution(); e = t >= this.minResolution && t <= this.maxResolution } return e }, setIsBaseLayer: function (e) { e != this.isBaseLayer && (this.isBaseLayer = e, null != this.map && this.map.events.triggerEvent("changebaselayer", { layer: this })) }, initResolutions: function () { var e, t, n, i, s, r = {}, a = !0; for (e = 0, t = this.RESOLUTION_PROPERTIES.length; e < t; e++)r[n = this.RESOLUTION_PROPERTIES[e]] = this.options[n], a && this.options[n] && (a = !1); if (null == this.options.alwaysInRange && (this.alwaysInRange = a), null == r.resolutions && (r.resolutions = this.resolutionsFromScales(r.scales)), null == r.resolutions && (r.resolutions = this.calculateResolutions(r)), null == r.resolutions) { for (e = 0, t = this.RESOLUTION_PROPERTIES.length; e < t; e++)r[n = this.RESOLUTION_PROPERTIES[e]] = null != this.options[n] ? this.options[n] : this.map[n]; null == r.resolutions && (r.resolutions = this.resolutionsFromScales(r.scales)), null == r.resolutions && (r.resolutions = this.calculateResolutions(r)) } if (this.options.maxResolution && "auto" !== this.options.maxResolution && (i = this.options.maxResolution), this.options.minScale && (i = OpenLayers.Util.getResolutionFromScale(this.options.minScale, this.units)), this.options.minResolution && "auto" !== this.options.minResolution && (s = this.options.minResolution), this.options.maxScale && (s = OpenLayers.Util.getResolutionFromScale(this.options.maxScale, this.units)), r.resolutions && (r.resolutions.sort(function (e, t) { return t - e }), i || (i = r.resolutions[0]), !s)) { var o = r.resolutions.length - 1; s = r.resolutions[o] } if (this.resolutions = r.resolutions, this.resolutions) { for (t = this.resolutions.length, this.scales = new Array(t), e = 0; e < t; e++)this.scales[e] = OpenLayers.Util.getScaleFromResolution(this.resolutions[e], this.units); this.numZoomLevels = t } this.minResolution = s, s && (this.maxScale = OpenLayers.Util.getScaleFromResolution(s, this.units)), this.maxResolution = i, i && (this.minScale = OpenLayers.Util.getScaleFromResolution(i, this.units)) }, resolutionsFromScales: function (e) { if (null != e) { var t, n, i; for (i = e.length, t = new Array(i), n = 0; n < i; n++)t[n] = OpenLayers.Util.getResolutionFromScale(e[n], this.units); return t } }, calculateResolutions: function (e) { var t, n, i, s = e.maxResolution; null != e.minScale ? s = OpenLayers.Util.getResolutionFromScale(e.minScale, this.units) : "auto" == s && null != this.maxExtent && (t = this.map.getSize(), n = this.maxExtent.getWidth() / t.w, i = this.maxExtent.getHeight() / t.h, s = Math.max(n, i)); var r = e.minResolution; if (null != e.maxScale ? r = OpenLayers.Util.getResolutionFromScale(e.maxScale, this.units) : "auto" == e.minResolution && null != this.minExtent && (t = this.map.getSize(), n = this.minExtent.getWidth() / t.w, i = this.minExtent.getHeight() / t.h, r = Math.max(n, i)), "number" != typeof s && "number" != typeof r && null != this.maxExtent) { var a = this.map.getTileSize(); s = Math.max(this.maxExtent.getWidth() / a.w, this.maxExtent.getHeight() / a.h) } var o = e.maxZoomLevel, l = e.numZoomLevels; if ("number" == typeof r && "number" == typeof s && void 0 === l) { var h = s / r; l = Math.floor(Math.log(h) / Math.log(2)) + 1 } else void 0 === l && null != o && (l = o + 1); if (!("number" != typeof l || l <= 0 || "number" != typeof s && "number" != typeof r)) { var p, u = new Array(l), y = 2; if ("number" == typeof r && "number" == typeof s && (y = Math.pow(s / r, 1 / (l - 1))), "number" == typeof s) for (p = 0; p < l; p++)u[p] = s / Math.pow(y, p); else for (p = 0; p < l; p++)u[l - 1 - p] = r * Math.pow(y, p); return u } }, getResolution: function () { var e = this.map.getZoom(); return this.getResolutionForZoom(e) }, getExtent: function () { return this.map.calculateBounds() }, getZoomForExtent: function (e, t) { var n = this.map.getSize(), i = Math.max(e.getWidth() / n.w, e.getHeight() / n.h); return this.getZoomForResolution(i, t) }, getDataExtent: function () { }, getResolutionForZoom: function (e) { var t; if (e = Math.max(0, Math.min(e, this.resolutions.length - 1)), this.map.fractionalZoom) { var n = Math.floor(e), i = Math.ceil(e); t = this.resolutions[n] - (e - n) * (this.resolutions[n] - this.resolutions[i]) } else t = this.resolutions[Math.round(e)]; return t }, getZoomForResolution: function (e, t) { var n, i, s; if (this.map.fractionalZoom) { var r, a = 0, o = this.resolutions.length - 1, l = this.resolutions[a], h = this.resolutions[o]; for (i = 0, s = this.resolutions.length; i < s; ++i)if ((r = this.resolutions[i]) >= e && (l = r, a = i), r <= e) { h = r, o = i; break } var p = l - h; n = p > 0 ? a + (l - e) / p : a } else { var u, y = Number.POSITIVE_INFINITY; for (i = 0, s = this.resolutions.length; i < s; i++)if (t) { if ((u = Math.abs(this.resolutions[i] - e)) > y) break; y = u } else if (this.resolutions[i] < e) break; n = Math.max(0, i - 1) } return n }, getLonLatFromViewPortPx: function (e) { var t = null, n = this.map; if (null != e && n.minPx) { var i = n.getResolution(), s = n.getMaxExtent({ restricted: !0 }), r = (e.x - n.minPx.x) * i + s.left, a = (n.minPx.y - e.y) * i + s.top; t = new OpenLayers.LonLat(r, a), this.wrapDateLine && (t = t.wrapDateLine(this.maxExtent)) } return t }, getViewPortPxFromLonLat: function (e, t) { var n = null; if (null != e) { t = t || this.map.getResolution(); var i = this.map.calculateBounds(null, t); n = new OpenLayers.Pixel(1 / t * (e.lon - i.left), 1 / t * (i.top - e.lat)) } return n }, setOpacity: function (e) { if (e != this.opacity) { this.opacity = e; for (var t = this.div.childNodes, n = 0, i = t.length; n < i; ++n) { var s = t[n].firstChild || t[n], r = t[n].lastChild; r && "iframe" === r.nodeName.toLowerCase() && (s = r.parentNode), OpenLayers.Util.modifyDOMElement(s, null, null, null, null, null, null, e) } null != this.map && this.map.events.triggerEvent("changelayer", { layer: this, property: "opacity" }) } }, getZIndex: function () { return this.div.style.zIndex }, setZIndex: function (e) { this.div.style.zIndex = e }, adjustBounds: function (e) { if (this.gutter) { var t = this.gutter * this.map.getResolution(); e = new OpenLayers.Bounds(e.left - t, e.bottom - t, e.right + t, e.top + t) } if (this.wrapDateLine) { var n = { rightTolerance: this.getResolution(), leftTolerance: this.getResolution() }; e = e.wrapDateLine(this.maxExtent, n) } return e }, CLASS_NAME: "OpenLayers.Layer" }), OpenLayers.Layer.SphericalMercator = { getExtent: function () { return this.sphericalMercator ? this.map.calculateBounds() : OpenLayers.Layer.FixedZoomLevels.prototype.getExtent.apply(this) }, getLonLatFromViewPortPx: function (e) { return OpenLayers.Layer.prototype.getLonLatFromViewPortPx.apply(this, arguments) }, getViewPortPxFromLonLat: function (e) { return OpenLayers.Layer.prototype.getViewPortPxFromLonLat.apply(this, arguments) }, initMercatorParameters: function () { this.RESOLUTIONS = []; for (var e = 0; e <= this.MAX_ZOOM_LEVEL; ++e)this.RESOLUTIONS[e] = 156543.03390625 / Math.pow(2, e); this.units = "m", this.projection = this.projection || "EPSG:900913" }, forwardMercator: function () { var e = new OpenLayers.Projection("EPSG:4326"), t = new OpenLayers.Projection("EPSG:900913"); return function (n, i) { var s = OpenLayers.Projection.transform({ x: n, y: i }, e, t); return new OpenLayers.LonLat(s.x, s.y) } }(), inverseMercator: function () { var e = new OpenLayers.Projection("EPSG:4326"), t = new OpenLayers.Projection("EPSG:900913"); return function (n, i) { var s = OpenLayers.Projection.transform({ x: n, y: i }, t, e); return new OpenLayers.LonLat(s.x, s.y) } }() }, OpenLayers.Layer.EventPane = OpenLayers.Class(OpenLayers.Layer, { smoothDragPan: !0, isBaseLayer: !0, isFixed: !0, pane: null, mapObject: null, initialize: function (e, t) { OpenLayers.Layer.prototype.initialize.apply(this, arguments), null == this.pane && (this.pane = OpenLayers.Util.createDiv(this.div.id + "_EventPane")) }, destroy: function () { this.mapObject = null, this.pane = null, OpenLayers.Layer.prototype.destroy.apply(this, arguments) }, setMap: function (e) { OpenLayers.Layer.prototype.setMap.apply(this, arguments), this.pane.style.zIndex = parseInt(this.div.style.zIndex) + 1, this.pane.style.display = this.div.style.display, this.pane.style.width = "100%", this.pane.style.height = "100%", "msie" == OpenLayers.BROWSER_NAME && (this.pane.style.background = "url(" + OpenLayers.Util.getImageLocation("blank.gif") + ")"), this.isFixed ? this.map.viewPortDiv.appendChild(this.pane) : this.map.layerContainerDiv.appendChild(this.pane), this.loadMapObject(), null == this.mapObject && this.loadWarningMessage() }, removeMap: function (e) { this.pane && this.pane.parentNode && this.pane.parentNode.removeChild(this.pane), OpenLayers.Layer.prototype.removeMap.apply(this, arguments) }, loadWarningMessage: function () { this.div.style.backgroundColor = "darkblue"; var e = this.map.getSize(), t = Math.min(e.w, 300), n = Math.min(e.h, 200), i = new OpenLayers.Size(t, n), s = new OpenLayers.Pixel(e.w / 2, e.h / 2).add(-i.w / 2, -i.h / 2), r = OpenLayers.Util.createDiv(this.name + "_warning", s, i, null, null, null, "auto"); r.style.padding = "7px", r.style.backgroundColor = "yellow", r.innerHTML = this.getWarningHTML(), this.div.appendChild(r) }, getWarningHTML: function () { return "" }, display: function (e) { OpenLayers.Layer.prototype.display.apply(this, arguments), this.pane.style.display = this.div.style.display }, setZIndex: function (e) { OpenLayers.Layer.prototype.setZIndex.apply(this, arguments), this.pane.style.zIndex = parseInt(this.div.style.zIndex) + 1 }, moveByPx: function (e, t) { OpenLayers.Layer.prototype.moveByPx.apply(this, arguments), this.dragPanMapObject ? this.dragPanMapObject(e, -t) : this.moveTo(this.map.getCachedCenter()) }, moveTo: function (e, t, n) { if (OpenLayers.Layer.prototype.moveTo.apply(this, arguments), null != this.mapObject) { var i = this.map.getCenter(), s = this.map.getZoom(); if (null != i) { var r = this.getMapObjectCenter(), a = this.getOLLonLatFromMapObjectLonLat(r), o = this.getMapObjectZoom(), l = this.getOLZoomFromMapObjectZoom(o); if (!i.equals(a) || s != l) if (!t && a && this.dragPanMapObject && this.smoothDragPan) { var h = this.map.getViewPortPxFromLonLat(a), p = this.map.getViewPortPxFromLonLat(i); this.dragPanMapObject(p.x - h.x, h.y - p.y) } else { var u = this.getMapObjectLonLatFromOLLonLat(i), y = this.getMapObjectZoomFromOLZoom(s); this.setMapObjectCenter(u, y, n) } } } }, getLonLatFromViewPortPx: function (e) { var t = null; if (null != this.mapObject && null != this.getMapObjectCenter()) { var n = this.getMapObjectPixelFromOLPixel(e), i = this.getMapObjectLonLatFromMapObjectPixel(n); t = this.getOLLonLatFromMapObjectLonLat(i) } return t }, getViewPortPxFromLonLat: function (e) { var t = null; if (null != this.mapObject && null != this.getMapObjectCenter()) { var n = this.getMapObjectLonLatFromOLLonLat(e), i = this.getMapObjectPixelFromMapObjectLonLat(n); t = this.getOLPixelFromMapObjectPixel(i) } return t }, getOLLonLatFromMapObjectLonLat: function (e) { var t = null; if (null != e) { var n = this.getLongitudeFromMapObjectLonLat(e), i = this.getLatitudeFromMapObjectLonLat(e); t = new OpenLayers.LonLat(n, i) } return t }, getMapObjectLonLatFromOLLonLat: function (e) { var t = null; return null != e && (t = this.getMapObjectLonLatFromLonLat(e.lon, e.lat)), t }, getOLPixelFromMapObjectPixel: function (e) { var t = null; if (null != e) { var n = this.getXFromMapObjectPixel(e), i = this.getYFromMapObjectPixel(e); t = new OpenLayers.Pixel(n, i) } return t }, getMapObjectPixelFromOLPixel: function (e) { var t = null; return null != e && (t = this.getMapObjectPixelFromXY(e.x, e.y)), t }, CLASS_NAME: "OpenLayers.Layer.EventPane" }), OpenLayers.Layer.FixedZoomLevels = OpenLayers.Class({ initialize: function () { }, initResolutions: function () { for (var e, t = ["minZoomLevel", "maxZoomLevel", "numZoomLevels"], n = 0, i = t.length; n < i; n++) { var s = t[n]; this[s] = null != this.options[s] ? this.options[s] : this.map[s] } (null == this.minZoomLevel || this.minZoomLevel < this.MIN_ZOOM_LEVEL) && (this.minZoomLevel = this.MIN_ZOOM_LEVEL); var r = this.MAX_ZOOM_LEVEL - this.minZoomLevel + 1; if (e = null == this.options.numZoomLevels && null != this.options.maxZoomLevel || null == this.numZoomLevels && null != this.maxZoomLevel ? this.maxZoomLevel - this.minZoomLevel + 1 : this.numZoomLevels, this.numZoomLevels = null != e ? Math.min(e, r) : r, this.maxZoomLevel = this.minZoomLevel + this.numZoomLevels - 1, null != this.RESOLUTIONS) { var a = 0; this.resolutions = []; for (n = this.minZoomLevel; n <= this.maxZoomLevel; n++)this.resolutions[a++] = this.RESOLUTIONS[n]; this.maxResolution = this.resolutions[0], this.minResolution = this.resolutions[this.resolutions.length - 1] } }, getResolution: function () { if (null != this.resolutions) return OpenLayers.Layer.prototype.getResolution.apply(this, arguments); var e = null, t = this.map.getSize(), n = this.getExtent(); return null != t && null != n && (e = Math.max(n.getWidth() / t.w, n.getHeight() / t.h)), e }, getExtent: function () { var e = this.map.getSize(), t = this.getLonLatFromViewPortPx({ x: 0, y: 0 }), n = this.getLonLatFromViewPortPx({ x: e.w, y: e.h }); return null != t && null != n ? new OpenLayers.Bounds(t.lon, n.lat, n.lon, t.lat) : null }, getZoomForResolution: function (e) { if (null != this.resolutions) return OpenLayers.Layer.prototype.getZoomForResolution.apply(this, arguments); var t = OpenLayers.Layer.prototype.getExtent.apply(this, []); return this.getZoomForExtent(t) }, getOLZoomFromMapObjectZoom: function (e) { var t = null; return null != e && (t = e - this.minZoomLevel, this.map.baseLayer !== this && (t = this.map.baseLayer.getZoomForResolution(this.getResolutionForZoom(t)))), t }, getMapObjectZoomFromOLZoom: function (e) { var t = null; return null != e && (t = e + this.minZoomLevel, this.map.baseLayer !== this && (t = this.getZoomForResolution(this.map.baseLayer.getResolutionForZoom(t)))), t }, CLASS_NAME: "OpenLayers.Layer.FixedZoomLevels" }), OpenLayers.Layer.Google = OpenLayers.Class(OpenLayers.Layer.EventPane, OpenLayers.Layer.FixedZoomLevels, { MIN_ZOOM_LEVEL: 0, MAX_ZOOM_LEVEL: 21, RESOLUTIONS: [1.40625, .703125, .3515625, .17578125, .087890625, .0439453125, .02197265625, .010986328125, .0054931640625, .00274658203125, .001373291015625, .0006866455078125, .00034332275390625, .000171661376953125, 858306884765625e-19, 4291534423828125e-20, 2145767211914062e-20, 1072883605957031e-20, 536441802978515e-20, 268220901489257e-20, 1341104507446289e-21, 6.705522537231445e-7], type: null, wrapDateLine: !0, sphericalMercator: !1, version: null, initialize: function (e, t) { (t = t || {}).version || (t.version = "function" == typeof GMap2 ? "2" : "3"); var n = OpenLayers.Layer.Google["v" + t.version.replace(/\./g, "_")]; if (!n) throw "Unsupported Google Maps API version: " + t.version; OpenLayers.Util.applyDefaults(t, n), OpenLayers.Util.applyDefaults(t, n.DEFAULTS), t.maxExtent && (t.maxExtent = t.maxExtent.clone()), OpenLayers.Layer.EventPane.prototype.initialize.apply(this, [e, t]), OpenLayers.Layer.FixedZoomLevels.prototype.initialize.apply(this, [e, t]), this.sphericalMercator && (OpenLayers.Util.extend(this, OpenLayers.Layer.SphericalMercator), this.initMercatorParameters()) }, clone: function () { return new OpenLayers.Layer.Google(this.name, this.getOptions()) }, setVisibility: function (e) { var t = null == this.opacity ? 1 : this.opacity; OpenLayers.Layer.EventPane.prototype.setVisibility.apply(this, arguments), this.setOpacity(t) }, display: function (e) { this._dragging || this.setGMapVisibility(e), OpenLayers.Layer.EventPane.prototype.display.apply(this, arguments) }, moveTo: function (e, t, n) { this._dragging = n, OpenLayers.Layer.EventPane.prototype.moveTo.apply(this, arguments), delete this._dragging }, setOpacity: function (e) { if (e !== this.opacity && (null != this.map && this.map.events.triggerEvent("changelayer", { layer: this, property: "opacity" }), this.opacity = e), this.getVisibility()) { var t = this.getMapContainer(); OpenLayers.Util.modifyDOMElement(t, null, null, null, null, null, null, e) } }, destroy: function () { if (this.map) { this.setGMapVisibility(!1); var e = OpenLayers.Layer.Google.cache[this.map.id]; e && e.count <= 1 && this.removeGMapElements() } OpenLayers.Layer.EventPane.prototype.destroy.apply(this, arguments) }, removeGMapElements: function () { var e = OpenLayers.Layer.Google.cache[this.map.id]; if (e) { var t = this.mapObject && this.getMapContainer(); t && t.parentNode && t.parentNode.removeChild(t); var n = e.termsOfUse; n && n.parentNode && n.parentNode.removeChild(n); var i = e.poweredBy; i && i.parentNode && i.parentNode.removeChild(i), this.mapObject && window.google && google.maps && google.maps.event && google.maps.event.clearListeners && google.maps.event.clearListeners(this.mapObject, "tilesloaded") } }, removeMap: function (e) { this.visibility && this.mapObject && this.setGMapVisibility(!1); var t = OpenLayers.Layer.Google.cache[e.id]; t && (t.count <= 1 ? (this.removeGMapElements(), delete OpenLayers.Layer.Google.cache[e.id]) : --t.count), delete this.termsOfUse, delete this.poweredBy, delete this.mapObject, delete this.dragObject, OpenLayers.Layer.EventPane.prototype.removeMap.apply(this, arguments) }, getOLBoundsFromMapObjectBounds: function (e) { var t = null; if (null != e) { var n = e.getSouthWest(), i = e.getNorthEast(); this.sphericalMercator ? (n = this.forwardMercator(n.lng(), n.lat()), i = this.forwardMercator(i.lng(), i.lat())) : (n = new OpenLayers.LonLat(n.lng(), n.lat()), i = new OpenLayers.LonLat(i.lng(), i.lat())), t = new OpenLayers.Bounds(n.lon, n.lat, i.lon, i.lat) } return t }, getWarningHTML: function () { return OpenLayers.i18n("googleWarning") }, getMapObjectCenter: function () { return this.mapObject.getCenter() }, getMapObjectZoom: function () { return this.mapObject.getZoom() }, getLongitudeFromMapObjectLonLat: function (e) { return this.sphericalMercator ? this.forwardMercator(e.lng(), e.lat()).lon : e.lng() }, getLatitudeFromMapObjectLonLat: function (e) { return this.sphericalMercator ? this.forwardMercator(e.lng(), e.lat()).lat : e.lat() }, getXFromMapObjectPixel: function (e) { return e.x }, getYFromMapObjectPixel: function (e) { return e.y }, CLASS_NAME: "OpenLayers.Layer.Google" }), OpenLayers.Layer.Google.cache = {}, OpenLayers.Layer.Google.v2 = { termsOfUse: null, poweredBy: null, dragObject: null, loadMapObject: function () { var e, t, n; this.type || (this.type = G_NORMAL_MAP); var i = OpenLayers.Layer.Google.cache[this.map.id]; if (i) e = i.mapObject, t = i.termsOfUse, n = i.poweredBy, ++i.count; else { var s = this.map.viewPortDiv, r = document.createElement("div"); r.id = this.map.id + "_GMap2Container", r.style.position = "absolute", r.style.width = "100%", r.style.height = "100%", s.appendChild(r); try { e = new GMap2(r), t = r.lastChild, s.appendChild(t), t.style.zIndex = "1100", t.style.right = "", t.style.bottom = "", t.className = "olLayerGoogleCopyright", n = r.lastChild, s.appendChild(n), n.style.zIndex = "1100", n.style.right = "", n.style.bottom = "", n.className = "olLayerGooglePoweredBy gmnoprint" } catch (e) { throw e } OpenLayers.Layer.Google.cache[this.map.id] = { mapObject: e, termsOfUse: t, poweredBy: n, count: 1 } } this.mapObject = e, this.termsOfUse = t, this.poweredBy = n, -1 === OpenLayers.Util.indexOf(this.mapObject.getMapTypes(), this.type) && this.mapObject.addMapType(this.type), "function" == typeof e.getDragObject ? this.dragObject = e.getDragObject() : this.dragPanMapObject = null, !1 === this.isBaseLayer && this.setGMapVisibility("none" !== this.div.style.display) }, onMapResize: function () { if (this.visibility && this.mapObject.isLoaded()) this.mapObject.checkResize(); else { if (!this._resized) var e = this, t = GEvent.addListener(this.mapObject, "load", function () { GEvent.removeListener(t), delete e._resized, e.mapObject.checkResize(), e.moveTo(e.map.getCenter(), e.map.getZoom()) }); this._resized = !0 } }, setGMapVisibility: function (e) { var t = OpenLayers.Layer.Google.cache[this.map.id]; if (t) { var n = this.mapObject.getContainer(); !0 === e ? (this.mapObject.setMapType(this.type), n.style.display = "", this.termsOfUse.style.left = "", this.termsOfUse.style.display = "", this.poweredBy.style.display = "", t.displayed = this.id) : (t.displayed === this.id && delete t.displayed, t.displayed || (n.style.display = "none", this.termsOfUse.style.display = "none", this.termsOfUse.style.left = "-9999px", this.poweredBy.style.display = "none")) } }, getMapContainer: function () { return this.mapObject.getContainer() }, getMapObjectBoundsFromOLBounds: function (e) { var t = null; if (null != e) { var n = this.sphericalMercator ? this.inverseMercator(e.bottom, e.left) : new OpenLayers.LonLat(e.bottom, e.left), i = this.sphericalMercator ? this.inverseMercator(e.top, e.right) : new OpenLayers.LonLat(e.top, e.right); t = new GLatLngBounds(new GLatLng(n.lat, n.lon), new GLatLng(i.lat, i.lon)) } return t }, setMapObjectCenter: function (e, t) { this.mapObject.setCenter(e, t) }, dragPanMapObject: function (e, t) { this.dragObject.moveBy(new GSize(-e, t)) }, getMapObjectLonLatFromMapObjectPixel: function (e) { return this.mapObject.fromContainerPixelToLatLng(e) }, getMapObjectPixelFromMapObjectLonLat: function (e) { return this.mapObject.fromLatLngToContainerPixel(e) }, getMapObjectZoomFromMapObjectBounds: function (e) { return this.mapObject.getBoundsZoomLevel(e) }, getMapObjectLonLatFromLonLat: function (e, t) { var n; if (this.sphericalMercator) { var i = this.inverseMercator(e, t); n = new GLatLng(i.lat, i.lon) } else n = new GLatLng(t, e); return n }, getMapObjectPixelFromXY: function (e, t) { return new GPoint(e, t) } }, OpenLayers.Geometry = OpenLayers.Class({ id: null, parent: null, bounds: null, initialize: function () { this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_") }, destroy: function () { this.id = null, this.bounds = null }, clone: function () { return new OpenLayers.Geometry }, setBounds: function (e) { e && (this.bounds = e.clone()) }, clearBounds: function () { this.bounds = null, this.parent && this.parent.clearBounds() }, extendBounds: function (e) { this.getBounds() ? this.bounds.extend(e) : this.setBounds(e) }, getBounds: function () { return null == this.bounds && this.calculateBounds(), this.bounds }, calculateBounds: function () { }, distanceTo: function (e, t) { }, getVertices: function (e) { }, atPoint: function (e, t, n) { var i = !1; if (null != this.getBounds() && null != e) { var s = null != t ? t : 0, r = null != n ? n : 0; i = new OpenLayers.Bounds(this.bounds.left - s, this.bounds.bottom - r, this.bounds.right + s, this.bounds.top + r).containsLonLat(e) } return i }, getLength: function () { return 0 }, getArea: function () { return 0 }, getCentroid: function () { return null }, toString: function () { return OpenLayers.Format && OpenLayers.Format.WKT ? OpenLayers.Format.WKT.prototype.write(new OpenLayers.Feature.Vector(this)) : Object.prototype.toString.call(this) }, CLASS_NAME: "OpenLayers.Geometry" }), OpenLayers.Geometry.fromWKT = function (e) { var t; if (OpenLayers.Format && OpenLayers.Format.WKT) { var n = OpenLayers.Geometry.fromWKT.format; n || (n = new OpenLayers.Format.WKT, OpenLayers.Geometry.fromWKT.format = n); var i = n.read(e); if (i instanceof OpenLayers.Feature.Vector) t = i.geometry; else if (OpenLayers.Util.isArray(i)) { for (var s = i.length, r = new Array(s), a = 0; a < s; ++a)r[a] = i[a].geometry; t = new OpenLayers.Geometry.Collection(r) } } return t }, OpenLayers.Geometry.segmentsIntersect = function (e, t, n) { var i = n && n.point, s = n && n.tolerance, r = !1, a = e.x1 - t.x1, o = e.y1 - t.y1, l = e.x2 - e.x1, h = e.y2 - e.y1, p = t.y2 - t.y1, u = t.x2 - t.x1, y = p * l - u * h, c = u * o - p * a, d = l * o - h * a; if (0 == y) 0 == c && 0 == d && (r = !0); else { var f = c / y, m = d / y; if (f >= 0 && f <= 1 && m >= 0 && m <= 1) if (i) { var g = e.x1 + f * l, L = e.y1 + f * h; r = new OpenLayers.Geometry.Point(g, L) } else r = !0 } if (s) if (r) { if (i) { var v, O = [e, t]; e: for (var x = 0; x < 2; ++x) { v = O[x]; for (var E = 1; E < 3; ++E)if (g = v["x" + E], L = v["y" + E], Math.sqrt(Math.pow(g - r.x, 2) + Math.pow(L - r.y, 2)) < s) { r.x = g, r.y = L; break e } } } } else { var b, S, w; O = [e, t]; e: for (x = 0; x < 2; ++x) { b = O[x], S = O[(x + 1) % 2]; for (E = 1; E < 3; ++E)if (w = { x: b["x" + E], y: b["y" + E] }, OpenLayers.Geometry.distanceToSegment(w, S).distance < s) { r = !i || new OpenLayers.Geometry.Point(w.x, w.y); break e } } } return r }, OpenLayers.Geometry.distanceToSegment = function (e, t) { var n = OpenLayers.Geometry.distanceSquaredToSegment(e, t); return n.distance = Math.sqrt(n.distance), n }, OpenLayers.Geometry.distanceSquaredToSegment = function (e, t) { var n, i, s = e.x, r = e.y, a = t.x1, o = t.y1, l = t.x2, h = t.y2, p = l - a, u = h - o, y = (p * (s - a) + u * (r - o)) / (Math.pow(p, 2) + Math.pow(u, 2)); return y <= 0 ? (n = a, i = o) : y >= 1 ? (n = l, i = h) : (n = a + y * p, i = o + y * u), { distance: Math.pow(n - s, 2) + Math.pow(i - r, 2), x: n, y: i, along: y } }, OpenLayers.Geometry.Collection = OpenLayers.Class(OpenLayers.Geometry, { components: null, componentTypes: null, initialize: function (e) { OpenLayers.Geometry.prototype.initialize.apply(this, arguments), this.components = [], null != e && this.addComponents(e) }, destroy: function () { this.components.length = 0, this.components = null, OpenLayers.Geometry.prototype.destroy.apply(this, arguments) }, clone: function () { for (var geometry = eval("new " + this.CLASS_NAME + "()"), i = 0, len = this.components.length; i < len; i++)geometry.addComponent(this.components[i].clone()); return OpenLayers.Util.applyDefaults(geometry, this), geometry }, getComponentsString: function () { for (var e = [], t = 0, n = this.components.length; t < n; t++)e.push(this.components[t].toShortString()); return e.join(",") }, calculateBounds: function () { this.bounds = null; var e = new OpenLayers.Bounds, t = this.components; if (t) for (var n = 0, i = t.length; n < i; n++)e.extend(t[n].getBounds()); null != e.left && null != e.bottom && null != e.right && null != e.top && this.setBounds(e) }, addComponents: function (e) { OpenLayers.Util.isArray(e) || (e = [e]); for (var t = 0, n = e.length; t < n; t++)this.addComponent(e[t]) }, addComponent: function (e, t) { var n = !1; if (e && (null == this.componentTypes || OpenLayers.Util.indexOf(this.componentTypes, e.CLASS_NAME) > -1)) { if (null != t && t < this.components.length) { var i = this.components.slice(0, t), s = this.components.slice(t, this.components.length); i.push(e), this.components = i.concat(s) } else this.components.push(e); e.parent = this, this.clearBounds(), n = !0 } return n }, removeComponents: function (e) { var t = !1; OpenLayers.Util.isArray(e) || (e = [e]); for (var n = e.length - 1; n >= 0; --n)t = this.removeComponent(e[n]) || t; return t }, removeComponent: function (e) { return OpenLayers.Util.removeItem(this.components, e), this.clearBounds(), !0 }, getLength: function () { for (var e = 0, t = 0, n = this.components.length; t < n; t++)e += this.components[t].getLength(); return e }, getArea: function () { for (var e = 0, t = 0, n = this.components.length; t < n; t++)e += this.components[t].getArea(); return e }, getGeodesicArea: function (e) { for (var t = 0, n = 0, i = this.components.length; n < i; n++)t += this.components[n].getGeodesicArea(e); return t }, getCentroid: function (e) { if (!e) return this.components.length && this.components[0].getCentroid(); var t = this.components.length; if (!t) return !1; for (var n, i = [], s = [], r = 0, a = Number.MAX_VALUE, o = 0; o < t; ++o) { var l = (n = this.components[o]).getArea(), h = n.getCentroid(!0); isNaN(l) || isNaN(h.x) || isNaN(h.y) || (i.push(l), r += l, a = l < a && l > 0 ? l : a, s.push(h)) } if (t = i.length, 0 === r) { for (o = 0; o < t; ++o)i[o] = 1; r = i.length } else { for (o = 0; o < t; ++o)i[o] /= a; r /= a } var p = 0, u = 0; for (o = 0; o < t; ++o)h = s[o], l = i[o], p += h.x * l, u += h.y * l; return new OpenLayers.Geometry.Point(p / r, u / r) }, getGeodesicLength: function (e) { for (var t = 0, n = 0, i = this.components.length; n < i; n++)t += this.components[n].getGeodesicLength(e); return t }, move: function (e, t) { for (var n = 0, i = this.components.length; n < i; n++)this.components[n].move(e, t) }, rotate: function (e, t) { for (var n = 0, i = this.components.length; n < i; ++n)this.components[n].rotate(e, t) }, resize: function (e, t, n) { for (var i = 0; i < this.components.length; ++i)this.components[i].resize(e, t, n); return this }, distanceTo: function (e, t) { for (var n, i, s, r = !(t && !1 === t.edge) && t && t.details, a = Number.POSITIVE_INFINITY, o = 0, l = this.components.length; o < l && (n = this.components[o].distanceTo(e, t), !((s = r ? n.distance : n) < a && (i = n, 0 == (a = s)))); ++o); return i }, equals: function (e) { var t = !0; if (e && e.CLASS_NAME && this.CLASS_NAME == e.CLASS_NAME) if (OpenLayers.Util.isArray(e.components) && e.components.length == this.components.length) { for (var n = 0, i = this.components.length; n < i; ++n)if (!this.components[n].equals(e.components[n])) { t = !1; break } } else t = !1; else t = !1; return t }, transform: function (e, t) { if (e && t) { for (var n = 0, i = this.components.length; n < i; n++) { this.components[n].transform(e, t) } this.bounds = null } return this }, intersects: function (e) { for (var t = !1, n = 0, i = this.components.length; n < i && !(t = e.intersects(this.components[n])); ++n); return t }, getVertices: function (e) { for (var t = [], n = 0, i = this.components.length; n < i; ++n)Array.prototype.push.apply(t, this.components[n].getVertices(e)); return t }, CLASS_NAME: "OpenLayers.Geometry.Collection" }), OpenLayers.Geometry.Point = OpenLayers.Class(OpenLayers.Geometry, { x: null, y: null, initialize: function (e, t) { OpenLayers.Geometry.prototype.initialize.apply(this, arguments), this.x = parseFloat(e), this.y = parseFloat(t) }, clone: function (e) { return null == e && (e = new OpenLayers.Geometry.Point(this.x, this.y)), OpenLayers.Util.applyDefaults(e, this), e }, calculateBounds: function () { this.bounds = new OpenLayers.Bounds(this.x, this.y, this.x, this.y) }, distanceTo: function (e, t) { var n, i, s, r, a, o, l = !(t && !1 === t.edge) && t && t.details; return e instanceof OpenLayers.Geometry.Point ? (i = this.x, s = this.y, r = e.x, a = e.y, n = Math.sqrt(Math.pow(i - r, 2) + Math.pow(s - a, 2)), o = l ? { x0: i, y0: s, x1: r, y1: a, distance: n } : n) : (o = e.distanceTo(this, t), l && (o = { x0: o.x1, y0: o.y1, x1: o.x0, y1: o.y0, distance: o.distance })), o }, equals: function (e) { var t = !1; return null != e && (t = this.x == e.x && this.y == e.y || isNaN(this.x) && isNaN(this.y) && isNaN(e.x) && isNaN(e.y)), t }, toShortString: function () { return this.x + ", " + this.y }, move: function (e, t) { this.x = this.x + e, this.y = this.y + t, this.clearBounds() }, rotate: function (e, t) { e *= Math.PI / 180; var n = this.distanceTo(t), i = e + Math.atan2(this.y - t.y, this.x - t.x); this.x = t.x + n * Math.cos(i), this.y = t.y + n * Math.sin(i), this.clearBounds() }, getCentroid: function () { return new OpenLayers.Geometry.Point(this.x, this.y) }, resize: function (e, t, n) { return n = null == n ? 1 : n, this.x = t.x + e * n * (this.x - t.x), this.y = t.y + e * (this.y - t.y), this.clearBounds(), this }, intersects: function (e) { return "OpenLayers.Geometry.Point" == e.CLASS_NAME ? this.equals(e) : e.intersects(this) }, transform: function (e, t) { return e && t && (OpenLayers.Projection.transform(this, e, t), this.bounds = null), this }, getVertices: function (e) { return [this] }, CLASS_NAME: "OpenLayers.Geometry.Point" }), OpenLayers.Geometry.MultiPoint = OpenLayers.Class(OpenLayers.Geometry.Collection, { componentTypes: ["OpenLayers.Geometry.Point"], addPoint: function (e, t) { this.addComponent(e, t) }, removePoint: function (e) { this.removeComponent(e) }, CLASS_NAME: "OpenLayers.Geometry.MultiPoint" }), OpenLayers.Geometry.Curve = OpenLayers.Class(OpenLayers.Geometry.MultiPoint, { componentTypes: ["OpenLayers.Geometry.Point"], getLength: function () { var e = 0; if (this.components && this.components.length > 1) for (var t = 1, n = this.components.length; t < n; t++)e += this.components[t - 1].distanceTo(this.components[t]); return e }, getGeodesicLength: function (e) { var t = this; if (e) { var n = new OpenLayers.Projection("EPSG:4326"); n.equals(e) || (t = this.clone().transform(e, n)) } var i = 0; if (t.components && t.components.length > 1) for (var s, r, a = 1, o = t.components.length; a < o; a++)s = t.components[a - 1], r = t.components[a], i += OpenLayers.Util.distVincenty({ lon: s.x, lat: s.y }, { lon: r.x, lat: r.y }); return 1e3 * i }, CLASS_NAME: "OpenLayers.Geometry.Curve" }), OpenLayers.Geometry.LineString = OpenLayers.Class(OpenLayers.Geometry.Curve, { removeComponent: function (e) { var t = this.components && this.components.length > 2; return t && OpenLayers.Geometry.Collection.prototype.removeComponent.apply(this, arguments), t }, intersects: function (e) { var t = !1, n = e.CLASS_NAME; if ("OpenLayers.Geometry.LineString" == n || "OpenLayers.Geometry.LinearRing" == n || "OpenLayers.Geometry.Point" == n) { var i, s, r, a, o, l, h, p, u, y = this.getSortedSegments(); i = "OpenLayers.Geometry.Point" == n ? [{ x1: e.x, y1: e.y, x2: e.x, y2: e.y }] : e.getSortedSegments(); e: for (var c = 0, d = y.length; c < d; ++c) { r = (s = y[c]).x1, a = s.x2, o = s.y1, l = s.y2; for (var f = 0, m = i.length; f < m && !((h = i[f]).x1 > a); ++f)if (!(h.x2 < r) && (p = h.y1, u = h.y2, !(Math.min(p, u) > Math.max(o, l)) && !(Math.max(p, u) < Math.min(o, l)) && OpenLayers.Geometry.segmentsIntersect(s, h))) { t = !0; break e } } } else t = e.intersects(this); return t }, getSortedSegments: function () { for (var e, t, n = this.components.length - 1, i = new Array(n), s = 0; s < n; ++s)e = this.components[s], t = this.components[s + 1], e.x < t.x ? i[s] = { x1: e.x, y1: e.y, x2: t.x, y2: t.y } : i[s] = { x1: t.x, y1: t.y, x2: e.x, y2: e.y }; return i.sort(function (e, t) { return e.x1 - t.x1 }) }, splitWithSegment: function (e, t) { for (var n, i, s, r, a = !(t && !1 === t.edge), o = t && t.tolerance, l = [], h = this.getVertices(), p = [], u = [], y = !1, c = { point: !0, tolerance: o }, d = null, f = 0, m = h.length - 2; f <= m; ++f)if (n = h[f], p.push(n.clone()), i = h[f + 1], r = { x1: n.x, y1: n.y, x2: i.x, y2: i.y }, (s = OpenLayers.Geometry.segmentsIntersect(e, r, c)) instanceof OpenLayers.Geometry.Point && (!!(s.x === e.x1 && s.y === e.y1 || s.x === e.x2 && s.y === e.y2 || s.equals(n) || s.equals(i)) || a)) { if (s.equals(u[u.length - 1]) || u.push(s.clone()), 0 === f && s.equals(n)) continue; if (s.equals(i)) continue; y = !0, s.equals(n) || p.push(s), l.push(new OpenLayers.Geometry.LineString(p)), p = [s.clone()] } if (y && (p.push(i.clone()), l.push(new OpenLayers.Geometry.LineString(p))), u.length > 0) { var g = e.x1 < e.x2 ? 1 : -1, L = e.y1 < e.y2 ? 1 : -1; d = { lines: l, points: u.sort(function (e, t) { return g * e.x - g * t.x || L * e.y - L * t.y }) } } return d }, split: function (e, t) { var n, i, s, r, a = null, o = t && t.mutual; if (e instanceof OpenLayers.Geometry.LineString) { var l, h, p, u, y, c, d = this.getVertices(), f = []; s = []; for (var m = 0, g = d.length - 2; m <= g; ++m) { l = d[m], h = d[m + 1], p = { x1: l.x, y1: l.y, x2: h.x, y2: h.y }, r = r || [e], o && f.push(l.clone()); for (var L = 0; L < r.length; ++L)if ((u = r[L].splitWithSegment(p, t)) && ((y = u.lines).length > 0 && (y.unshift(L, 1), Array.prototype.splice.apply(r, y), L += y.length - 2), o)) for (var v = 0, O = u.points.length; v < O; ++v)(c = u.points[v]).equals(l) || (f.push(c), s.push(new OpenLayers.Geometry.LineString(f)), f = c.equals(h) ? [] : [c.clone()]) } o && s.length > 0 && f.length > 0 && (f.push(h.clone()), s.push(new OpenLayers.Geometry.LineString(f))) } else a = e.splitWith(this, t); return r && r.length > 1 ? i = !0 : r = [], s && s.length > 1 ? n = !0 : s = [], (i || n) && (a = o ? [s, r] : r), a }, splitWith: function (e, t) { return e.split(this, t) }, getVertices: function (e) { return !0 === e ? [this.components[0], this.components[this.components.length - 1]] : !1 === e ? this.components.slice(1, this.components.length - 1) : this.components.slice() }, distanceTo: function (e, t) { var n, i = !(t && !1 === t.edge) && t && t.details, s = {}, r = Number.POSITIVE_INFINITY; if (e instanceof OpenLayers.Geometry.Point) { for (var a, o = this.getSortedSegments(), l = e.x, h = e.y, p = 0, u = o.length; p < u; ++p)if (a = o[p], (n = OpenLayers.Geometry.distanceToSegment(e, a)).distance < r) { if (s = n, 0 === (r = n.distance)) break } else if (a.x2 > l && (h > a.y1 && h < a.y2 || h < a.y1 && h > a.y2)) break; s = i ? { distance: s.distance, x0: s.x, y0: s.y, x1: l, y1: h } : s.distance } else if (e instanceof OpenLayers.Geometry.LineString) { var y, c, d, f, m, g = this.getSortedSegments(), L = e.getSortedSegments(), v = L.length, O = { point: !0 }; e: for (p = 0, u = g.length; p < u; ++p) { f = (y = g[p]).x1, m = y.y1; for (var x = 0; x < v; ++x) { if (c = L[x], d = OpenLayers.Geometry.segmentsIntersect(y, c, O)) { r = 0, s = { distance: 0, x0: d.x, y0: d.y, x1: d.x, y1: d.y }; break e } (n = OpenLayers.Geometry.distanceToSegment({ x: f, y: m }, c)).distance < r && (s = { distance: r = n.distance, x0: f, y0: m, x1: n.x, y1: n.y }) } } if (i || (s = s.distance), 0 !== r && y) { n = e.distanceTo(new OpenLayers.Geometry.Point(y.x2, y.y2), t); var E = i ? n.distance : n; E < r && (s = i ? { distance: r, x0: n.x1, y0: n.y1, x1: n.x0, y1: n.y0 } : E) } } else s = e.distanceTo(this, t), i && (s = { distance: s.distance, x0: s.x1, y0: s.y1, x1: s.x0, y1: s.y0 }); return s }, simplify: function (e) { if (this && null !== this) { var t = this.getVertices(); if (t.length < 3) return this; var n = function (e, t, s, a) { for (var o, l = 0, h = 0, p = t; p < s; p++)(o = i(e[t], e[s], e[p])) > l && (l = o, h = p); l > a && h != t && (r.push(h), n(e, t, h, a), n(e, h, s, a)) }, i = function (e, t, n) { return Math.abs(.5 * (e.x * t.y + t.x * n.y + n.x * e.y - t.x * e.y - n.x * t.y - e.x * n.y)) / Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) * 2 }, s = t.length - 1, r = []; for (r.push(0), r.push(s); t[0].equals(t[s]);)s-- , r.push(s); n(t, 0, s, e); var a = []; r.sort(function (e, t) { return e - t }); for (var o = 0; o < r.length; o++)a.push(t[r[o]]); return new OpenLayers.Geometry.LineString(a) } return this }, CLASS_NAME: "OpenLayers.Geometry.LineString" }), OpenLayers.Geometry.LinearRing = OpenLayers.Class(OpenLayers.Geometry.LineString, { componentTypes: ["OpenLayers.Geometry.Point"], addComponent: function (e, t) { var n = !1, i = this.components.pop(); null == t && e.equals(i) || (n = OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, arguments)); var s = this.components[0]; return OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, [s]), n }, removeComponent: function (e) { var t = this.components && this.components.length > 3; if (t) { this.components.pop(), OpenLayers.Geometry.Collection.prototype.removeComponent.apply(this, arguments); var n = this.components[0]; OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, [n]) } return t }, move: function (e, t) { for (var n = 0, i = this.components.length; n < i - 1; n++)this.components[n].move(e, t) }, rotate: function (e, t) { for (var n = 0, i = this.components.length; n < i - 1; ++n)this.components[n].rotate(e, t) }, resize: function (e, t, n) { for (var i = 0, s = this.components.length; i < s - 1; ++i)this.components[i].resize(e, t, n); return this }, transform: function (e, t) { if (e && t) { for (var n = 0, i = this.components.length; n < i - 1; n++) { this.components[n].transform(e, t) } this.bounds = null } return this }, getCentroid: function () { if (this.components) { var e = this.components.length; if (e > 0 && e <= 2) return this.components[0].clone(); if (e > 2) { var t = 0, n = 0, i = this.components[0].x, s = this.components[0].y, r = -1 * this.getArea(); if (0 != r) { for (var a = 0; a < e - 1; a++) { var o = this.components[a], l = this.components[a + 1]; t += (o.x + l.x - 2 * i) * ((o.x - i) * (l.y - s) - (l.x - i) * (o.y - s)), n += (o.y + l.y - 2 * s) * ((o.x - i) * (l.y - s) - (l.x - i) * (o.y - s)) } var h = i + t / (6 * r), p = s + n / (6 * r) } else { for (a = 0; a < e - 1; a++)t += this.components[a].x, n += this.components[a].y; h = t / (e - 1), p = n / (e - 1) } return new OpenLayers.Geometry.Point(h, p) } return null } }, getArea: function () { var e = 0; if (this.components && this.components.length > 2) { for (var t = 0, n = 0, i = this.components.length; n < i - 1; n++) { var s = this.components[n], r = this.components[n + 1]; t += (s.x + r.x) * (r.y - s.y) } e = -t / 2 } return e }, getGeodesicArea: function (e) { var t = this; if (e) { var n = new OpenLayers.Projection("EPSG:4326"); n.equals(e) || (t = this.clone().transform(e, n)) } var i = 0, s = t.components && t.components.length; if (s > 2) { for (var r, a, o = 0; o < s - 1; o++)r = t.components[o], a = t.components[o + 1], i += OpenLayers.Util.rad(a.x - r.x) * (2 + Math.sin(OpenLayers.Util.rad(r.y)) + Math.sin(OpenLayers.Util.rad(a.y))); i = 6378137 * i * 6378137 / 2 } return i }, containsPoint: function (e) { var t = OpenLayers.Number.limitSigDigs, n = t(e.x, 14), i = t(e.y, 14); function s(e, t, n, i, s) { return (i - t) / (s - n) * (e - s) + i } for (var r, a, o, l, h, p, u, y = this.components.length - 1, c = 0, d = 0; d < y; ++d)if (o = t((r = this.components[d]).x, 14), l = t(r.y, 14), h = t((a = this.components[d + 1]).x, 14), l != (p = t(a.y, 14))) { if ((u = t(s(i, o, l, h, p), 14)) == n && (l < p && i >= l && i <= p || l > p && i <= l && i >= p)) { c = -1; break } u <= n || o != h && (u < Math.min(o, h) || u > Math.max(o, h)) || (l < p && i >= l && i < p || l > p && i < l && i >= p) && ++c } else if (i == l && (o <= h && n >= o && n <= h || o >= h && n <= o && n >= h)) { c = -1; break } return -1 == c ? 1 : !!(1 & c) }, intersects: function (e) { var t = !1; if ("OpenLayers.Geometry.Point" == e.CLASS_NAME) t = this.containsPoint(e); else if ("OpenLayers.Geometry.LineString" == e.CLASS_NAME) t = e.intersects(this); else if ("OpenLayers.Geometry.LinearRing" == e.CLASS_NAME) t = OpenLayers.Geometry.LineString.prototype.intersects.apply(this, [e]); else for (var n = 0, i = e.components.length; n < i && !(t = e.components[n].intersects(this)); ++n); return t }, getVertices: function (e) { return !0 === e ? [] : this.components.slice(0, this.components.length - 1) }, CLASS_NAME: "OpenLayers.Geometry.LinearRing" }), OpenLayers.Layer.HTTPRequest = OpenLayers.Class(OpenLayers.Layer, { URL_HASH_FACTOR: (Math.sqrt(5) - 1) / 2, url: null, params: null, reproject: !1, initialize: function (e, t, n, i) { OpenLayers.Layer.prototype.initialize.apply(this, [e, i]), this.url = t, this.params || (this.params = OpenLayers.Util.extend({}, n)) }, destroy: function () { this.url = null, this.params = null, OpenLayers.Layer.prototype.destroy.apply(this, arguments) }, clone: function (e) { return null == e && (e = new OpenLayers.Layer.HTTPRequest(this.name, this.url, this.params, this.getOptions())), e = OpenLayers.Layer.prototype.clone.apply(this, [e]) }, setUrl: function (e) { this.url = e }, mergeNewParams: function (e) { this.params = OpenLayers.Util.extend(this.params, e); var t = this.redraw(); return null != this.map && this.map.events.triggerEvent("changelayer", { layer: this, property: "params" }), t }, redraw: function (e) { return e ? this.mergeNewParams({ _olSalt: Math.random() }) : OpenLayers.Layer.prototype.redraw.apply(this, []) }, selectUrl: function (e, t) { for (var n = 1, i = 0, s = e.length; i < s; i++)n *= e.charCodeAt(i) * this.URL_HASH_FACTOR, n -= Math.floor(n); return t[Math.floor(n * t.length)] }, getFullRequestString: function (e, t) { var n = t || this.url, i = OpenLayers.Util.extend({}, this.params); i = OpenLayers.Util.extend(i, e); var s = OpenLayers.Util.getParameterString(i); OpenLayers.Util.isArray(n) && (n = this.selectUrl(s, n)); var r = OpenLayers.Util.upperCaseObject(OpenLayers.Util.getParameters(n)); for (var a in i) a.toUpperCase() in r && delete i[a]; return s = OpenLayers.Util.getParameterString(i), OpenLayers.Util.urlAppend(n, s) }, CLASS_NAME: "OpenLayers.Layer.HTTPRequest" }), OpenLayers.Tile = OpenLayers.Class({ events: null, eventListeners: null, id: null, layer: null, url: null, bounds: null, size: null, position: null, isLoading: !1, initialize: function (e, t, n, i, s, r) { this.layer = e, this.position = t.clone(), this.setBounds(n), this.url = i, s && (this.size = s.clone()), this.id = OpenLayers.Util.createUniqueID("Tile_"), OpenLayers.Util.extend(this, r), this.events = new OpenLayers.Events(this), this.eventListeners instanceof Object && this.events.on(this.eventListeners) }, unload: function () { this.isLoading && (this.isLoading = !1, this.events.triggerEvent("unload")) }, destroy: function () { this.layer = null, this.bounds = null, this.size = null, this.position = null, this.eventListeners && this.events.un(this.eventListeners), this.events.destroy(), this.eventListeners = null, this.events = null }, draw: function (e) { e || this.clear(); var t = this.shouldDraw(); return t && !e && !1 === this.events.triggerEvent("beforedraw") && (t = null), t }, shouldDraw: function () { var e = !1, t = this.layer.maxExtent; if (t) { var n = this.layer.map, i = n.baseLayer.wrapDateLine && n.getMaxExtent(); this.bounds.intersectsBounds(t, { inclusive: !1, worldBounds: i }) && (e = !0) } return e || this.layer.displayOutsideMaxExtent }, setBounds: function (e) { if (e = e.clone(), this.layer.map.baseLayer.wrapDateLine) { var t = this.layer.map.getMaxExtent(), n = this.layer.map.getResolution(); e = e.wrapDateLine(t, { leftTolerance: n, rightTolerance: n }) } this.bounds = e }, moveTo: function (e, t, n) { null == n && (n = !0), this.setBounds(e), this.position = t.clone(), n && this.draw() }, clear: function (e) { }, CLASS_NAME: "OpenLayers.Tile" }), OpenLayers.Tile.Image = OpenLayers.Class(OpenLayers.Tile, { url: null, imgDiv: null, frame: null, imageReloadAttempts: null, layerAlphaHack: null, asyncRequestId: null, maxGetUrlLength: null, canvasContext: null, crossOriginKeyword: null, initialize: function (e, t, n, i, s, r) { OpenLayers.Tile.prototype.initialize.apply(this, arguments), this.url = i, this.layerAlphaHack = this.layer.alpha && OpenLayers.Util.alphaHack(), (null != this.maxGetUrlLength || this.layer.gutter || this.layerAlphaHack) && (this.frame = document.createElement("div"), this.frame.style.position = "absolute", this.frame.style.overflow = "hidden"), null != this.maxGetUrlLength && OpenLayers.Util.extend(this, OpenLayers.Tile.Image.IFrame) }, destroy: function () { this.imgDiv && (this.clear(), this.imgDiv = null, this.frame = null), this.asyncRequestId = null, OpenLayers.Tile.prototype.destroy.apply(this, arguments) }, draw: function () { var e = OpenLayers.Tile.prototype.draw.apply(this, arguments); return e ? (this.layer != this.layer.map.baseLayer && this.layer.reproject && (this.bounds = this.getBoundsFromBaseLayer(this.position)), this.isLoading ? this._loadEvent = "reload" : (this.isLoading = !0, this._loadEvent = "loadstart"), this.renderTile(), this.positionTile()) : !1 === e && this.unload(), e }, renderTile: function () { if (this.layer.async) { var e = this.asyncRequestId = (this.asyncRequestId || 0) + 1; this.layer.getURLasync(this.bounds, function (t) { e == this.asyncRequestId && (this.url = t, this.initImage()) }, this) } else this.url = this.layer.getURL(this.bounds), this.initImage() }, positionTile: function () { var e = this.getTile().style, t = this.frame ? this.size : this.layer.getImageSize(this.bounds), n = 1; this.layer instanceof OpenLayers.Layer.Grid && (n = this.layer.getServerResolution() / this.layer.map.getResolution()), e.left = this.position.x + "px", e.top = this.position.y + "px", e.width = Math.round(n * t.w) + "px", e.height = Math.round(n * t.h) + "px" }, clear: function () { OpenLayers.Tile.prototype.clear.apply(this, arguments); var e = this.imgDiv; if (e) { var t = this.getTile(); t.parentNode === this.layer.div && this.layer.div.removeChild(t), this.setImgSrc(), !0 === this.layerAlphaHack && (e.style.filter = ""), OpenLayers.Element.removeClass(e, "olImageLoadError") } this.canvasContext = null }, getImage: function () { if (!this.imgDiv) { this.imgDiv = OpenLayers.Tile.Image.IMAGE.cloneNode(!1); var e = this.imgDiv.style; if (this.frame) { var t = 0, n = 0; this.layer.gutter && (t = this.layer.gutter / this.layer.tileSize.w * 100, n = this.layer.gutter / this.layer.tileSize.h * 100), e.left = -t + "%", e.top = -n + "%", e.width = 2 * t + 100 + "%", e.height = 2 * n + 100 + "%" } e.visibility = "hidden", e.opacity = 0, this.layer.opacity < 1 && (e.filter = "alpha(opacity=" + 100 * this.layer.opacity + ")"), e.position = "absolute", this.layerAlphaHack && (e.paddingTop = e.height, e.height = "0", e.width = "100%"), this.frame && this.frame.appendChild(this.imgDiv) } return this.imgDiv }, setImage: function (e) { this.imgDiv = e }, initImage: function () { if (this.url || this.imgDiv) { this.events.triggerEvent("beforeload"), this.layer.div.appendChild(this.getTile()), this.events.triggerEvent(this._loadEvent); var e = this.getImage(), t = e.getAttribute("src") || ""; this.url && OpenLayers.Util.isEquivalentUrl(t, this.url) ? this._loadTimeout = window.setTimeout(OpenLayers.Function.bind(this.onImageLoad, this), 0) : (this.stopLoading(), this.crossOriginKeyword && e.removeAttribute("crossorigin"), OpenLayers.Event.observe(e, "load", OpenLayers.Function.bind(this.onImageLoad, this)), OpenLayers.Event.observe(e, "error", OpenLayers.Function.bind(this.onImageError, this)), this.imageReloadAttempts = 0, this.setImgSrc(this.url)) } else this.isLoading = !1 }, setImgSrc: function (e) { var t = this.imgDiv; e ? (t.style.visibility = "hidden", t.style.opacity = 0, this.crossOriginKeyword && ("data:" !== e.substr(0, 5) ? t.setAttribute("crossorigin", this.crossOriginKeyword) : t.removeAttribute("crossorigin")), t.src = e) : (this.stopLoading(), this.imgDiv = null, t.parentNode && t.parentNode.removeChild(t)) }, getTile: function () { return this.frame ? this.frame : this.getImage() }, createBackBuffer: function () { var e; if (this.imgDiv && !this.isLoading) return this.frame ? (e = this.frame.cloneNode(!1)).appendChild(this.imgDiv) : e = this.imgDiv, this.imgDiv = null, e }, onImageLoad: function () { var e = this.imgDiv; this.stopLoading(), e.style.visibility = "inherit", e.style.opacity = this.layer.opacity, this.isLoading = !1, this.canvasContext = null, this.events.triggerEvent("loadend"), !0 === this.layerAlphaHack && (e.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + e.src + "', sizingMethod='scale')") }, onImageError: function () { var e = this.imgDiv; null != e.src && (this.imageReloadAttempts++ , this.imageReloadAttempts <= OpenLayers.IMAGE_RELOAD_ATTEMPTS ? this.setImgSrc(this.layer.getURL(this.bounds)) : (OpenLayers.Element.addClass(e, "olImageLoadError"), this.events.triggerEvent("loaderror"), this.onImageLoad())) }, stopLoading: function () { OpenLayers.Event.stopObservingElement(this.imgDiv), window.clearTimeout(this._loadTimeout), delete this._loadTimeout }, getCanvasContext: function () { if (OpenLayers.CANVAS_SUPPORTED && this.imgDiv && !this.isLoading) { if (!this.canvasContext) { var e = document.createElement("canvas"); e.width = this.size.w, e.height = this.size.h, this.canvasContext = e.getContext("2d"), this.canvasContext.drawImage(this.imgDiv, 0, 0) } return this.canvasContext } }, CLASS_NAME: "OpenLayers.Tile.Image" }), OpenLayers.Tile.Image.IMAGE = function () { var e = new Image; return e.className = "olTileImage", e.galleryImg = "no", e }(), OpenLayers.Layer.Grid = OpenLayers.Class(OpenLayers.Layer.HTTPRequest, { tileSize: null, tileOriginCorner: "bl", tileOrigin: null, tileOptions: null, tileClass: OpenLayers.Tile.Image, grid: null, singleTile: !1, ratio: 1.5, buffer: 0, transitionEffect: "resize", numLoadingTiles: 0, serverResolutions: null, loading: !1, backBuffer: null, gridResolution: null, backBufferResolution: null, backBufferLonLat: null, backBufferTimerId: null, removeBackBufferDelay: null, className: null, gridLayout: null, rowSign: null, transitionendEvents: ["transitionend", "webkitTransitionEnd", "otransitionend", "oTransitionEnd"], initialize: function (e, t, n, i) { OpenLayers.Layer.HTTPRequest.prototype.initialize.apply(this, arguments), this.grid = [], this._removeBackBuffer = OpenLayers.Function.bind(this.removeBackBuffer, this), this.initProperties(), this.rowSign = "t" === this.tileOriginCorner.substr(0, 1) ? 1 : -1 }, initProperties: function () { void 0 === this.options.removeBackBufferDelay && (this.removeBackBufferDelay = this.singleTile ? 0 : 2500), void 0 === this.options.className && (this.className = this.singleTile ? "olLayerGridSingleTile" : "olLayerGrid") }, setMap: function (e) { OpenLayers.Layer.HTTPRequest.prototype.setMap.call(this, e), OpenLayers.Element.addClass(this.div, this.className) }, removeMap: function (e) { this.removeBackBuffer() }, destroy: function () { this.removeBackBuffer(), this.clearGrid(), this.grid = null, this.tileSize = null, OpenLayers.Layer.HTTPRequest.prototype.destroy.apply(this, arguments) }, clearGrid: function () { if (this.grid) { for (var e = 0, t = this.grid.length; e < t; e++)for (var n = this.grid[e], i = 0, s = n.length; i < s; i++) { var r = n[i]; this.destroyTile(r) } this.grid = [], this.gridResolution = null, this.gridLayout = null } }, addOptions: function (e, t) { var n = void 0 !== e.singleTile && e.singleTile !== this.singleTile; OpenLayers.Layer.HTTPRequest.prototype.addOptions.apply(this, arguments), this.map && n && (this.initProperties(), this.clearGrid(), this.tileSize = this.options.tileSize, this.setTileSize(), this.moveTo(null, !0)) }, clone: function (e) { return null == e && (e = new OpenLayers.Layer.Grid(this.name, this.url, this.params, this.getOptions())), e = OpenLayers.Layer.HTTPRequest.prototype.clone.apply(this, [e]), null != this.tileSize && (e.tileSize = this.tileSize.clone()), e.grid = [], e.gridResolution = null, e.backBuffer = null, e.backBufferTimerId = null, e.loading = !1, e.numLoadingTiles = 0, e }, moveTo: function (e, t, n) { if (OpenLayers.Layer.HTTPRequest.prototype.moveTo.apply(this, arguments), null != (e = e || this.map.getExtent())) { var i = !this.grid.length || t, s = this.getTilesBounds(), r = this.map.getResolution(); this.getServerResolution(r); this.singleTile ? (i || !n && !s.containsBounds(e)) && (t && "resize" !== this.transitionEffect && this.removeBackBuffer(), t && "resize" !== this.transitionEffect || this.applyBackBuffer(r), this.initSingleTile(e)) : (i = i || !s.intersectsBounds(e, { worldBounds: this.map.baseLayer.wrapDateLine && this.map.getMaxExtent() })) ? (!t || "resize" !== this.transitionEffect && this.gridResolution !== r || this.applyBackBuffer(r), this.initGriddedTiles(e)) : this.moveGriddedTiles() } }, getTileData: function (e) { var t = null, n = e.lon, i = e.lat, s = this.grid.length; if (this.map && s) { var r = this.map.getResolution(), a = this.tileSize.w, o = this.tileSize.h, l = this.grid[0][0].bounds, h = l.left, p = l.top; if (n < h && this.map.baseLayer.wrapDateLine) { var u = this.map.getMaxExtent().getWidth(); n += u * Math.ceil((h - n) / u) } var y = (n - h) / (r * a), c = (p - i) / (r * o), d = Math.floor(y), f = Math.floor(c); if (f >= 0 && f < s) { var m = this.grid[f][d]; m && (t = { tile: m, i: Math.floor((y - d) * a), j: Math.floor((c - f) * o) }) } } return t }, destroyTile: function (e) { this.removeTileMonitoringHooks(e), e.destroy() }, getServerResolution: function (e) { var t = Number.POSITIVE_INFINITY; if (e = e || this.map.getResolution(), this.serverResolutions && -1 === OpenLayers.Util.indexOf(this.serverResolutions, e)) { var n, i, s, r; for (n = this.serverResolutions.length - 1; n >= 0 && (s = this.serverResolutions[n], !((i = Math.abs(s - e)) > t)); n--)t = i, r = s; e = r } return e }, getServerZoom: function () { var e = this.getServerResolution(); return this.serverResolutions ? OpenLayers.Util.indexOf(this.serverResolutions, e) : this.map.getZoomForResolution(e) + (this.zoomOffset || 0) }, applyBackBuffer: function (e) { null !== this.backBufferTimerId && this.removeBackBuffer(); var t = this.backBuffer; if (!t) { if (!(t = this.createBackBuffer())) return; e === this.gridResolution ? this.div.insertBefore(t, this.div.firstChild) : this.map.baseLayer.div.parentNode.insertBefore(t, this.map.baseLayer.div), this.backBuffer = t; var n = this.grid[0][0].bounds; this.backBufferLonLat = { lon: n.left, lat: n.top }, this.backBufferResolution = this.gridResolution } for (var i, s = this.backBufferResolution / e, r = t.childNodes, a = r.length - 1; a >= 0; --a)(i = r[a]).style.top = (s * i._i * i._h | 0) + "px", i.style.left = (s * i._j * i._w | 0) + "px", i.style.width = Math.round(s * i._w) + "px", i.style.height = Math.round(s * i._h) + "px"; var o = this.getViewPortPxFromLonLat(this.backBufferLonLat, e), l = this.map.layerContainerOriginPx.x, h = this.map.layerContainerOriginPx.y; t.style.left = Math.round(o.x - l) + "px", t.style.top = Math.round(o.y - h) + "px" }, createBackBuffer: function () { var e; if (this.grid.length > 0) { (e = document.createElement("div")).id = this.div.id + "_bb", e.className = "olBackBuffer", e.style.position = "absolute"; var t = this.map; e.style.zIndex = "resize" === this.transitionEffect ? this.getZIndex() - 1 : t.Z_INDEX_BASE.BaseLayer - (t.getNumLayers() - t.getLayerIndex(this)); for (var n = 0, i = this.grid.length; n < i; n++)for (var s = 0, r = this.grid[n].length; s < r; s++) { var a = this.grid[n][s], o = this.grid[n][s].createBackBuffer(); o && (o._i = n, o._j = s, o._w = a.size.w, o._h = a.size.h, o.id = a.id + "_bb", e.appendChild(o)) } } return e }, removeBackBuffer: function () { if (this._transitionElement) { for (var e = this.transitionendEvents.length - 1; e >= 0; --e)OpenLayers.Event.stopObserving(this._transitionElement, this.transitionendEvents[e], this._removeBackBuffer); delete this._transitionElement } this.backBuffer && (this.backBuffer.parentNode && this.backBuffer.parentNode.removeChild(this.backBuffer), this.backBuffer = null, this.backBufferResolution = null, null !== this.backBufferTimerId && (window.clearTimeout(this.backBufferTimerId), this.backBufferTimerId = null)) }, moveByPx: function (e, t) { this.singleTile || this.moveGriddedTiles() }, setTileSize: function (e) { this.singleTile && ((e = this.map.getSize()).h = parseInt(e.h * this.ratio, 10), e.w = parseInt(e.w * this.ratio, 10)), OpenLayers.Layer.HTTPRequest.prototype.setTileSize.apply(this, [e]) }, getTilesBounds: function () { var e = null, t = this.grid.length; if (t) { var n = this.grid[t - 1][0].bounds, i = this.grid[0].length * n.getWidth(), s = this.grid.length * n.getHeight(); e = new OpenLayers.Bounds(n.left, n.bottom, n.left + i, n.bottom + s) } return e }, initSingleTile: function (e) { this.events.triggerEvent("retile"); var t = e.getCenterLonLat(), n = e.getWidth() * this.ratio, i = e.getHeight() * this.ratio, s = new OpenLayers.Bounds(t.lon - n / 2, t.lat - i / 2, t.lon + n / 2, t.lat + i / 2), r = this.map.getLayerPxFromLonLat({ lon: s.left, lat: s.top }); this.grid.length || (this.grid[0] = []); var a = this.grid[0][0]; a ? a.moveTo(s, r) : (a = this.addTile(s, r), this.addTileMonitoringHooks(a), a.draw(), this.grid[0][0] = a), this.removeExcessTiles(1, 1), this.gridResolution = this.getServerResolution() }, calculateGridLayout: function (e, t, n) { var i = n * this.tileSize.w, s = n * this.tileSize.h, r = e.left - t.lon, a = Math.floor(r / i) - this.buffer, o = this.rowSign, l = o * (t.lat - e.top + s); return { tilelon: i, tilelat: s, startcol: a, startrow: Math[~o ? "floor" : "ceil"](l / s) - this.buffer * o } }, getTileOrigin: function () { var e = this.tileOrigin; if (!e) { var t = this.getMaxExtent(), n = { tl: ["left", "top"], tr: ["right", "top"], bl: ["left", "bottom"], br: ["right", "bottom"] }[this.tileOriginCorner]; e = new OpenLayers.LonLat(t[n[0]], t[n[1]]) } return e }, getTileBoundsForGridIndex: function (e, t) { var n = this.getTileOrigin(), i = this.gridLayout, s = i.tilelon, r = i.tilelat, a = i.startcol, o = i.startrow, l = this.rowSign; return new OpenLayers.Bounds(n.lon + (a + t) * s, n.lat - (o + e * l) * r * l, n.lon + (a + t + 1) * s, n.lat - (o + (e - 1) * l) * r * l) }, initGriddedTiles: function (e) { this.events.triggerEvent("retile"); var t = this.map.getSize(), n = this.getTileOrigin(), i = this.map.getResolution(), s = this.getServerResolution(), r = i / s, a = { w: this.tileSize.w / r, h: this.tileSize.h / r }, o = Math.ceil(t.h / a.h) + 2 * this.buffer + 1, l = Math.ceil(t.w / a.w) + 2 * this.buffer + 1, h = this.calculateGridLayout(e, n, s); this.gridLayout = h; var p = h.tilelon, u = h.tilelat, y = this.map.layerContainerOriginPx.x, c = this.map.layerContainerOriginPx.y, d = this.getTileBoundsForGridIndex(0, 0), f = this.map.getViewPortPxFromLonLat(new OpenLayers.LonLat(d.left, d.top)); f.x = Math.round(f.x) - y, f.y = Math.round(f.y) - c; var m = [], g = this.map.getCenter(), L = 0; do { var v = this.grid[L]; v || (v = [], this.grid.push(v)); var O = 0; do { d = this.getTileBoundsForGridIndex(L, O); var x = f.clone(); x.x = x.x + O * Math.round(a.w), x.y = x.y + L * Math.round(a.h); var E = v[O]; E ? E.moveTo(d, x, !1) : (E = this.addTile(d, x), this.addTileMonitoringHooks(E), v.push(E)); var b = d.getCenterLonLat(); m.push({ tile: E, distance: Math.pow(b.lon - g.lon, 2) + Math.pow(b.lat - g.lat, 2) }), O += 1 } while (d.right <= e.right + p * this.buffer || O < l); L += 1 } while (d.bottom >= e.bottom - u * this.buffer || L < o); this.removeExcessTiles(L, O); i = this.getServerResolution(); this.gridResolution = i, m.sort(function (e, t) { return e.distance - t.distance }); for (var S = 0, w = m.length; S < w; ++S)m[S].tile.draw() }, getMaxExtent: function () { return this.maxExtent }, addTile: function (e, t) { var n = new this.tileClass(this, t, e, null, this.tileSize, this.tileOptions); return this.events.triggerEvent("addtile", { tile: n }), n }, addTileMonitoringHooks: function (e) { e.onLoadStart = function () { !1 === this.loading && (this.loading = !0, this.events.triggerEvent("loadstart")), this.events.triggerEvent("tileloadstart", { tile: e }), this.numLoadingTiles++ , !this.singleTile && this.backBuffer && this.gridResolution === this.backBufferResolution && OpenLayers.Element.addClass(e.getTile(), "olTileReplacing") }, e.onLoadEnd = function (t) { this.numLoadingTiles--; var n = "unload" === t.type; if (this.events.triggerEvent("tileloaded", { tile: e, aborted: n }), !this.singleTile && !n && this.backBuffer && this.gridResolution === this.backBufferResolution) { var i = e.getTile(); if ("none" === OpenLayers.Element.getStyle(i, "display")) { var s = document.getElementById(e.id + "_bb"); s && s.parentNode.removeChild(s) } OpenLayers.Element.removeClass(i, "olTileReplacing") } if (0 === this.numLoadingTiles) { if (this.backBuffer) if (0 === this.backBuffer.childNodes.length) this.removeBackBuffer(); else { this._transitionElement = n ? this.div.lastChild : e.imgDiv; for (var r = this.transitionendEvents, a = r.length - 1; a >= 0; --a)OpenLayers.Event.observe(this._transitionElement, r[a], this._removeBackBuffer); this.backBufferTimerId = window.setTimeout(this._removeBackBuffer, this.removeBackBufferDelay) } this.loading = !1, this.events.triggerEvent("loadend") } }, e.onLoadError = function () { this.events.triggerEvent("tileerror", { tile: e }) }, e.events.on({ loadstart: e.onLoadStart, loadend: e.onLoadEnd, unload: e.onLoadEnd, loaderror: e.onLoadError, scope: this }) }, removeTileMonitoringHooks: function (e) { e.unload(), e.events.un({ loadstart: e.onLoadStart, loadend: e.onLoadEnd, unload: e.onLoadEnd, loaderror: e.onLoadError, scope: this }) }, moveGriddedTiles: function () { for (var e = this.buffer + 1; ;) { var t = this.grid[0][0], n = { x: t.position.x + this.map.layerContainerOriginPx.x, y: t.position.y + this.map.layerContainerOriginPx.y }, i = this.getServerResolution() / this.map.getResolution(), s = { w: Math.round(this.tileSize.w * i), h: Math.round(this.tileSize.h * i) }; if (n.x > -s.w * (e - 1)) this.shiftColumn(!0, s); else if (n.x < -s.w * e) this.shiftColumn(!1, s); else if (n.y > -s.h * (e - 1)) this.shiftRow(!0, s); else { if (!(n.y < -s.h * e)) break; this.shiftRow(!1, s) } } }, shiftRow: function (e, t) { var n = this.grid, i = e ? 0 : n.length - 1, s = e ? -1 : 1, r = this.rowSign; this.gridLayout.startrow += s * r; for (var a = n[i], o = n[e ? "pop" : "shift"](), l = 0, h = o.length; l < h; l++) { var p = o[l], u = a[l].position.clone(); u.y += t.h * s, p.moveTo(this.getTileBoundsForGridIndex(i, l), u) } n[e ? "unshift" : "push"](o) }, shiftColumn: function (e, t) { var n = this.grid, i = e ? 0 : n[0].length - 1, s = e ? -1 : 1; this.gridLayout.startcol += s; for (var r = 0, a = n.length; r < a; r++) { var o = n[r], l = o[i].position.clone(), h = o[e ? "pop" : "shift"](); l.x += t.w * s, h.moveTo(this.getTileBoundsForGridIndex(r, i), l), o[e ? "unshift" : "push"](h) } }, removeExcessTiles: function (e, t) { for (var n, i; this.grid.length > e;) { for (n = 0, i = (r = this.grid.pop()).length; n < i; n++) { var s = r[n]; this.destroyTile(s) } } for (n = 0, i = this.grid.length; n < i; n++)for (; this.grid[n].length > t;) { var r; s = (r = this.grid[n]).pop(); this.destroyTile(s) } }, onMapResize: function () { this.singleTile && (this.clearGrid(), this.setTileSize()) }, getTileBounds: function (e) { var t = this.maxExtent, n = this.getResolution(), i = n * this.tileSize.w, s = n * this.tileSize.h, r = this.getLonLatFromViewPortPx(e), a = t.left + i * Math.floor((r.lon - t.left) / i), o = t.bottom + s * Math.floor((r.lat - t.bottom) / s); return new OpenLayers.Bounds(a, o, a + i, o + s) }, CLASS_NAME: "OpenLayers.Layer.Grid" }), OpenLayers.Layer.XYZ = OpenLayers.Class(OpenLayers.Layer.Grid, { isBaseLayer: !0, sphericalMercator: !1, zoomOffset: 0, serverResolutions: null, initialize: function (e, t, n) { (n && n.sphericalMercator || this.sphericalMercator) && (n = OpenLayers.Util.extend({ projection: "EPSG:900913", numZoomLevels: 19 }, n)), OpenLayers.Layer.Grid.prototype.initialize.apply(this, [e || this.name, t || this.url, {}, n]) }, clone: function (e) { return null == e && (e = new OpenLayers.Layer.XYZ(this.name, this.url, this.getOptions())), e = OpenLayers.Layer.Grid.prototype.clone.apply(this, [e]) }, getURL: function (e) { var t = this.getXYZ(e), n = this.url; if (OpenLayers.Util.isArray(n)) { var i = "" + t.x + t.y + t.z; n = this.selectUrl(i, n) } return OpenLayers.String.format(n, t) }, getXYZ: function (e) { var t = this.getServerResolution(), n = Math.round((e.left - this.maxExtent.left) / (t * this.tileSize.w)), i = Math.round((this.maxExtent.top - e.top) / (t * this.tileSize.h)), s = this.getServerZoom(); if (this.wrapDateLine) { var r = Math.pow(2, s); n = (n % r + r) % r } return { x: n, y: i, z: s } }, setMap: function (e) { OpenLayers.Layer.Grid.prototype.setMap.apply(this, arguments), this.tileOrigin || (this.tileOrigin = new OpenLayers.LonLat(this.maxExtent.left, this.maxExtent.bottom)) }, CLASS_NAME: "OpenLayers.Layer.XYZ" }), OpenLayers.Layer.OSM = OpenLayers.Class(OpenLayers.Layer.XYZ, { name: "OpenStreetMap", url: ["http://a.tile.openstreetmap.org/${z}/${x}/${y}.png", "http://b.tile.openstreetmap.org/${z}/${x}/${y}.png", "http://c.tile.openstreetmap.org/${z}/${x}/${y}.png"], attribution: "&copy; <a href='http://www.openstreetmap.org/copyright'>OpenStreetMap</a> contributors", sphericalMercator: !0, wrapDateLine: !0, tileOptions: null, initialize: function (e, t, n) { OpenLayers.Layer.XYZ.prototype.initialize.apply(this, arguments), this.tileOptions = OpenLayers.Util.extend({ crossOriginKeyword: "anonymous" }, this.options && this.options.tileOptions) }, clone: function (e) { return null == e && (e = new OpenLayers.Layer.OSM(this.name, this.url, this.getOptions())), e = OpenLayers.Layer.XYZ.prototype.clone.apply(this, [e]) }, CLASS_NAME: "OpenLayers.Layer.OSM" }), OpenLayers.Layer.Bing = OpenLayers.Class(OpenLayers.Layer.XYZ, { key: null, serverResolutions: [156543.03390625, 78271.516953125, 39135.7584765625, 19567.87923828125, 9783.939619140625, 4891.9698095703125, 2445.9849047851562, 1222.9924523925781, 611.4962261962891, 305.74811309814453, 152.87405654907226, 76.43702827453613, 38.218514137268066, 19.109257068634033, 9.554628534317017, 4.777314267158508, 2.388657133579254, 1.194328566789627, .5971642833948135, .29858214169740677, .14929107084870338, .07464553542435169], attributionTemplate: '<span class="olBingAttribution ${type}"><div><a target="_blank" href="http://www.bing.com/maps/"><img src="${logo}" /></a></div>${copyrights}<a style="white-space: nowrap" target="_blank" href="http://www.microsoft.com/maps/product/terms.html">Terms of Use</a></span>', metadata: null, protocolRegex: /^http:/i, type: "Road", culture: "en-US", metadataParams: null, tileOptions: null, protocol: ~window.location.href.indexOf("http") ? "" : "http:", initialize: function (e) { var t = [(e = OpenLayers.Util.applyDefaults({ sphericalMercator: !0 }, e)).name || "Bing " + (e.type || this.type), null, e]; OpenLayers.Layer.XYZ.prototype.initialize.apply(this, t), this.tileOptions = OpenLayers.Util.extend({ crossOriginKeyword: "anonymous" }, this.options.tileOptions), this.loadMetadata() }, loadMetadata: function () { this._callbackId = "_callback_" + this.id.replace(/\./g, "_"), window[this._callbackId] = OpenLayers.Function.bind(OpenLayers.Layer.Bing.processMetadata, this); var e = OpenLayers.Util.applyDefaults({ key: this.key, jsonp: this._callbackId, include: "ImageryProviders" }, this.metadataParams), t = this.protocol + "//dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.type + "?" + OpenLayers.Util.getParameterString(e), n = document.createElement("script"); n.type = "text/javascript", n.src = t, n.id = this._callbackId, document.getElementsByTagName("head")[0].appendChild(n) }, initLayer: function () { var e = this.metadata.resourceSets[0].resources[0], t = e.imageUrl.replace("{quadkey}", "${quadkey}"); t = (t = t.replace("{culture}", this.culture)).replace(this.protocolRegex, this.protocol), this.url = []; for (var n = 0; n < e.imageUrlSubdomains.length; ++n)this.url.push(t.replace("{subdomain}", e.imageUrlSubdomains[n])); this.addOptions({ maxResolution: Math.min(this.serverResolutions[e.zoomMin], this.maxResolution || Number.POSITIVE_INFINITY), numZoomLevels: Math.min(e.zoomMax + 1 - e.zoomMin, this.numZoomLevels) }, !0), this.isBaseLayer || this.redraw(), this.updateAttribution() }, getURL: function (e) { if (this.url) { for (var t = this.getXYZ(e), n = t.x, i = t.y, s = t.z, r = [], a = s; a > 0; --a) { var o = "0", l = 1 << a - 1; 0 != (n & l) && o++ , 0 != (i & l) && (o++ , o++), r.push(o) } var h = r.join(""), p = this.selectUrl("" + n + i + s, this.url); return OpenLayers.String.format(p, { quadkey: h }) } }, updateAttribution: function () { var e = this.metadata; if (e.resourceSets && this.map && this.map.center) { var t, n, i, s, r, a, o, l = e.resourceSets[0].resources[0], h = this.map.getExtent().transform(this.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326")), p = l.imageryProviders || [], u = OpenLayers.Util.indexOf(this.serverResolutions, this.getServerResolution()), y = ""; for (n = 0, i = p.length; n < i; ++n)for (s = 0, r = (t = p[n]).coverageAreas.length; s < r; ++s)o = t.coverageAreas[s], a = OpenLayers.Bounds.fromArray(o.bbox, !0), h.intersectsBounds(a) && u <= o.zoomMax && u >= o.zoomMin && (y += t.attribution + " "); var c = e.brandLogoUri.replace(this.protocolRegex, this.protocol); this.attribution = OpenLayers.String.format(this.attributionTemplate, { type: this.type.toLowerCase(), logo: c, copyrights: y }), this.map && this.map.events.triggerEvent("changelayer", { layer: this, property: "attribution" }) } }, setMap: function () { OpenLayers.Layer.XYZ.prototype.setMap.apply(this, arguments), this.map.events.register("moveend", this, this.updateAttribution) }, clone: function (e) { return null == e && (e = new OpenLayers.Layer.Bing(this.options)), e = OpenLayers.Layer.XYZ.prototype.clone.apply(this, [e]) }, destroy: function () { this.map && this.map.events.unregister("moveend", this, this.updateAttribution), OpenLayers.Layer.XYZ.prototype.destroy.apply(this, arguments) }, CLASS_NAME: "OpenLayers.Layer.Bing" }), OpenLayers.Layer.Bing.processMetadata = function (e) { this.metadata = e, this.initLayer(); var t = document.getElementById(this._callbackId); t.parentNode.removeChild(t), window[this._callbackId] = void 0, delete this._callbackId }, OpenLayers.Handler = OpenLayers.Class({ id: null, control: null, map: null, keyMask: null, active: !1, evt: null, touch: !1, initialize: function (e, t, n) { OpenLayers.Util.extend(this, n), this.control = e, this.callbacks = t; var i = this.map || e.map; i && this.setMap(i), this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_") }, setMap: function (e) { this.map = e }, checkModifiers: function (e) { return null == this.keyMask || ((e.shiftKey ? OpenLayers.Handler.MOD_SHIFT : 0) | (e.ctrlKey ? OpenLayers.Handler.MOD_CTRL : 0) | (e.altKey ? OpenLayers.Handler.MOD_ALT : 0) | (e.metaKey ? OpenLayers.Handler.MOD_META : 0)) == this.keyMask }, activate: function () { if (this.active) return !1; for (var e = OpenLayers.Events.prototype.BROWSER_EVENTS, t = 0, n = e.length; t < n; t++)this[e[t]] && this.register(e[t], this[e[t]]); return this.active = !0, !0 }, deactivate: function () { if (!this.active) return !1; for (var e = OpenLayers.Events.prototype.BROWSER_EVENTS, t = 0, n = e.length; t < n; t++)this[e[t]] && this.unregister(e[t], this[e[t]]); return this.touch = !1, this.active = !1, !0 }, startTouch: function () { if (!this.touch) { this.touch = !0; for (var e = ["mousedown", "mouseup", "mousemove", "click", "dblclick", "mouseout"], t = 0, n = e.length; t < n; t++)this[e[t]] && this.unregister(e[t], this[e[t]]) } }, callback: function (e, t) { e && this.callbacks[e] && this.callbacks[e].apply(this.control, t) }, register: function (e, t) { this.map.events.registerPriority(e, this, t), this.map.events.registerPriority(e, this, this.setEvent) }, unregister: function (e, t) { this.map.events.unregister(e, this, t), this.map.events.unregister(e, this, this.setEvent) }, setEvent: function (e) { return this.evt = e, !0 }, destroy: function () { this.deactivate(), this.control = this.map = null }, CLASS_NAME: "OpenLayers.Handler" }), OpenLayers.Handler.MOD_NONE = 0, OpenLayers.Handler.MOD_SHIFT = 1, OpenLayers.Handler.MOD_CTRL = 2, OpenLayers.Handler.MOD_ALT = 4, OpenLayers.Handler.MOD_META = 8, OpenLayers.Handler.MouseWheel = OpenLayers.Class(OpenLayers.Handler, { wheelListener: null, interval: 0, maxDelta: Number.POSITIVE_INFINITY, delta: 0, cumulative: !0, initialize: function (e, t, n) { OpenLayers.Handler.prototype.initialize.apply(this, arguments), this.wheelListener = OpenLayers.Function.bindAsEventListener(this.onWheelEvent, this) }, destroy: function () { OpenLayers.Handler.prototype.destroy.apply(this, arguments), this.wheelListener = null }, onWheelEvent: function (e) { if (this.map && this.checkModifiers(e)) { for (var t = !1, n = !1, i = !1, s = OpenLayers.Event.element(e); null != s && !i && !t;) { if (!t) try { var r; if (s.currentStyle) r = s.currentStyle.overflow; else r = document.defaultView.getComputedStyle(s, null).getPropertyValue("overflow"); t = r && "auto" == r || "scroll" == r } catch (e) { } if (!n && !(n = OpenLayers.Element.hasClass(s, "olScrollable"))) for (var a = 0, o = this.map.layers.length; a < o; a++) { var l = this.map.layers[a]; if (s == l.div || s == l.pane) { n = !0; break } } i = s == this.map.div, s = s.parentNode } if (!t && i) { if (n) { var h = 0; if (e.wheelDelta ? ((h = e.wheelDelta) % 160 == 0 && (h *= .75), h /= 120) : e.detail && (h = -e.detail / Math.abs(e.detail)), this.delta += h, window.clearTimeout(this._timeoutId), this.interval && Math.abs(this.delta) < this.maxDelta) { var p = OpenLayers.Util.extend({}, e); this._timeoutId = window.setTimeout(OpenLayers.Function.bind(function () { this.wheelZoom(p) }, this), this.interval) } else this.wheelZoom(e) } OpenLayers.Event.stop(e) } } }, wheelZoom: function (e) { var t = this.delta; this.delta = 0, t && (e.xy = this.map.events.getMousePosition(e), t < 0 ? this.callback("down", [e, this.cumulative ? Math.max(-this.maxDelta, t) : -1]) : this.callback("up", [e, this.cumulative ? Math.min(this.maxDelta, t) : 1])) }, activate: function (e) { if (OpenLayers.Handler.prototype.activate.apply(this, arguments)) { var t = this.wheelListener; return OpenLayers.Event.observe(window, "DOMMouseScroll", t), OpenLayers.Event.observe(window, "mousewheel", t), OpenLayers.Event.observe(document, "mousewheel", t), !0 } return !1 }, deactivate: function (e) { if (OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) { var t = this.wheelListener; return OpenLayers.Event.stopObserving(window, "DOMMouseScroll", t), OpenLayers.Event.stopObserving(window, "mousewheel", t), OpenLayers.Event.stopObserving(document, "mousewheel", t), !0 } return !1 }, CLASS_NAME: "OpenLayers.Handler.MouseWheel" }), OpenLayers.Geometry.MultiLineString = OpenLayers.Class(OpenLayers.Geometry.Collection, { componentTypes: ["OpenLayers.Geometry.LineString"], split: function (e, t) { for (var n, i, s, r, a, o = null, l = t && t.mutual, h = [], p = [e], u = 0, y = this.components.length; u < y; ++u) { i = this.components[u], r = !1; for (var c = 0; c < p.length; ++c)if (n = i.split(p[c], t)) { if (l) { for (var d = 0, f = (s = n[0]).length; d < f; ++d)0 === d && h.length ? h[h.length - 1].addComponent(s[d]) : h.push(new OpenLayers.Geometry.MultiLineString([s[d]])); r = !0, n = n[1] } if (n.length) { n.unshift(c, 1), Array.prototype.splice.apply(p, n); break } } r || (h.length ? h[h.length - 1].addComponent(i.clone()) : h = [new OpenLayers.Geometry.MultiLineString(i.clone())]) } return h && h.length > 1 ? r = !0 : h = [], p && p.length > 1 ? a = !0 : p = [], (r || a) && (o = l ? [h, p] : p), o }, splitWith: function (e, t) { var n, i, s, r, a, o, l, h = null, p = t && t.mutual; if (e instanceof OpenLayers.Geometry.LineString) { l = [], o = [e]; for (var u = 0, y = this.components.length; u < y; ++u) { a = !1, i = this.components[u]; for (var c = 0; c < o.length; ++c)if (n = o[c].split(i, t)) { p && ((s = n[0]).length && (s.unshift(c, 1), Array.prototype.splice.apply(o, s), c += s.length - 2), 0 === (n = n[1]).length && (n = [i.clone()])); for (var d = 0, f = n.length; d < f; ++d)0 === d && l.length ? l[l.length - 1].addComponent(n[d]) : l.push(new OpenLayers.Geometry.MultiLineString([n[d]])); a = !0 } a || (l.length ? l[l.length - 1].addComponent(i.clone()) : l = [new OpenLayers.Geometry.MultiLineString([i.clone()])]) } } else h = e.split(this); return o && o.length > 1 ? r = !0 : o = [], l && l.length > 1 ? a = !0 : l = [], (r || a) && (h = p ? [o, l] : l), h }, CLASS_NAME: "OpenLayers.Geometry.MultiLineString" }), OpenLayers.Renderer = OpenLayers.Class({ container: null, root: null, extent: null, locked: !1, size: null, resolution: null, map: null, featureDx: 0, initialize: function (e, t) { this.container = OpenLayers.Util.getElement(e), OpenLayers.Util.extend(this, t) }, destroy: function () { this.container = null, this.extent = null, this.size = null, this.resolution = null, this.map = null }, supported: function () { return !1 }, setExtent: function (e, t) { if (this.extent = e.clone(), this.map.baseLayer && this.map.baseLayer.wrapDateLine) { var n = e.getWidth() / this.map.getExtent().getWidth(); e = e.scale(1 / n); this.extent = e.wrapDateLine(this.map.getMaxExtent()).scale(n) } return t && (this.resolution = null), !0 }, setSize: function (e) { this.size = e.clone(), this.resolution = null }, getResolution: function () { return this.resolution = this.resolution || this.map.getResolution(), this.resolution }, drawFeature: function (e, t) { if (null == t && (t = e.style), e.geometry) { var n = e.geometry.getBounds(); if (n) { var i; this.map.baseLayer && this.map.baseLayer.wrapDateLine && (i = this.map.getMaxExtent()), n.intersectsBounds(this.extent, { worldBounds: i }) ? this.calculateFeatureDx(n, i) : t = { display: "none" }; var s = this.drawGeometry(e.geometry, t, e.id); if ("none" != t.display && t.label && !1 !== s) { var r = e.geometry.getCentroid(); if (t.labelXOffset || t.labelYOffset) { var a = isNaN(t.labelXOffset) ? 0 : t.labelXOffset, o = isNaN(t.labelYOffset) ? 0 : t.labelYOffset, l = this.getResolution(); r.move(a * l, o * l) } this.drawText(e.id, t, r) } else this.removeText(e.id); return s } } }, calculateFeatureDx: function (e, t) { if (this.featureDx = 0, t) { var n = t.getWidth(), i = (this.extent.left + this.extent.right) / 2, s = (e.left + e.right) / 2, r = Math.round((s - i) / n); this.featureDx = r * n } }, drawGeometry: function (e, t, n) { }, drawText: function (e, t, n) { }, removeText: function (e) { }, clear: function () { }, getFeatureIdFromEvent: function (e) { }, eraseFeatures: function (e) { OpenLayers.Util.isArray(e) || (e = [e]); for (var t = 0, n = e.length; t < n; ++t) { var i = e[t]; this.eraseGeometry(i.geometry, i.id), this.removeText(i.id) } }, eraseGeometry: function (e, t) { }, moveRoot: function (e) { }, getRenderLayerId: function () { return this.container.id }, applyDefaultSymbolizer: function (e) { var t = OpenLayers.Util.extend({}, OpenLayers.Renderer.defaultSymbolizer); return !1 === e.stroke && (delete t.strokeWidth, delete t.strokeColor), !1 === e.fill && delete t.fillColor, OpenLayers.Util.extend(t, e), t }, CLASS_NAME: "OpenLayers.Renderer" }), OpenLayers.Renderer.defaultSymbolizer = { fillColor: "#000000", strokeColor: "#000000", strokeWidth: 2, fillOpacity: 1, strokeOpacity: 1, pointRadius: 0, labelAlign: "cm" }, OpenLayers.Renderer.symbol = { star: [350, 75, 379, 161, 469, 161, 397, 215, 423, 301, 350, 250, 277, 301, 303, 215, 231, 161, 321, 161, 350, 75], cross: [4, 0, 6, 0, 6, 4, 10, 4, 10, 6, 6, 6, 6, 10, 4, 10, 4, 6, 0, 6, 0, 4, 4, 4, 4, 0], x: [0, 0, 25, 0, 50, 35, 75, 0, 100, 0, 65, 50, 100, 100, 75, 100, 50, 65, 25, 100, 0, 100, 35, 50, 0, 0], square: [0, 0, 0, 1, 1, 1, 1, 0, 0, 0], triangle: [0, 10, 10, 10, 5, 0, 0, 10] }, OpenLayers.ElementsIndexer = OpenLayers.Class({ maxZIndex: null, order: null, indices: null, compare: null, initialize: function (e) { this.compare = e ? OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_Y_ORDER : OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_DRAWING_ORDER, this.clear() }, insert: function (e) { this.exists(e) && this.remove(e); var t = e.id; this.determineZIndex(e); for (var n, i = -1, s = this.order.length; s - i > 1;) { n = parseInt((i + s) / 2), this.compare(this, e, OpenLayers.Util.getElement(this.order[n])) > 0 ? i = n : s = n } return this.order.splice(s, 0, t), this.indices[t] = this.getZIndex(e), this.getNextElement(s) }, remove: function (e) { var t = e.id, n = OpenLayers.Util.indexOf(this.order, t); if (n >= 0) if (this.order.splice(n, 1), delete this.indices[t], this.order.length > 0) { var i = this.order[this.order.length - 1]; this.maxZIndex = this.indices[i] } else this.maxZIndex = 0 }, clear: function () { this.order = [], this.indices = {}, this.maxZIndex = 0 }, exists: function (e) { return null != this.indices[e.id] }, getZIndex: function (e) { return e._style.graphicZIndex }, determineZIndex: function (e) { var t = e._style.graphicZIndex; null == t ? (t = this.maxZIndex, e._style.graphicZIndex = t) : t > this.maxZIndex && (this.maxZIndex = t) }, getNextElement: function (e) { var t = e + 1; if (t < this.order.length) { var n = OpenLayers.Util.getElement(this.order[t]); return null == n && (n = this.getNextElement(t)), n } return null }, CLASS_NAME: "OpenLayers.ElementsIndexer" }), OpenLayers.ElementsIndexer.IndexingMethods = { Z_ORDER: function (e, t, n) { var i = e.getZIndex(t), s = 0; n && (s = i - e.getZIndex(n)); return s }, Z_ORDER_DRAWING_ORDER: function (e, t, n) { var i = OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER(e, t, n); return n && 0 == i && (i = 1), i }, Z_ORDER_Y_ORDER: function (e, t, n) { var i = OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER(e, t, n); if (n && 0 === i) { var s = n._boundsBottom - t._boundsBottom; i = 0 === s ? 1 : s } return i } }, OpenLayers.Renderer.Elements = OpenLayers.Class(OpenLayers.Renderer, { rendererRoot: null, root: null, vectorRoot: null, textRoot: null, xmlns: null, xOffset: 0, indexer: null, BACKGROUND_ID_SUFFIX: "_background", LABEL_ID_SUFFIX: "_label", LABEL_OUTLINE_SUFFIX: "_outline", initialize: function (e, t) { OpenLayers.Renderer.prototype.initialize.apply(this, arguments), this.rendererRoot = this.createRenderRoot(), this.root = this.createRoot("_root"), this.vectorRoot = this.createRoot("_vroot"), this.textRoot = this.createRoot("_troot"), this.root.appendChild(this.vectorRoot), this.root.appendChild(this.textRoot), this.rendererRoot.appendChild(this.root), this.container.appendChild(this.rendererRoot), t && (t.zIndexing || t.yOrdering) && (this.indexer = new OpenLayers.ElementsIndexer(t.yOrdering)) }, destroy: function () { this.clear(), this.rendererRoot = null, this.root = null, this.xmlns = null, OpenLayers.Renderer.prototype.destroy.apply(this, arguments) }, clear: function () { var e, t = this.vectorRoot; if (t) for (; e = t.firstChild;)t.removeChild(e); if (t = this.textRoot) for (; e = t.firstChild;)t.removeChild(e); this.indexer && this.indexer.clear() }, setExtent: function (e, t) { var n = OpenLayers.Renderer.prototype.setExtent.apply(this, arguments), i = this.getResolution(); if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) { var s, r = e.getWidth() / this.map.getExtent().getWidth(), a = (e = e.scale(1 / r), this.map.getMaxExtent()); a.right > e.left && a.right < e.right ? s = !0 : a.left > e.left && a.left < e.right && (s = !1), (s !== this.rightOfDateLine || t) && (n = !1, this.xOffset = !0 === s ? a.getWidth() / i : 0), this.rightOfDateLine = s } return n }, getNodeType: function (e, t) { }, drawGeometry: function (e, t, n) { var i = e.CLASS_NAME, s = !0; if ("OpenLayers.Geometry.Collection" == i || "OpenLayers.Geometry.MultiPoint" == i || "OpenLayers.Geometry.MultiLineString" == i || "OpenLayers.Geometry.MultiPolygon" == i) { for (var r = 0, a = e.components.length; r < a; r++)s = this.drawGeometry(e.components[r], t, n) && s; return s } s = !1; var o, l = !1; ("none" != t.display && (t.backgroundGraphic ? this.redrawBackgroundNode(e.id, e, t, n) : l = !0, s = this.redrawNode(e.id, e, t, n)), 0 == s) && ((o = document.getElementById(e.id)) && (o._style.backgroundGraphic && (l = !0), o.parentNode.removeChild(o))); l && ((o = document.getElementById(e.id + this.BACKGROUND_ID_SUFFIX)) && o.parentNode.removeChild(o)); return s }, redrawNode: function (e, t, n, i) { n = this.applyDefaultSymbolizer(n); var s = this.nodeFactory(e, this.getNodeType(t, n)); s._featureId = i, s._boundsBottom = t.getBounds().bottom, s._geometryClass = t.CLASS_NAME, s._style = n; var r = this.drawGeometryNode(s, t, n); if (!1 === r) return !1; if (s = r.node, this.indexer) { var a = this.indexer.insert(s); a ? this.vectorRoot.insertBefore(s, a) : this.vectorRoot.appendChild(s) } else s.parentNode !== this.vectorRoot && this.vectorRoot.appendChild(s); return this.postDraw(s), r.complete }, redrawBackgroundNode: function (e, t, n, i) { var s = OpenLayers.Util.extend({}, n); return s.externalGraphic = s.backgroundGraphic, s.graphicXOffset = s.backgroundXOffset, s.graphicYOffset = s.backgroundYOffset, s.graphicZIndex = s.backgroundGraphicZIndex, s.graphicWidth = s.backgroundWidth || s.graphicWidth, s.graphicHeight = s.backgroundHeight || s.graphicHeight, s.backgroundGraphic = null, s.backgroundXOffset = null, s.backgroundYOffset = null, s.backgroundGraphicZIndex = null, this.redrawNode(e + this.BACKGROUND_ID_SUFFIX, t, s, null) }, drawGeometryNode: function (e, t, n) { var i, s = { isFilled: void 0 === (n = n || e._style).fill || n.fill, isStroked: void 0 === n.stroke ? !!n.strokeWidth : n.stroke }; switch (t.CLASS_NAME) { case "OpenLayers.Geometry.Point": !1 === n.graphic && (s.isFilled = !1, s.isStroked = !1), i = this.drawPoint(e, t); break; case "OpenLayers.Geometry.LineString": s.isFilled = !1, i = this.drawLineString(e, t); break; case "OpenLayers.Geometry.LinearRing": i = this.drawLinearRing(e, t); break; case "OpenLayers.Geometry.Polygon": i = this.drawPolygon(e, t); break; case "OpenLayers.Geometry.Rectangle": i = this.drawRectangle(e, t) }return e._options = s, 0 != i && { node: this.setStyle(e, n, s, t), complete: i } }, postDraw: function (e) { }, drawPoint: function (e, t) { }, drawLineString: function (e, t) { }, drawLinearRing: function (e, t) { }, drawPolygon: function (e, t) { }, drawRectangle: function (e, t) { }, drawCircle: function (e, t) { }, removeText: function (e) { var t = document.getElementById(e + this.LABEL_ID_SUFFIX); t && this.textRoot.removeChild(t); var n = document.getElementById(e + this.LABEL_OUTLINE_SUFFIX); n && this.textRoot.removeChild(n) }, getFeatureIdFromEvent: function (e) { var t = e.target, n = t && t.correspondingUseElement; return (n || (t || e.srcElement))._featureId }, eraseGeometry: function (e, t) { if ("OpenLayers.Geometry.MultiPoint" == e.CLASS_NAME || "OpenLayers.Geometry.MultiLineString" == e.CLASS_NAME || "OpenLayers.Geometry.MultiPolygon" == e.CLASS_NAME || "OpenLayers.Geometry.Collection" == e.CLASS_NAME) for (var n = 0, i = e.components.length; n < i; n++)this.eraseGeometry(e.components[n], t); else { var s = OpenLayers.Util.getElement(e.id); if (s && s.parentNode && (s.geometry && (s.geometry.destroy(), s.geometry = null), s.parentNode.removeChild(s), this.indexer && this.indexer.remove(s), s._style.backgroundGraphic)) { var r = e.id + this.BACKGROUND_ID_SUFFIX, a = OpenLayers.Util.getElement(r); a && a.parentNode && a.parentNode.removeChild(a) } } }, nodeFactory: function (e, t) { var n = OpenLayers.Util.getElement(e); return n ? this.nodeTypeCompare(n, t) || (n.parentNode.removeChild(n), n = this.nodeFactory(e, t)) : n = this.createNode(t, e), n }, nodeTypeCompare: function (e, t) { }, createNode: function (e, t) { }, moveRoot: function (e) { var t = this.root; e.root.parentNode == this.rendererRoot && (t = e.root), t.parentNode.removeChild(t), e.rendererRoot.appendChild(t) }, getRenderLayerId: function () { return this.root.parentNode.parentNode.id }, isComplexSymbol: function (e) { return "circle" != e && !!e }, CLASS_NAME: "OpenLayers.Renderer.Elements" }), OpenLayers.Control = OpenLayers.Class({ id: null, map: null, div: null, type: null, allowSelection: !1, displayClass: "", title: "", autoActivate: !1, active: null, handlerOptions: null, handler: null, eventListeners: null, events: null, initialize: function (e) { this.displayClass = this.CLASS_NAME.replace("OpenLayers.", "ol").replace(/\./g, ""), OpenLayers.Util.extend(this, e), this.events = new OpenLayers.Events(this), this.eventListeners instanceof Object && this.events.on(this.eventListeners), null == this.id && (this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_")) }, destroy: function () { if (this.events && (this.eventListeners && this.events.un(this.eventListeners), this.events.destroy(), this.events = null), this.eventListeners = null, this.handler && (this.handler.destroy(), this.handler = null), this.handlers) { for (var e in this.handlers) this.handlers.hasOwnProperty(e) && "function" == typeof this.handlers[e].destroy && this.handlers[e].destroy(); this.handlers = null } this.map && (this.map.removeControl(this), this.map = null), this.div = null }, setMap: function (e) { this.map = e, this.handler && this.handler.setMap(e) }, draw: function (e) { return null == this.div && (this.div = OpenLayers.Util.createDiv(this.id), this.div.className = this.displayClass, this.allowSelection || (this.div.className += " olControlNoSelect", this.div.setAttribute("unselectable", "on", 0), this.div.onselectstart = OpenLayers.Function.False), "" != this.title && (this.div.title = this.title)), null != e && (this.position = e.clone()), this.moveTo(this.position), this.div }, moveTo: function (e) { null != e && null != this.div && (this.div.style.left = e.x + "px", this.div.style.top = e.y + "px") }, activate: function () { return !this.active && (this.handler && this.handler.activate(), this.active = !0, this.map && OpenLayers.Element.addClass(this.map.viewPortDiv, this.displayClass.replace(/ /g, "") + "Active"), this.events.triggerEvent("activate"), !0) }, deactivate: function () { return !!this.active && (this.handler && this.handler.deactivate(), this.active = !1, this.map && OpenLayers.Element.removeClass(this.map.viewPortDiv, this.displayClass.replace(/ /g, "") + "Active"), this.events.triggerEvent("deactivate"), !0) }, CLASS_NAME: "OpenLayers.Control" }), OpenLayers.Control.TYPE_BUTTON = 1, OpenLayers.Control.TYPE_TOGGLE = 2, OpenLayers.Control.TYPE_TOOL = 3, OpenLayers.Control.Panel = OpenLayers.Class(OpenLayers.Control, { controls: null, autoActivate: !0, defaultControl: null, saveState: !1, allowDepress: !1, activeState: null, initialize: function (e) { OpenLayers.Control.prototype.initialize.apply(this, [e]), this.controls = [], this.activeState = {} }, destroy: function () { this.map && this.map.events.unregister("buttonclick", this, this.onButtonClick), OpenLayers.Control.prototype.destroy.apply(this, arguments); for (var e, t = this.controls.length - 1; t >= 0; t--)(e = this.controls[t]).events && e.events.un({ activate: this.iconOn, deactivate: this.iconOff }), e.panel_div = null; this.activeState = null }, activate: function () { if (OpenLayers.Control.prototype.activate.apply(this, arguments)) { for (var e, t = 0, n = this.controls.length; t < n; t++)((e = this.controls[t]) === this.defaultControl || this.saveState && this.activeState[e.id]) && e.activate(); return !0 === this.saveState && (this.defaultControl = null), this.redraw(), !0 } return !1 }, deactivate: function () { if (OpenLayers.Control.prototype.deactivate.apply(this, arguments)) { for (var e, t = 0, n = this.controls.length; t < n; t++)e = this.controls[t], this.activeState[e.id] = e.deactivate(); return this.redraw(), !0 } return !1 }, draw: function () { return OpenLayers.Control.prototype.draw.apply(this, arguments), this.outsideViewport ? (this.events.attachToElement(this.div), this.events.register("buttonclick", this, this.onButtonClick)) : this.map.events.register("buttonclick", this, this.onButtonClick), this.addControlsToMap(this.controls), this.div }, redraw: function () { for (var e = this.div.childNodes.length - 1; e >= 0; e--)this.div.removeChild(this.div.childNodes[e]); if (this.div.innerHTML = "", this.active) { e = 0; for (var t = this.controls.length; e < t; e++)this.div.appendChild(this.controls[e].panel_div) } }, activateControl: function (e) { if (!this.active) return !1; if (e.type != OpenLayers.Control.TYPE_BUTTON) if (e.type != OpenLayers.Control.TYPE_TOGGLE) if (this.allowDepress && e.active) e.deactivate(); else { for (var t, n = 0, i = this.controls.length; n < i; n++)(t = this.controls[n]) == e || t.type !== OpenLayers.Control.TYPE_TOOL && null != t.type || t.deactivate(); e.activate() } else e.active ? e.deactivate() : e.activate(); else e.trigger() }, addControls: function (e) { OpenLayers.Util.isArray(e) || (e = [e]), this.controls = this.controls.concat(e); for (var t = 0, n = e.length; t < n; t++) { var i = e[t], s = this.createControlMarkup(i); OpenLayers.Element.addClass(s, i.displayClass + "ItemInactive"), OpenLayers.Element.addClass(s, "olButton"), "" == i.title || s.title || (s.title = i.title), i.panel_div = s } this.map && (this.addControlsToMap(e), this.redraw()) }, createControlMarkup: function (e) { return document.createElement("div") }, addControlsToMap: function (e) { for (var t, n = 0, i = e.length; n < i; n++)!0 === (t = e[n]).autoActivate ? (t.autoActivate = !1, this.map.addControl(t), t.autoActivate = !0) : (this.map.addControl(t), t.deactivate()), t.events.on({ activate: this.iconOn, deactivate: this.iconOff }) }, iconOn: function () { var e = this.panel_div, t = new RegExp("\\b(" + this.displayClass + "Item)Inactive\\b"); e.className = e.className.replace(t, "$1Active") }, iconOff: function () { var e = this.panel_div, t = new RegExp("\\b(" + this.displayClass + "Item)Active\\b"); e.className = e.className.replace(t, "$1Inactive") }, onButtonClick: function (e) { for (var t = this.controls, n = e.buttonElement, i = t.length - 1; i >= 0; --i)if (t[i].panel_div === n) { this.activateControl(t[i]); break } }, getControlsBy: function (e, t) { var n = "function" == typeof t.test; return OpenLayers.Array.filter(this.controls, function (i) { return i[e] == t || n && t.test(i[e]) }) }, getControlsByName: function (e) { return this.getControlsBy("name", e) }, getControlsByClass: function (e) { return this.getControlsBy("CLASS_NAME", e) }, CLASS_NAME: "OpenLayers.Control.Panel" }), OpenLayers.Strategy = OpenLayers.Class({ layer: null, options: null, active: null, autoActivate: !0, autoDestroy: !0, initialize: function (e) { OpenLayers.Util.extend(this, e), this.options = e, this.active = !1 }, destroy: function () { this.deactivate(), this.layer = null, this.options = null }, setLayer: function (e) { this.layer = e }, activate: function () { return !this.active && (this.active = !0, !0) }, deactivate: function () { return !!this.active && (this.active = !1, !0) }, CLASS_NAME: "OpenLayers.Strategy" }), OpenLayers.Strategy.Fixed = OpenLayers.Class(OpenLayers.Strategy, { preload: !1, activate: function () { var e = OpenLayers.Strategy.prototype.activate.apply(this, arguments); return e && (this.layer.events.on({ refresh: this.load, scope: this }), 1 == this.layer.visibility || this.preload ? this.load() : this.layer.events.on({ visibilitychanged: this.load, scope: this })), e }, deactivate: function () { var e = OpenLayers.Strategy.prototype.deactivate.call(this); return e && this.layer.events.un({ refresh: this.load, visibilitychanged: this.load, scope: this }), e }, load: function (e) { var t = this.layer; t.events.triggerEvent("loadstart", { filter: t.filter }), t.protocol.read(OpenLayers.Util.applyDefaults({ callback: this.merge, filter: t.filter, scope: this }, e)), t.events.un({ visibilitychanged: this.load, scope: this }) }, merge: function (e) { var t = this.layer; t.destroyFeatures(); var n = e.features; if (n && n.length > 0) { var i = t.projection, s = t.map.getProjectionObject(); if (!s.equals(i)) for (var r, a = 0, o = n.length; a < o; ++a)(r = n[a].geometry) && r.transform(i, s); t.addFeatures(n) } t.events.triggerEvent("loadend", { response: e }) }, CLASS_NAME: "OpenLayers.Strategy.Fixed" }), OpenLayers.Control.Zoom = OpenLayers.Class(OpenLayers.Control, { zoomInText: "+", zoomInId: "olZoomInLink", zoomOutText: "−", zoomOutId: "olZoomOutLink", draw: function () { var e = OpenLayers.Control.prototype.draw.apply(this), t = this.getOrCreateLinks(e), n = t.zoomIn, i = t.zoomOut, s = this.map.events; return i.parentNode !== e && (s = this.events).attachToElement(i.parentNode), s.register("buttonclick", this, this.onZoomClick), this.zoomInLink = n, this.zoomOutLink = i, e }, getOrCreateLinks: function (e) { var t = document.getElementById(this.zoomInId), n = document.getElementById(this.zoomOutId); return t || ((t = document.createElement("a")).href = "#zoomIn", t.appendChild(document.createTextNode(this.zoomInText)), t.className = "olControlZoomIn", e.appendChild(t)), OpenLayers.Element.addClass(t, "olButton"), n || ((n = document.createElement("a")).href = "#zoomOut", n.appendChild(document.createTextNode(this.zoomOutText)), n.className = "olControlZoomOut", e.appendChild(n)), OpenLayers.Element.addClass(n, "olButton"), { zoomIn: t, zoomOut: n } }, onZoomClick: function (e) { var t = e.buttonElement; t === this.zoomInLink ? this.map.zoomIn() : t === this.zoomOutLink && this.map.zoomOut() }, destroy: function () { this.map && this.map.events.unregister("buttonclick", this, this.onZoomClick), delete this.zoomInLink, delete this.zoomOutLink, OpenLayers.Control.prototype.destroy.apply(this) }, CLASS_NAME: "OpenLayers.Control.Zoom" }), OpenLayers.Geometry.Polygon = OpenLayers.Class(OpenLayers.Geometry.Collection, { componentTypes: ["OpenLayers.Geometry.LinearRing"], getArea: function () { var e = 0; if (this.components && this.components.length > 0) { e += Math.abs(this.components[0].getArea()); for (var t = 1, n = this.components.length; t < n; t++)e -= Math.abs(this.components[t].getArea()) } return e }, getGeodesicArea: function (e) { var t = 0; if (this.components && this.components.length > 0) { t += Math.abs(this.components[0].getGeodesicArea(e)); for (var n = 1, i = this.components.length; n < i; n++)t -= Math.abs(this.components[n].getGeodesicArea(e)) } return t }, containsPoint: function (e) { var t = this.components.length, n = !1; if (t > 0 && 1 !== (n = this.components[0].containsPoint(e)) && n && t > 1) for (var i, s = 1; s < t; ++s)if (i = this.components[s].containsPoint(e)) { n = 1 === i && 1; break } return n }, intersects: function (e) { var t, n, i = !1; if ("OpenLayers.Geometry.Point" == e.CLASS_NAME) i = this.containsPoint(e); else if ("OpenLayers.Geometry.LineString" == e.CLASS_NAME || "OpenLayers.Geometry.LinearRing" == e.CLASS_NAME) { for (t = 0, n = this.components.length; t < n && !(i = e.intersects(this.components[t])); ++t); if (!i) for (t = 0, n = e.components.length; t < n && !(i = this.containsPoint(e.components[t])); ++t); } else for (t = 0, n = e.components.length; t < n && !(i = this.intersects(e.components[t])); ++t); if (!i && "OpenLayers.Geometry.Polygon" == e.CLASS_NAME) { var s = this.components[0]; for (t = 0, n = s.components.length; t < n && !(i = e.containsPoint(s.components[t])); ++t); } return i }, distanceTo: function (e, t) { return !!(t && !1 === t.edge) && this.intersects(e) ? 0 : OpenLayers.Geometry.Collection.prototype.distanceTo.apply(this, [e, t]) }, CLASS_NAME: "OpenLayers.Geometry.Polygon" }), OpenLayers.Geometry.Polygon.createRegularPolygon = function (e, t, n, i) { var s, r, a, o = Math.PI * (1 / n - .5); i && (o += i / 180 * Math.PI); for (var l = [], h = 0; h < n; ++h)s = o + 2 * h * Math.PI / n, r = e.x + t * Math.cos(s), a = e.y + t * Math.sin(s), l.push(new OpenLayers.Geometry.Point(r, a)); var p = new OpenLayers.Geometry.LinearRing(l); return new OpenLayers.Geometry.Polygon([p]) }, OpenLayers.Geometry.MultiPolygon = OpenLayers.Class(OpenLayers.Geometry.Collection, { componentTypes: ["OpenLayers.Geometry.Polygon"], CLASS_NAME: "OpenLayers.Geometry.MultiPolygon" }), OpenLayers.Feature = OpenLayers.Class({ layer: null, id: null, lonlat: null, data: null, marker: null, popupClass: null, popup: null, initialize: function (e, t, n) { this.layer = e, this.lonlat = t, this.data = null != n ? n : {}, this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_") }, destroy: function () { null != this.layer && null != this.layer.map && null != this.popup && this.layer.map.removePopup(this.popup), null != this.layer && null != this.marker && this.layer.removeMarker(this.marker), this.layer = null, this.id = null, this.lonlat = null, this.data = null, null != this.marker && (this.destroyMarker(this.marker), this.marker = null), null != this.popup && (this.destroyPopup(this.popup), this.popup = null) }, onScreen: function () { var e = !1; null != this.layer && null != this.layer.map && (e = this.layer.map.getExtent().containsLonLat(this.lonlat)); return e }, createMarker: function () { return null != this.lonlat && (this.marker = new OpenLayers.Marker(this.lonlat, this.data.icon)), this.marker }, destroyMarker: function () { this.marker.destroy() }, createPopup: function (e) { if (null != this.lonlat) { if (!this.popup) { var t = this.marker ? this.marker.icon : null, n = this.popupClass ? this.popupClass : OpenLayers.Popup.Anchored; this.popup = new n(this.id + "_popup", this.lonlat, this.data.popupSize, this.data.popupContentHTML, t, e) } null != this.data.overflow && (this.popup.contentDiv.style.overflow = this.data.overflow), this.popup.feature = this } return this.popup }, destroyPopup: function () { this.popup && (this.popup.feature = null, this.popup.destroy(), this.popup = null) }, CLASS_NAME: "OpenLayers.Feature" }), OpenLayers.State = { UNKNOWN: "Unknown", INSERT: "Insert", UPDATE: "Update", DELETE: "Delete" }, OpenLayers.Feature.Vector = OpenLayers.Class(OpenLayers.Feature, { fid: null, geometry: null, attributes: null, bounds: null, state: null, style: null, url: null, renderIntent: "default", modified: null, initialize: function (e, t, n) { OpenLayers.Feature.prototype.initialize.apply(this, [null, null, t]), this.lonlat = null, this.geometry = e || null, this.state = null, this.attributes = {}, t && (this.attributes = OpenLayers.Util.extend(this.attributes, t)), this.style = n || null }, destroy: function () { this.layer && (this.layer.removeFeatures(this), this.layer = null), this.geometry = null, this.modified = null, OpenLayers.Feature.prototype.destroy.apply(this, arguments) }, clone: function () { return new OpenLayers.Feature.Vector(this.geometry ? this.geometry.clone() : null, this.attributes, this.style) }, onScreen: function (e) { var t = !1; if (this.layer && this.layer.map) { var n = this.layer.map.getExtent(); if (e) { var i = this.geometry.getBounds(); t = n.intersectsBounds(i) } else { t = n.toGeometry().intersects(this.geometry) } } return t }, getVisibility: function () { return !(this.style && "none" == this.style.display || !this.layer || this.layer && this.layer.styleMap && "none" == this.layer.styleMap.createSymbolizer(this, this.renderIntent).display || this.layer && !this.layer.getVisibility()) }, createMarker: function () { return null }, destroyMarker: function () { }, createPopup: function () { return null }, atPoint: function (e, t, n) { var i = !1; return this.geometry && (i = this.geometry.atPoint(e, t, n)), i }, destroyPopup: function () { }, move: function (e) { if (this.layer && this.geometry.move) { var t; t = "OpenLayers.LonLat" == e.CLASS_NAME ? this.layer.getViewPortPxFromLonLat(e) : e; var n = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat()), i = this.layer.map.getResolution(); return this.geometry.move(i * (t.x - n.x), i * (n.y - t.y)), this.layer.drawFeature(this), n } }, toState: function (e) { if (e == OpenLayers.State.UPDATE) switch (this.state) { case OpenLayers.State.UNKNOWN: case OpenLayers.State.DELETE: this.state = e; break; case OpenLayers.State.UPDATE: case OpenLayers.State.INSERT: } else if (e == OpenLayers.State.INSERT) switch (this.state) { case OpenLayers.State.UNKNOWN: break; default: this.state = e } else if (e == OpenLayers.State.DELETE) switch (this.state) { case OpenLayers.State.INSERT: case OpenLayers.State.DELETE: break; case OpenLayers.State.UNKNOWN: case OpenLayers.State.UPDATE: this.state = e } else e == OpenLayers.State.UNKNOWN && (this.state = e) }, CLASS_NAME: "OpenLayers.Feature.Vector" }), OpenLayers.Feature.Vector.style = { default: { fillColor: "#ee9900", fillOpacity: .4, hoverFillColor: "white", hoverFillOpacity: .8, strokeColor: "#ee9900", strokeOpacity: 1, strokeWidth: 1, strokeLinecap: "round", strokeDashstyle: "solid", hoverStrokeColor: "red", hoverStrokeOpacity: 1, hoverStrokeWidth: .2, pointRadius: 6, hoverPointRadius: 1, hoverPointUnit: "%", pointerEvents: "visiblePainted", cursor: "inherit", fontColor: "#000000", labelAlign: "cm", labelOutlineColor: "white", labelOutlineWidth: 3 }, select: { fillColor: "blue", fillOpacity: .4, hoverFillColor: "white", hoverFillOpacity: .8, strokeColor: "blue", strokeOpacity: 1, strokeWidth: 2, strokeLinecap: "round", strokeDashstyle: "solid", hoverStrokeColor: "red", hoverStrokeOpacity: 1, hoverStrokeWidth: .2, pointRadius: 6, hoverPointRadius: 1, hoverPointUnit: "%", pointerEvents: "visiblePainted", cursor: "pointer", fontColor: "#000000", labelAlign: "cm", labelOutlineColor: "white", labelOutlineWidth: 3 }, temporary: { fillColor: "#66cccc", fillOpacity: .2, hoverFillColor: "white", hoverFillOpacity: .8, strokeColor: "#66cccc", strokeOpacity: 1, strokeLinecap: "round", strokeWidth: 2, strokeDashstyle: "solid", hoverStrokeColor: "red", hoverStrokeOpacity: 1, hoverStrokeWidth: .2, pointRadius: 6, hoverPointRadius: 1, hoverPointUnit: "%", pointerEvents: "visiblePainted", cursor: "inherit", fontColor: "#000000", labelAlign: "cm", labelOutlineColor: "white", labelOutlineWidth: 3 }, delete: { display: "none" } }, OpenLayers.Style = OpenLayers.Class({ id: null, name: null, title: null, description: null, layerName: null, isDefault: !1, rules: null, context: null, defaultStyle: null, defaultsPerSymbolizer: !1, propertyStyles: null, initialize: function (e, t) { OpenLayers.Util.extend(this, t), this.rules = [], t && t.rules && this.addRules(t.rules), this.setDefaultStyle(e || OpenLayers.Feature.Vector.style.default), this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_") }, destroy: function () { for (var e = 0, t = this.rules.length; e < t; e++)this.rules[e].destroy(), this.rules[e] = null; this.rules = null, this.defaultStyle = null }, createSymbolizer: function (e) { for (var t, n = this.defaultsPerSymbolizer ? {} : this.createLiterals(OpenLayers.Util.extend({}, this.defaultStyle), e), i = this.rules, s = [], r = !1, a = 0, o = i.length; a < o; a++) { (t = i[a]).evaluate(e) && (t instanceof OpenLayers.Rule && t.elseFilter ? s.push(t) : (r = !0, this.applySymbolizer(t, n, e))) } if (0 == r && s.length > 0) { r = !0; for (a = 0, o = s.length; a < o; a++)this.applySymbolizer(s[a], n, e) } return i.length > 0 && 0 == r && (n.display = "none"), null != n.label && "string" != typeof n.label && (n.label = String(n.label)), n }, applySymbolizer: function (e, t, n) { var i = n.geometry ? this.getSymbolizerPrefix(n.geometry) : OpenLayers.Style.SYMBOLIZER_PREFIXES[0], s = e.symbolizer[i] || e.symbolizer; if (!0 === this.defaultsPerSymbolizer) { var r = this.defaultStyle; OpenLayers.Util.applyDefaults(s, { pointRadius: r.pointRadius }), !0 !== s.stroke && !0 !== s.graphic || OpenLayers.Util.applyDefaults(s, { strokeWidth: r.strokeWidth, strokeColor: r.strokeColor, strokeOpacity: r.strokeOpacity, strokeDashstyle: r.strokeDashstyle, strokeLinecap: r.strokeLinecap }), !0 !== s.fill && !0 !== s.graphic || OpenLayers.Util.applyDefaults(s, { fillColor: r.fillColor, fillOpacity: r.fillOpacity }), !0 === s.graphic && OpenLayers.Util.applyDefaults(s, { pointRadius: this.defaultStyle.pointRadius, externalGraphic: this.defaultStyle.externalGraphic, graphicName: this.defaultStyle.graphicName, graphicOpacity: this.defaultStyle.graphicOpacity, graphicWidth: this.defaultStyle.graphicWidth, graphicHeight: this.defaultStyle.graphicHeight, graphicXOffset: this.defaultStyle.graphicXOffset, graphicYOffset: this.defaultStyle.graphicYOffset }) } return this.createLiterals(OpenLayers.Util.extend(t, s), n) }, createLiterals: function (e, t) { var n = OpenLayers.Util.extend({}, t.attributes || t.data); for (var i in OpenLayers.Util.extend(n, this.context), this.propertyStyles) e[i] = OpenLayers.Style.createLiteral(e[i], n, t, i); return e }, findPropertyStyles: function () { var e = {}, t = this.defaultStyle; this.addPropertyStyles(e, t); for (var n, i, s = this.rules, r = 0, a = s.length; r < a; r++)for (var o in n = s[r].symbolizer) { if ("object" != typeof (i = n[o])) { this.addPropertyStyles(e, n); break } this.addPropertyStyles(e, i) } return e }, addPropertyStyles: function (e, t) { var n; for (var i in t) "string" == typeof (n = t[i]) && n.match(/\$\{\w+\}/) && (e[i] = !0); return e }, addRules: function (e) { Array.prototype.push.apply(this.rules, e), this.propertyStyles = this.findPropertyStyles() }, setDefaultStyle: function (e) { this.defaultStyle = e, this.propertyStyles = this.findPropertyStyles() }, getSymbolizerPrefix: function (e) { for (var t = OpenLayers.Style.SYMBOLIZER_PREFIXES, n = 0, i = t.length; n < i; n++)if (-1 != e.CLASS_NAME.indexOf(t[n])) return t[n] }, clone: function () { var e = OpenLayers.Util.extend({}, this); if (this.rules) { e.rules = []; for (var t = 0, n = this.rules.length; t < n; ++t)e.rules.push(this.rules[t].clone()) } e.context = this.context && OpenLayers.Util.extend({}, this.context); var i = OpenLayers.Util.extend({}, this.defaultStyle); return new OpenLayers.Style(i, e) }, CLASS_NAME: "OpenLayers.Style" }), OpenLayers.Style.createLiteral = function (e, t, n, i) { return "string" == typeof e && -1 != e.indexOf("${") && (e = OpenLayers.String.format(e, t, [n, i]), e = isNaN(e) || !e ? e : parseFloat(e)), e }, OpenLayers.Style.SYMBOLIZER_PREFIXES = ["Point", "Line", "Polygon", "Text", "Raster"], OpenLayers.Filter = OpenLayers.Class({ initialize: function (e) { OpenLayers.Util.extend(this, e) }, destroy: function () { }, evaluate: function (e) { return !0 }, clone: function () { return null }, toString: function () { return OpenLayers.Format && OpenLayers.Format.CQL ? OpenLayers.Format.CQL.prototype.write(this) : Object.prototype.toString.call(this) }, CLASS_NAME: "OpenLayers.Filter" }), OpenLayers.Filter.Spatial = OpenLayers.Class(OpenLayers.Filter, { type: null, property: null, value: null, distance: null, distanceUnits: null, evaluate: function (e) { var t = !1; switch (this.type) { case OpenLayers.Filter.Spatial.BBOX: case OpenLayers.Filter.Spatial.INTERSECTS: if (e.geometry) { var n = this.value; "OpenLayers.Bounds" == this.value.CLASS_NAME && (n = this.value.toGeometry()), e.geometry.intersects(n) && (t = !0) } break; default: throw new Error("evaluate is not implemented for this filter type.") }return t }, clone: function () { var e = OpenLayers.Util.applyDefaults({ value: this.value && this.value.clone && this.value.clone() }, this); return new OpenLayers.Filter.Spatial(e) }, CLASS_NAME: "OpenLayers.Filter.Spatial" }), OpenLayers.Filter.Spatial.BBOX = "BBOX", OpenLayers.Filter.Spatial.INTERSECTS = "INTERSECTS", OpenLayers.Filter.Spatial.DWITHIN = "DWITHIN", OpenLayers.Filter.Spatial.WITHIN = "WITHIN", OpenLayers.Filter.Spatial.CONTAINS = "CONTAINS", OpenLayers.Strategy.BBOX = OpenLayers.Class(OpenLayers.Strategy, { bounds: null, resolution: null, ratio: 2, resFactor: null, response: null, activate: function () { var e = OpenLayers.Strategy.prototype.activate.call(this); return e && (this.layer.events.on({ moveend: this.update, refresh: this.update, visibilitychanged: this.update, scope: this }), this.update()), e }, deactivate: function () { var e = OpenLayers.Strategy.prototype.deactivate.call(this); return e && this.layer.events.un({ moveend: this.update, refresh: this.update, visibilitychanged: this.update, scope: this }), e }, update: function (e) { var t = this.getMapBounds(); null !== t && (e && e.force || this.layer.visibility && this.layer.calculateInRange() && this.invalidBounds(t)) && (this.calculateBounds(t), this.resolution = this.layer.map.getResolution(), this.triggerRead(e)) }, getMapBounds: function () { if (null === this.layer.map) return null; var e = this.layer.map.getExtent(); return e && !this.layer.projection.equals(this.layer.map.getProjectionObject()) && (e = e.clone().transform(this.layer.map.getProjectionObject(), this.layer.projection)), e }, invalidBounds: function (e) { e || (e = this.getMapBounds()); var t = !this.bounds || !this.bounds.containsBounds(e); if (!t && this.resFactor) { var n = this.resolution / this.layer.map.getResolution(); t = n >= this.resFactor || n <= 1 / this.resFactor } return t }, calculateBounds: function (e) { e || (e = this.getMapBounds()); var t = e.getCenterLonLat(), n = e.getWidth() * this.ratio, i = e.getHeight() * this.ratio; this.bounds = new OpenLayers.Bounds(t.lon - n / 2, t.lat - i / 2, t.lon + n / 2, t.lat + i / 2) }, triggerRead: function (e) { !this.response || e && !0 === e.noAbort || (this.layer.protocol.abort(this.response), this.layer.events.triggerEvent("loadend")); var t = { filter: this.createFilter() }; this.layer.events.triggerEvent("loadstart", t), this.response = this.layer.protocol.read(OpenLayers.Util.applyDefaults({ filter: t.filter, callback: this.merge, scope: this }, e)) }, createFilter: function () { var e = new OpenLayers.Filter.Spatial({ type: OpenLayers.Filter.Spatial.BBOX, value: this.bounds, projection: this.layer.projection }); return this.layer.filter && (e = new OpenLayers.Filter.Logical({ type: OpenLayers.Filter.Logical.AND, filters: [this.layer.filter, e] })), e }, merge: function (e) { if (this.layer.destroyFeatures(), e.success()) { var t = e.features; if (t && t.length > 0) { var n = this.layer.projection, i = this.layer.map.getProjectionObject(); if (!i.equals(n)) for (var s, r = 0, a = t.length; r < a; ++r)(s = t[r].geometry) && s.transform(n, i); this.layer.addFeatures(t) } } else this.bounds = null; this.response = null, this.layer.events.triggerEvent("loadend", { response: e }) }, CLASS_NAME: "OpenLayers.Strategy.BBOX" }), OpenLayers.Handler.Feature = OpenLayers.Class(OpenLayers.Handler, { EVENTMAP: { click: { in: "click", out: "clickout" }, mousemove: { in: "over", out: "out" }, dblclick: { in: "dblclick", out: null }, mousedown: { in: null, out: null }, mouseup: { in: null, out: null }, touchstart: { in: "click", out: "clickout" } }, feature: null, lastFeature: null, down: null, up: null, clickTolerance: 4, geometryTypes: null, stopClick: !0, stopDown: !0, stopUp: !1, initialize: function (e, t, n, i) { OpenLayers.Handler.prototype.initialize.apply(this, [e, n, i]), this.layer = t }, touchstart: function (e) { return this.startTouch(), !!OpenLayers.Event.isMultiTouch(e) || this.mousedown(e) }, touchmove: function (e) { OpenLayers.Event.preventDefault(e) }, mousedown: function (e) { return (OpenLayers.Event.isLeftClick(e) || OpenLayers.Event.isSingleTouch(e)) && (this.down = e.xy), !this.handle(e) || !this.stopDown }, mouseup: function (e) { return this.up = e.xy, !this.handle(e) || !this.stopUp }, click: function (e) { return !this.handle(e) || !this.stopClick }, mousemove: function (e) { return !this.callbacks.over && !this.callbacks.out || (this.handle(e), !0) }, dblclick: function (e) { return !this.handle(e) }, geometryTypeMatches: function (e) { return null == this.geometryTypes || OpenLayers.Util.indexOf(this.geometryTypes, e.geometry.CLASS_NAME) > -1 }, handle: function (e) { this.feature && !this.feature.layer && (this.feature = null); var t = e.type, n = !1, i = !!this.feature, s = "click" == t || "dblclick" == t || "touchstart" == t; if (this.feature = this.layer.getFeatureFromEvent(e), this.feature && !this.feature.layer && (this.feature = null), this.lastFeature && !this.lastFeature.layer && (this.lastFeature = null), this.feature) { "touchstart" === t && OpenLayers.Event.preventDefault(e); var r = this.feature != this.lastFeature; this.geometryTypeMatches(this.feature) ? (i && r ? (this.lastFeature && this.triggerCallback(t, "out", [this.lastFeature]), this.triggerCallback(t, "in", [this.feature])) : i && !s || this.triggerCallback(t, "in", [this.feature]), this.lastFeature = this.feature, n = !0) : (this.lastFeature && (i && r || s) && this.triggerCallback(t, "out", [this.lastFeature]), this.feature = null) } else this.lastFeature && (i || s) && this.triggerCallback(t, "out", [this.lastFeature]); return n }, triggerCallback: function (e, t, n) { var i = this.EVENTMAP[e][t]; i && ("click" == e && this.up && this.down ? (Math.sqrt(Math.pow(this.up.x - this.down.x, 2) + Math.pow(this.up.y - this.down.y, 2)) <= this.clickTolerance && this.callback(i, n), this.up = this.down = null) : this.callback(i, n)) }, activate: function () { var e = !1; return OpenLayers.Handler.prototype.activate.apply(this, arguments) && (this.moveLayerToTop(), this.map.events.on({ removelayer: this.handleMapEvents, changelayer: this.handleMapEvents, scope: this }), e = !0), e }, deactivate: function () { var e = !1; return OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.moveLayerBack(), this.feature = null, this.lastFeature = null, this.down = null, this.up = null, this.map.events.un({ removelayer: this.handleMapEvents, changelayer: this.handleMapEvents, scope: this }), e = !0), e }, handleMapEvents: function (e) { "removelayer" != e.type && "order" != e.property || this.moveLayerToTop() }, moveLayerToTop: function () { var e = Math.max(this.map.Z_INDEX_BASE.Feature - 1, this.layer.getZIndex()) + 1; this.layer.setZIndex(e) }, moveLayerBack: function () { var e = this.layer.getZIndex() - 1; e >= this.map.Z_INDEX_BASE.Feature ? this.layer.setZIndex(e) : this.map.setLayerZIndex(this.layer, this.map.getLayerIndex(this.layer)) }, CLASS_NAME: "OpenLayers.Handler.Feature" }), OpenLayers.StyleMap = OpenLayers.Class({ styles: null, extendDefault: !0, initialize: function (e, t) { if (this.styles = { default: new OpenLayers.Style(OpenLayers.Feature.Vector.style.default), select: new OpenLayers.Style(OpenLayers.Feature.Vector.style.select), temporary: new OpenLayers.Style(OpenLayers.Feature.Vector.style.temporary), delete: new OpenLayers.Style(OpenLayers.Feature.Vector.style.delete) }, e instanceof OpenLayers.Style) this.styles.default = e, this.styles.select = e, this.styles.temporary = e, this.styles.delete = e; else if ("object" == typeof e) for (var n in e) if (e[n] instanceof OpenLayers.Style) this.styles[n] = e[n]; else { if ("object" != typeof e[n]) { this.styles.default = new OpenLayers.Style(e), this.styles.select = new OpenLayers.Style(e), this.styles.temporary = new OpenLayers.Style(e), this.styles.delete = new OpenLayers.Style(e); break } this.styles[n] = new OpenLayers.Style(e[n]) } OpenLayers.Util.extend(this, t) }, destroy: function () { for (var e in this.styles) this.styles[e].destroy(); this.styles = null }, createSymbolizer: function (e, t) { e || (e = new OpenLayers.Feature.Vector), this.styles[t] || (t = "default"), e.renderIntent = t; var n = {}; return this.extendDefault && "default" != t && (n = this.styles.default.createSymbolizer(e)), OpenLayers.Util.extend(n, this.styles[t].createSymbolizer(e)) }, addUniqueValueRules: function (e, t, n, i) { var s = []; for (var r in n) s.push(new OpenLayers.Rule({ symbolizer: n[r], context: i, filter: new OpenLayers.Filter.Comparison({ type: OpenLayers.Filter.Comparison.EQUAL_TO, property: t, value: r }) })); this.styles[e].addRules(s) }, CLASS_NAME: "OpenLayers.StyleMap" }), OpenLayers.Layer.Vector = OpenLayers.Class(OpenLayers.Layer, { isBaseLayer: !1, isFixed: !1, features: null, filter: null, selectedFeatures: null, unrenderedFeatures: null, reportError: !0, style: null, styleMap: null, strategies: null, protocol: null, renderers: ["SVG", "VML", "Canvas"], renderer: null, rendererOptions: null, geometryType: null, drawn: !1, ratio: 1, initialize: function (e, t) { if (OpenLayers.Layer.prototype.initialize.apply(this, arguments), this.renderer && this.renderer.supported() || this.assignRenderer(), this.renderer && this.renderer.supported() || (this.renderer = null, this.displayError()), this.styleMap || (this.styleMap = new OpenLayers.StyleMap), this.features = [], this.selectedFeatures = [], this.unrenderedFeatures = {}, this.strategies) for (var n = 0, i = this.strategies.length; n < i; n++)this.strategies[n].setLayer(this) }, destroy: function () { if (this.strategies) { var e, t, n; for (t = 0, n = this.strategies.length; t < n; t++)(e = this.strategies[t]).autoDestroy && e.destroy(); this.strategies = null } this.protocol && (this.protocol.autoDestroy && this.protocol.destroy(), this.protocol = null), this.destroyFeatures(), this.features = null, this.selectedFeatures = null, this.unrenderedFeatures = null, this.renderer && this.renderer.destroy(), this.renderer = null, this.geometryType = null, this.drawn = null, OpenLayers.Layer.prototype.destroy.apply(this, arguments) }, clone: function (e) { null == e && (e = new OpenLayers.Layer.Vector(this.name, this.getOptions())), e = OpenLayers.Layer.prototype.clone.apply(this, [e]); for (var t = this.features, n = t.length, i = new Array(n), s = 0; s < n; ++s)i[s] = t[s].clone(); return e.features = i, e }, refresh: function (e) { this.calculateInRange() && this.visibility && this.events.triggerEvent("refresh", e) }, assignRenderer: function () { for (var e = 0, t = this.renderers.length; e < t; e++) { var n = this.renderers[e], i = "function" == typeof n ? n : OpenLayers.Renderer[n]; if (i && i.prototype.supported()) { this.renderer = new i(this.div, this.rendererOptions); break } } }, displayError: function () { this.reportError && OpenLayers.Console.userError(OpenLayers.i18n("browserNotSupported", { renderers: this.renderers.join("\n") })) }, setMap: function (e) { if (OpenLayers.Layer.prototype.setMap.apply(this, arguments), this.renderer) { this.renderer.map = this.map; var t = this.map.getSize(); t.w = t.w * this.ratio, t.h = t.h * this.ratio, this.renderer.setSize(t) } else this.map.removeLayer(this) }, afterAdd: function () { var e, t, n; if (this.strategies) for (t = 0, n = this.strategies.length; t < n; t++)(e = this.strategies[t]).autoActivate && e.activate() }, removeMap: function (e) { var t, n, i; if (this.drawn = !1, this.strategies) for (n = 0, i = this.strategies.length; n < i; n++)(t = this.strategies[n]).autoActivate && t.deactivate() }, onMapResize: function () { OpenLayers.Layer.prototype.onMapResize.apply(this, arguments); var e = this.map.getSize(); e.w = e.w * this.ratio, e.h = e.h * this.ratio, this.renderer.setSize(e) }, moveTo: function (e, t, n) { OpenLayers.Layer.prototype.moveTo.apply(this, arguments); var i = !0; if (!n) { this.renderer.root.style.visibility = "hidden"; var s = this.map.getSize(), r = s.w, a = s.h, o = r / 2 * this.ratio - r / 2, l = a / 2 * this.ratio - a / 2; o += this.map.layerContainerOriginPx.x, o = -Math.round(o), l += this.map.layerContainerOriginPx.y, l = -Math.round(l), this.div.style.left = o + "px", this.div.style.top = l + "px"; var h = this.map.getExtent().scale(this.ratio); if (i = this.renderer.setExtent(h, t), this.renderer.root.style.visibility = "visible", !0 === OpenLayers.IS_GECKO && (this.div.scrollLeft = this.div.scrollLeft), !t && i) for (var p in this.unrenderedFeatures) { var u = this.unrenderedFeatures[p]; this.drawFeature(u) } } if (!this.drawn || t || !i) { this.drawn = !0; p = 0; for (var y = this.features.length; p < y; p++)this.renderer.locked = p !== y - 1, u = this.features[p], this.drawFeature(u) } }, display: function (e) { OpenLayers.Layer.prototype.display.apply(this, arguments); var t = this.div.style.display; t != this.renderer.root.style.display && (this.renderer.root.style.display = t) }, addFeatures: function (e, t) { OpenLayers.Util.isArray(e) || (e = [e]); var n = !t || !t.silent; if (n) { var i = { features: e }; if (!1 === this.events.triggerEvent("beforefeaturesadded", i)) return; e = i.features } for (var s = [], r = 0, a = e.length; r < a; r++) { r != e.length - 1 ? this.renderer.locked = !0 : this.renderer.locked = !1; var o = e[r]; if (this.geometryType && !(o.geometry instanceof this.geometryType)) throw new TypeError("addFeatures: component should be an " + this.geometryType.prototype.CLASS_NAME); if (o.layer = this, !o.style && this.style && (o.style = OpenLayers.Util.extend({}, this.style)), n) { if (!1 === this.events.triggerEvent("beforefeatureadded", { feature: o })) continue; this.preFeatureInsert(o) } s.push(o), this.features.push(o), this.drawFeature(o), n && (this.events.triggerEvent("featureadded", { feature: o }), this.onFeatureInsert(o)) } n && this.events.triggerEvent("featuresadded", { features: s }) }, removeFeatures: function (e, t) { if (e && 0 !== e.length) { if (e === this.features) return this.removeAllFeatures(t); OpenLayers.Util.isArray(e) || (e = [e]), e === this.selectedFeatures && (e = e.slice()); var n = !t || !t.silent; n && this.events.triggerEvent("beforefeaturesremoved", { features: e }); for (var i = e.length - 1; i >= 0; i--) { 0 != i && e[i - 1].geometry ? this.renderer.locked = !0 : this.renderer.locked = !1; var s = e[i]; delete this.unrenderedFeatures[s.id], n && this.events.triggerEvent("beforefeatureremoved", { feature: s }), this.features = OpenLayers.Util.removeItem(this.features, s), s.layer = null, s.geometry && this.renderer.eraseFeatures(s), -1 != OpenLayers.Util.indexOf(this.selectedFeatures, s) && OpenLayers.Util.removeItem(this.selectedFeatures, s), n && this.events.triggerEvent("featureremoved", { feature: s }) } n && this.events.triggerEvent("featuresremoved", { features: e }) } }, removeAllFeatures: function (e) { var t, n = !e || !e.silent, i = this.features; n && this.events.triggerEvent("beforefeaturesremoved", { features: i }); for (var s = i.length - 1; s >= 0; s--)t = i[s], n && this.events.triggerEvent("beforefeatureremoved", { feature: t }), t.layer = null, n && this.events.triggerEvent("featureremoved", { feature: t }); this.renderer.clear(), this.features = [], this.unrenderedFeatures = {}, this.selectedFeatures = [], n && this.events.triggerEvent("featuresremoved", { features: i }) }, destroyFeatures: function (e, t) { if (null == e && (e = this.features), e) { this.removeFeatures(e, t); for (var n = e.length - 1; n >= 0; n--)e[n].destroy() } }, drawFeature: function (e, t) { if (this.drawn) { if ("object" != typeof t) { t || e.state !== OpenLayers.State.DELETE || (t = "delete"); var n = t || e.renderIntent; (t = e.style || this.style) || (t = this.styleMap.createSymbolizer(e, n)) } var i = this.renderer.drawFeature(e, t); !1 === i || null === i ? this.unrenderedFeatures[e.id] = e : delete this.unrenderedFeatures[e.id] } }, eraseFeatures: function (e) { this.renderer.eraseFeatures(e) }, getFeatureFromEvent: function (e) { if (!this.renderer) throw new Error("getFeatureFromEvent called on layer with no renderer. This usually means you destroyed a layer, but not some handler which is associated with it."); var t = null, n = this.renderer.getFeatureIdFromEvent(e); return n && (t = "string" == typeof n ? this.getFeatureById(n) : n), t }, getFeatureBy: function (e, t) { for (var n = null, i = 0, s = this.features.length; i < s; ++i)if (this.features[i][e] == t) { n = this.features[i]; break } return n }, getFeatureById: function (e) { return this.getFeatureBy("id", e) }, getFeatureByFid: function (e) { return this.getFeatureBy("fid", e) }, getFeaturesByAttribute: function (e, t) { var n, i, s = this.features.length, r = []; for (n = 0; n < s; n++)(i = this.features[n]) && i.attributes && i.attributes[e] === t && r.push(i); return r }, onFeatureInsert: function (e) { }, preFeatureInsert: function (e) { }, getDataExtent: function () { var e = null, t = this.features; if (t && t.length > 0) for (var n = null, i = 0, s = t.length; i < s; i++)(n = t[i].geometry) && (null === e && (e = new OpenLayers.Bounds), e.extend(n.getBounds())); return e }, CLASS_NAME: "OpenLayers.Layer.Vector" }), OpenLayers.Layer.Vector.RootContainer = OpenLayers.Class(OpenLayers.Layer.Vector, { displayInLayerSwitcher: !1, layers: null, display: function () { }, getFeatureFromEvent: function (e) { for (var t, n = this.layers, i = 0; i < n.length; i++)if (t = n[i].getFeatureFromEvent(e)) return t }, setMap: function (e) { OpenLayers.Layer.Vector.prototype.setMap.apply(this, arguments), this.collectRoots(), e.events.register("changelayer", this, this.handleChangeLayer) }, removeMap: function (e) { e.events.unregister("changelayer", this, this.handleChangeLayer), this.resetRoots(), OpenLayers.Layer.Vector.prototype.removeMap.apply(this, arguments) }, collectRoots: function () { for (var e, t = 0; t < this.map.layers.length; ++t)e = this.map.layers[t], -1 != OpenLayers.Util.indexOf(this.layers, e) && e.renderer.moveRoot(this.renderer) }, resetRoots: function () { for (var e, t = 0; t < this.layers.length; ++t)e = this.layers[t], this.renderer && e.renderer.getRenderLayerId() == this.id && this.renderer.moveRoot(e.renderer) }, handleChangeLayer: function (e) { var t = e.layer; "order" == e.property && -1 != OpenLayers.Util.indexOf(this.layers, t) && (this.resetRoots(), this.collectRoots()) }, CLASS_NAME: "OpenLayers.Layer.Vector.RootContainer" }), OpenLayers.Control.SelectFeature = OpenLayers.Class(OpenLayers.Control, { multipleKey: null, toggleKey: null, multiple: !1, clickout: !0, toggle: !1, hover: !1, highlightOnly: !1, box: !1, onBeforeSelect: function () { }, onSelect: function () { }, onUnselect: function () { }, scope: null, geometryTypes: null, layer: null, layers: null, callbacks: null, selectStyle: null, renderIntent: "select", handlers: null, initialize: function (e, t) { OpenLayers.Control.prototype.initialize.apply(this, [t]), null === this.scope && (this.scope = this), this.initLayer(e); var n = { click: this.clickFeature, clickout: this.clickoutFeature }; this.hover && (n.over = this.overFeature, n.out = this.outFeature), this.callbacks = OpenLayers.Util.extend(n, this.callbacks), this.handlers = { feature: new OpenLayers.Handler.Feature(this, this.layer, this.callbacks, { geometryTypes: this.geometryTypes }) }, this.box && (this.handlers.box = new OpenLayers.Handler.Box(this, { done: this.selectBox }, { boxDivClassName: "olHandlerBoxSelectFeature" })) }, initLayer: function (e) { OpenLayers.Util.isArray(e) ? (this.layers = e, this.layer = new OpenLayers.Layer.Vector.RootContainer(this.id + "_container", { layers: e })) : this.layer = e }, destroy: function () { this.active && this.layers && this.map.removeLayer(this.layer), OpenLayers.Control.prototype.destroy.apply(this, arguments), this.layers && this.layer.destroy() }, activate: function () { return this.active || (this.layers && this.map.addLayer(this.layer), this.handlers.feature.activate(), this.box && this.handlers.box && this.handlers.box.activate()), OpenLayers.Control.prototype.activate.apply(this, arguments) }, deactivate: function () { return this.active && (this.handlers.feature.deactivate(), this.handlers.box && this.handlers.box.deactivate(), this.layers && this.map.removeLayer(this.layer)), OpenLayers.Control.prototype.deactivate.apply(this, arguments) }, unselectAll: function (e) { var t, n, i, s, r = this.layers || [this.layer]; for (i = 0; i < r.length; ++i)if (s = 0, null != (t = r[i]).selectedFeatures) for (; t.selectedFeatures.length > s;)n = t.selectedFeatures[s], e && e.except == n ? ++s : this.unselect(n) }, clickFeature: function (e) { this.hover || (OpenLayers.Util.indexOf(e.layer.selectedFeatures, e) > -1 ? this.toggleSelect() ? this.unselect(e) : this.multipleSelect() || this.unselectAll({ except: e }) : (this.multipleSelect() || this.unselectAll({ except: e }), this.select(e))) }, multipleSelect: function () { return this.multiple || this.handlers.feature.evt && this.handlers.feature.evt[this.multipleKey] }, toggleSelect: function () { return this.toggle || this.handlers.feature.evt && this.handlers.feature.evt[this.toggleKey] }, clickoutFeature: function (e) { !this.hover && this.clickout && this.unselectAll() }, overFeature: function (e) { var t = e.layer; this.hover && (this.highlightOnly ? this.highlight(e) : -1 == OpenLayers.Util.indexOf(t.selectedFeatures, e) && this.select(e)) }, outFeature: function (e) { if (this.hover) if (this.highlightOnly) { if (e._lastHighlighter == this.id) if (e._prevHighlighter && e._prevHighlighter != this.id) { delete e._lastHighlighter; var t = this.map.getControl(e._prevHighlighter); t && t.highlight(e) } else this.unhighlight(e) } else this.unselect(e) }, highlight: function (e) { var t = e.layer; if (!1 !== this.events.triggerEvent("beforefeaturehighlighted", { feature: e })) { e._prevHighlighter = e._lastHighlighter, e._lastHighlighter = this.id; var n = this.selectStyle || this.renderIntent; t.drawFeature(e, n), this.events.triggerEvent("featurehighlighted", { feature: e }) } }, unhighlight: function (e) { var t = e.layer; null == e._prevHighlighter ? delete e._lastHighlighter : e._prevHighlighter == this.id ? delete e._prevHighlighter : (e._lastHighlighter = e._prevHighlighter, delete e._prevHighlighter), t.drawFeature(e, e.style || e.layer.style || "default"), this.events.triggerEvent("featureunhighlighted", { feature: e }) }, select: function (e) { var t = this.onBeforeSelect.call(this.scope, e), n = e.layer; !1 !== t && !1 !== (t = n.events.triggerEvent("beforefeatureselected", { feature: e })) && (n.selectedFeatures.push(e), this.highlight(e), this.handlers.feature.lastFeature || (this.handlers.feature.lastFeature = n.selectedFeatures[0]), n.events.triggerEvent("featureselected", { feature: e }), this.onSelect.call(this.scope, e)) }, unselect: function (e) { var t = e.layer; this.unhighlight(e), OpenLayers.Util.removeItem(t.selectedFeatures, e), t.events.triggerEvent("featureunselected", { feature: e }), this.onUnselect.call(this.scope, e) }, selectBox: function (e) { if (e instanceof OpenLayers.Bounds) { var t = this.map.getLonLatFromPixel({ x: e.left, y: e.bottom }), n = this.map.getLonLatFromPixel({ x: e.right, y: e.top }), i = new OpenLayers.Bounds(t.lon, t.lat, n.lon, n.lat); this.multipleSelect() || this.unselectAll(); var s = this.multiple; this.multiple = !0; var r, a = this.layers || [this.layer]; this.events.triggerEvent("boxselectionstart", { layers: a }); for (var o = 0; o < a.length; ++o)for (var l = 0, h = (r = a[o]).features.length; l < h; ++l) { var p = r.features[l]; p.getVisibility() && ((null == this.geometryTypes || OpenLayers.Util.indexOf(this.geometryTypes, p.geometry.CLASS_NAME) > -1) && i.toGeometry().intersects(p.geometry) && -1 == OpenLayers.Util.indexOf(r.selectedFeatures, p) && this.select(p)) } this.multiple = s, this.events.triggerEvent("boxselectionend", { layers: a }) } }, setMap: function (e) { this.handlers.feature.setMap(e), this.box && this.handlers.box.setMap(e), OpenLayers.Control.prototype.setMap.apply(this, arguments) }, setLayer: function (e) { var t = this.active; this.unselectAll(), this.deactivate(), this.layers && (this.layer.destroy(), this.layers = null), this.initLayer(e), this.handlers.feature.layer = this.layer, t && this.activate() }, CLASS_NAME: "OpenLayers.Control.SelectFeature" }), OpenLayers.Control.Attribution = OpenLayers.Class(OpenLayers.Control, { separator: ", ", template: "${layers}", destroy: function () { this.map.events.un({ removelayer: this.updateAttribution, addlayer: this.updateAttribution, changelayer: this.updateAttribution, changebaselayer: this.updateAttribution, scope: this }), OpenLayers.Control.prototype.destroy.apply(this, arguments) }, draw: function () { return OpenLayers.Control.prototype.draw.apply(this, arguments), this.map.events.on({ changebaselayer: this.updateAttribution, changelayer: this.updateAttribution, addlayer: this.updateAttribution, removelayer: this.updateAttribution, scope: this }), this.updateAttribution(), this.div }, updateAttribution: function () { var e = []; if (this.map && this.map.layers) { for (var t = 0, n = this.map.layers.length; t < n; t++) { var i = this.map.layers[t]; i.attribution && i.getVisibility() && -1 === OpenLayers.Util.indexOf(e, i.attribution) && e.push(i.attribution) } this.div.innerHTML = OpenLayers.String.format(this.template, { layers: e.join(this.separator) }) } }, CLASS_NAME: "OpenLayers.Control.Attribution" }), OpenLayers.Kinetic = OpenLayers.Class({ threshold: 0, deceleration: .0035, nbPoints: 100, delay: 200, points: void 0, timerId: void 0, initialize: function (e) { OpenLayers.Util.extend(this, e) }, begin: function () { OpenLayers.Animation.stop(this.timerId), this.timerId = void 0, this.points = [] }, update: function (e) { this.points.unshift({ xy: e, tick: (new Date).getTime() }), this.points.length > this.nbPoints && this.points.pop() }, end: function (e) { for (var t, n, i = (new Date).getTime(), s = 0, r = this.points.length; s < r && !(i - (n = this.points[s]).tick > this.delay); s++)t = n; if (t) { var a = (new Date).getTime() - t.tick, o = Math.sqrt(Math.pow(e.x - t.xy.x, 2) + Math.pow(e.y - t.xy.y, 2)), l = o / a; if (!(0 == l || l < this.threshold)) { var h = Math.asin((e.y - t.xy.y) / o); return t.xy.x <= e.x && (h = Math.PI - h), { speed: l, theta: h } } } }, move: function (e, t) { var n = e.speed, i = Math.cos(e.theta), s = -Math.sin(e.theta), r = (new Date).getTime(), a = 0, o = 0; this.timerId = OpenLayers.Animation.start(OpenLayers.Function.bind(function () { if (null != this.timerId) { var e = (new Date).getTime() - r, l = -this.deceleration * Math.pow(e, 2) / 2 + n * e, h = l * i, p = l * s, u = { end: !1 }; -this.deceleration * e + n <= 0 && (OpenLayers.Animation.stop(this.timerId), this.timerId = null, u.end = !0), u.x = h - a, u.y = p - o, a = h, o = p, t(u.x, u.y, u.end) } }, this)) }, CLASS_NAME: "OpenLayers.Kinetic" }), OpenLayers.Filter.Logical = OpenLayers.Class(OpenLayers.Filter, { filters: null, type: null, initialize: function (e) { this.filters = [], OpenLayers.Filter.prototype.initialize.apply(this, [e]) }, destroy: function () { this.filters = null, OpenLayers.Filter.prototype.destroy.apply(this) }, evaluate: function (e) { var t, n; switch (this.type) { case OpenLayers.Filter.Logical.AND: for (t = 0, n = this.filters.length; t < n; t++)if (0 == this.filters[t].evaluate(e)) return !1; return !0; case OpenLayers.Filter.Logical.OR: for (t = 0, n = this.filters.length; t < n; t++)if (1 == this.filters[t].evaluate(e)) return !0; return !1; case OpenLayers.Filter.Logical.NOT: return !this.filters[0].evaluate(e) } }, clone: function () { for (var e = [], t = 0, n = this.filters.length; t < n; ++t)e.push(this.filters[t].clone()); return new OpenLayers.Filter.Logical({ type: this.type, filters: e }) }, CLASS_NAME: "OpenLayers.Filter.Logical" }), OpenLayers.Filter.Logical.AND = "&&", OpenLayers.Filter.Logical.OR = "||", OpenLayers.Filter.Logical.NOT = "!", OpenLayers.Handler.Drag = OpenLayers.Class(OpenLayers.Handler, { started: !1, stopDown: !0, dragging: !1, last: null, start: null, lastMoveEvt: null, oldOnselectstart: null, interval: 0, timeoutId: null, documentDrag: !1, documentEvents: null, initialize: function (e, t, n) { if (OpenLayers.Handler.prototype.initialize.apply(this, arguments), !0 === this.documentDrag) { var i = this; this._docMove = function (e) { i.mousemove({ xy: { x: e.clientX, y: e.clientY }, element: document }) }, this._docUp = function (e) { i.mouseup({ xy: { x: e.clientX, y: e.clientY } }) } } }, dragstart: function (e) { var t = !0; return this.dragging = !1, this.checkModifiers(e) && (OpenLayers.Event.isLeftClick(e) || OpenLayers.Event.isSingleTouch(e)) ? (this.started = !0, this.start = e.xy, this.last = e.xy, OpenLayers.Element.addClass(this.map.viewPortDiv, "olDragDown"), this.down(e), this.callback("down", [e.xy]), OpenLayers.Event.preventDefault(e), this.oldOnselectstart || (this.oldOnselectstart = document.onselectstart ? document.onselectstart : OpenLayers.Function.True), document.onselectstart = OpenLayers.Function.False, t = !this.stopDown) : (this.started = !1, this.start = null, this.last = null), t }, dragmove: function (e) { return this.lastMoveEvt = e, !this.started || this.timeoutId || e.xy.x == this.last.x && e.xy.y == this.last.y || (!0 === this.documentDrag && this.documentEvents && (e.element === document ? (this.adjustXY(e), this.setEvent(e)) : this.removeDocumentEvents()), this.interval > 0 && (this.timeoutId = setTimeout(OpenLayers.Function.bind(this.removeTimeout, this), this.interval)), this.dragging = !0, this.move(e), this.callback("move", [e.xy]), this.oldOnselectstart || (this.oldOnselectstart = document.onselectstart, document.onselectstart = OpenLayers.Function.False), this.last = e.xy), !0 }, dragend: function (e) { if (this.started) { !0 === this.documentDrag && this.documentEvents && (this.adjustXY(e), this.removeDocumentEvents()); var t = this.start != this.last; this.started = !1, this.dragging = !1, OpenLayers.Element.removeClass(this.map.viewPortDiv, "olDragDown"), this.up(e), this.callback("up", [e.xy]), t && this.callback("done", [e.xy]), document.onselectstart = this.oldOnselectstart } return !0 }, down: function (e) { }, move: function (e) { }, up: function (e) { }, out: function (e) { }, mousedown: function (e) { return this.dragstart(e) }, touchstart: function (e) { return this.startTouch(), this.dragstart(e) }, mousemove: function (e) { return this.dragmove(e) }, touchmove: function (e) { return this.dragmove(e) }, removeTimeout: function () { this.timeoutId = null, this.dragging && this.mousemove(this.lastMoveEvt) }, mouseup: function (e) { return this.dragend(e) }, touchend: function (e) { return e.xy = this.last, this.dragend(e) }, mouseout: function (e) { if (this.started && OpenLayers.Util.mouseLeft(e, this.map.viewPortDiv)) if (!0 === this.documentDrag) this.addDocumentEvents(); else { var t = this.start != this.last; this.started = !1, this.dragging = !1, OpenLayers.Element.removeClass(this.map.viewPortDiv, "olDragDown"), this.out(e), this.callback("out", []), t && this.callback("done", [e.xy]), document.onselectstart && (document.onselectstart = this.oldOnselectstart) } return !0 }, click: function (e) { return this.start == this.last }, activate: function () { var e = !1; return OpenLayers.Handler.prototype.activate.apply(this, arguments) && (this.dragging = !1, e = !0), e }, deactivate: function () { var e = !1; return OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.started = !1, this.dragging = !1, this.start = null, this.last = null, e = !0, OpenLayers.Element.removeClass(this.map.viewPortDiv, "olDragDown")), e }, adjustXY: function (e) { var t = OpenLayers.Util.pagePosition(this.map.viewPortDiv); e.xy.x -= t[0], e.xy.y -= t[1] }, addDocumentEvents: function () { OpenLayers.Element.addClass(document.body, "olDragDown"), this.documentEvents = !0, OpenLayers.Event.observe(document, "mousemove", this._docMove), OpenLayers.Event.observe(document, "mouseup", this._docUp) }, removeDocumentEvents: function () { OpenLayers.Element.removeClass(document.body, "olDragDown"), this.documentEvents = !1, OpenLayers.Event.stopObserving(document, "mousemove", this._docMove), OpenLayers.Event.stopObserving(document, "mouseup", this._docUp) }, CLASS_NAME: "OpenLayers.Handler.Drag" }), OpenLayers.Handler.Box = OpenLayers.Class(OpenLayers.Handler, { dragHandler: null, boxDivClassName: "olHandlerBoxZoomBox", boxOffsets: null, initialize: function (e, t, n) { OpenLayers.Handler.prototype.initialize.apply(this, arguments), this.dragHandler = new OpenLayers.Handler.Drag(this, { down: this.startBox, move: this.moveBox, out: this.removeBox, up: this.endBox }, { keyMask: this.keyMask }) }, destroy: function () { OpenLayers.Handler.prototype.destroy.apply(this, arguments), this.dragHandler && (this.dragHandler.destroy(), this.dragHandler = null) }, setMap: function (e) { OpenLayers.Handler.prototype.setMap.apply(this, arguments), this.dragHandler && this.dragHandler.setMap(e) }, startBox: function (e) { this.callback("start", []), this.zoomBox = OpenLayers.Util.createDiv("zoomBox", { x: -9999, y: -9999 }), this.zoomBox.className = this.boxDivClassName, this.zoomBox.style.zIndex = this.map.Z_INDEX_BASE.Popup - 1, this.map.viewPortDiv.appendChild(this.zoomBox), OpenLayers.Element.addClass(this.map.viewPortDiv, "olDrawBox") }, moveBox: function (e) { var t = this.dragHandler.start.x, n = this.dragHandler.start.y, i = Math.abs(t - e.x), s = Math.abs(n - e.y), r = this.getBoxOffsets(); this.zoomBox.style.width = i + r.width + 1 + "px", this.zoomBox.style.height = s + r.height + 1 + "px", this.zoomBox.style.left = (e.x < t ? t - i - r.left : t - r.left) + "px", this.zoomBox.style.top = (e.y < n ? n - s - r.top : n - r.top) + "px" }, endBox: function (e) { var t; if (Math.abs(this.dragHandler.start.x - e.x) > 5 || Math.abs(this.dragHandler.start.y - e.y) > 5) { var n = this.dragHandler.start, i = Math.min(n.y, e.y), s = Math.max(n.y, e.y), r = Math.min(n.x, e.x), a = Math.max(n.x, e.x); t = new OpenLayers.Bounds(r, s, a, i) } else t = this.dragHandler.start.clone(); this.removeBox(), this.callback("done", [t]) }, removeBox: function () { this.map.viewPortDiv.removeChild(this.zoomBox), this.zoomBox = null, this.boxOffsets = null, OpenLayers.Element.removeClass(this.map.viewPortDiv, "olDrawBox") }, activate: function () { return !!OpenLayers.Handler.prototype.activate.apply(this, arguments) && (this.dragHandler.activate(), !0) }, deactivate: function () { return !!OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.dragHandler.deactivate() && this.zoomBox && this.removeBox(), !0) }, getBoxOffsets: function () { if (!this.boxOffsets) { var e = document.createElement("div"); e.style.position = "absolute", e.style.border = "1px solid black", e.style.width = "3px", document.body.appendChild(e); var t = 3 == e.clientWidth; document.body.removeChild(e); var n = parseInt(OpenLayers.Element.getStyle(this.zoomBox, "border-left-width")), i = parseInt(OpenLayers.Element.getStyle(this.zoomBox, "border-right-width")), s = parseInt(OpenLayers.Element.getStyle(this.zoomBox, "border-top-width")), r = parseInt(OpenLayers.Element.getStyle(this.zoomBox, "border-bottom-width")); this.boxOffsets = { left: n, right: i, top: s, bottom: r, width: !1 === t ? n + i : 0, height: !1 === t ? s + r : 0 } } return this.boxOffsets }, CLASS_NAME: "OpenLayers.Handler.Box" }), OpenLayers.Control.ZoomBox = OpenLayers.Class(OpenLayers.Control, { type: OpenLayers.Control.TYPE_TOOL, out: !1, keyMask: null, alwaysZoom: !1, zoomOnClick: !0, draw: function () { this.handler = new OpenLayers.Handler.Box(this, { done: this.zoomBox }, { keyMask: this.keyMask }) }, zoomBox: function (e) { if (e instanceof OpenLayers.Bounds) { var t, n = e.getCenterPixel(); if (this.out) { var i = e.right - e.left, s = e.bottom - e.top, r = Math.min(this.map.size.h / s, this.map.size.w / i), a = this.map.getExtent(), o = this.map.getLonLatFromPixel(n), l = o.lon - a.getWidth() / 2 * r, h = o.lon + a.getWidth() / 2 * r, p = o.lat - a.getHeight() / 2 * r, u = o.lat + a.getHeight() / 2 * r; t = new OpenLayers.Bounds(l, p, h, u) } else { var y = this.map.getLonLatFromPixel({ x: e.left, y: e.bottom }), c = this.map.getLonLatFromPixel({ x: e.right, y: e.top }); t = new OpenLayers.Bounds(y.lon, y.lat, c.lon, c.lat) } var d = this.map.getZoom(), f = this.map.getSize(), m = { x: f.w / 2, y: f.h / 2 }, g = this.map.getZoomForExtent(t), L = this.map.getResolution(), v = this.map.getResolutionForZoom(g); if (L == v) this.map.setCenter(this.map.getLonLatFromPixel(n)); else { var O = { x: (L * n.x - v * m.x) / (L - v), y: (L * n.y - v * m.y) / (L - v) }; this.map.zoomTo(g, O) } d == this.map.getZoom() && 1 == this.alwaysZoom && this.map.zoomTo(d + (this.out ? -1 : 1)) } else this.zoomOnClick && (this.out ? this.map.zoomTo(this.map.getZoom() - 1, e) : this.map.zoomTo(this.map.getZoom() + 1, e)) }, CLASS_NAME: "OpenLayers.Control.ZoomBox" }), OpenLayers.Control.DragPan = OpenLayers.Class(OpenLayers.Control, { type: OpenLayers.Control.TYPE_TOOL, panned: !1, interval: 0, documentDrag: !1, kinetic: null, enableKinetic: !0, kineticInterval: 10, draw: function () { if (this.enableKinetic && OpenLayers.Kinetic) { var e = { interval: this.kineticInterval }; "object" == typeof this.enableKinetic && (e = OpenLayers.Util.extend(e, this.enableKinetic)), this.kinetic = new OpenLayers.Kinetic(e) } this.handler = new OpenLayers.Handler.Drag(this, { move: this.panMap, done: this.panMapDone, down: this.panMapStart }, { interval: this.interval, documentDrag: this.documentDrag }) }, panMapStart: function () { this.kinetic && this.kinetic.begin() }, panMap: function (e) { this.kinetic && this.kinetic.update(e), this.panned = !0, this.map.pan(this.handler.last.x - e.x, this.handler.last.y - e.y, { dragging: !0, animate: !1 }) }, panMapDone: function (e) { if (this.panned) { var t = null; if (this.kinetic && (t = this.kinetic.end(e)), this.map.pan(this.handler.last.x - e.x, this.handler.last.y - e.y, { dragging: !!t, animate: !1 }), t) { var n = this; this.kinetic.move(t, function (e, t, i) { n.map.pan(e, t, { dragging: !i, animate: !1 }) }) } this.panned = !1 } }, CLASS_NAME: "OpenLayers.Control.DragPan" }), OpenLayers.Handler.Click = OpenLayers.Class(OpenLayers.Handler, { delay: 300, single: !0, double: !1, pixelTolerance: 0, dblclickTolerance: 13, stopSingle: !1, stopDouble: !1, timerId: null, down: null, last: null, first: null, rightclickTimerId: null, touchstart: function (e) { return this.startTouch(), this.down = this.getEventInfo(e), this.last = this.getEventInfo(e), !0 }, touchmove: function (e) { return this.last = this.getEventInfo(e), !0 }, touchend: function (e) { return this.down && (e.xy = this.last.xy, e.lastTouches = this.last.touches, this.handleSingle(e), this.down = null), !0 }, mousedown: function (e) { return this.down = this.getEventInfo(e), this.last = this.getEventInfo(e), !0 }, mouseup: function (e) { var t = !0; return this.checkModifiers(e) && this.control.handleRightClicks && OpenLayers.Event.isRightClick(e) && (t = this.rightclick(e)), t }, rightclick: function (e) { if (this.passesTolerance(e)) { if (null != this.rightclickTimerId) return this.clearTimer(), this.callback("dblrightclick", [e]), !this.stopDouble; var t = this.double ? OpenLayers.Util.extend({}, e) : this.callback("rightclick", [e]), n = OpenLayers.Function.bind(this.delayedRightCall, this, t); this.rightclickTimerId = window.setTimeout(n, this.delay) } return !this.stopSingle }, delayedRightCall: function (e) { this.rightclickTimerId = null, e && this.callback("rightclick", [e]) }, click: function (e) { return this.last || (this.last = this.getEventInfo(e)), this.handleSingle(e), !this.stopSingle }, dblclick: function (e) { return this.handleDouble(e), !this.stopDouble }, handleDouble: function (e) { this.passesDblclickTolerance(e) && (this.double && this.callback("dblclick", [e]), this.clearTimer()) }, handleSingle: function (e) { if (this.passesTolerance(e)) if (null != this.timerId) this.last.touches && 1 === this.last.touches.length && (this.double && OpenLayers.Event.preventDefault(e), this.handleDouble(e)), this.last.touches && 2 === this.last.touches.length || this.clearTimer(); else { this.first = this.getEventInfo(e); var t = this.single ? OpenLayers.Util.extend({}, e) : null; this.queuePotentialClick(t) } }, queuePotentialClick: function (e) { this.timerId = window.setTimeout(OpenLayers.Function.bind(this.delayedCall, this, e), this.delay) }, passesTolerance: function (e) { var t = !0; if (null != this.pixelTolerance && this.down && this.down.xy && (t = this.pixelTolerance >= this.down.xy.distanceTo(e.xy)) && this.touch && this.down.touches.length === this.last.touches.length) for (var n = 0, i = this.down.touches.length; n < i; ++n)if (this.getTouchDistance(this.down.touches[n], this.last.touches[n]) > this.pixelTolerance) { t = !1; break } return t }, getTouchDistance: function (e, t) { return Math.sqrt(Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)) }, passesDblclickTolerance: function (e) { var t = !0; return this.down && this.first && (t = this.down.xy.distanceTo(this.first.xy) <= this.dblclickTolerance), t }, clearTimer: function () { null != this.timerId && (window.clearTimeout(this.timerId), this.timerId = null), null != this.rightclickTimerId && (window.clearTimeout(this.rightclickTimerId), this.rightclickTimerId = null) }, delayedCall: function (e) { this.timerId = null, e && this.callback("click", [e]) }, getEventInfo: function (e) { var t; if (e.touches) { var n, i = e.touches.length; t = new Array(i); for (var s = 0; s < i; s++)n = e.touches[s], t[s] = { clientX: n.olClientX, clientY: n.olClientY } } return { xy: e.xy, touches: t } }, deactivate: function () { var e = !1; return OpenLayers.Handler.prototype.deactivate.apply(this, arguments) && (this.clearTimer(), this.down = null, this.first = null, this.last = null, e = !0), e }, CLASS_NAME: "OpenLayers.Handler.Click" }), OpenLayers.Control.Navigation = OpenLayers.Class(OpenLayers.Control, { dragPan: null, dragPanOptions: null, pinchZoom: null, pinchZoomOptions: null, documentDrag: !1, zoomBox: null, zoomBoxEnabled: !0, zoomWheelEnabled: !0, mouseWheelOptions: null, handleRightClicks: !1, zoomBoxKeyMask: OpenLayers.Handler.MOD_SHIFT, autoActivate: !0, initialize: function (e) { this.handlers = {}, OpenLayers.Control.prototype.initialize.apply(this, arguments) }, destroy: function () { this.deactivate(), this.dragPan && this.dragPan.destroy(), this.dragPan = null, this.zoomBox && this.zoomBox.destroy(), this.zoomBox = null, this.pinchZoom && this.pinchZoom.destroy(), this.pinchZoom = null, OpenLayers.Control.prototype.destroy.apply(this, arguments) }, activate: function () { return this.dragPan.activate(), this.zoomWheelEnabled && this.handlers.wheel.activate(), this.handlers.click.activate(), this.zoomBoxEnabled && this.zoomBox.activate(), this.pinchZoom && this.pinchZoom.activate(), OpenLayers.Control.prototype.activate.apply(this, arguments) }, deactivate: function () { return this.pinchZoom && this.pinchZoom.deactivate(), this.zoomBox.deactivate(), this.dragPan.deactivate(), this.handlers.click.deactivate(), this.handlers.wheel.deactivate(), OpenLayers.Control.prototype.deactivate.apply(this, arguments) }, draw: function () { this.handleRightClicks && (this.map.viewPortDiv.oncontextmenu = OpenLayers.Function.False); var e = { click: this.defaultClick, dblclick: this.defaultDblClick, dblrightclick: this.defaultDblRightClick }; this.handlers.click = new OpenLayers.Handler.Click(this, e, { double: !0, stopDouble: !0 }), this.dragPan = new OpenLayers.Control.DragPan(OpenLayers.Util.extend({ map: this.map, documentDrag: this.documentDrag }, this.dragPanOptions)), this.zoomBox = new OpenLayers.Control.ZoomBox({ map: this.map, keyMask: this.zoomBoxKeyMask }), this.dragPan.draw(), this.zoomBox.draw(); var t = this.map.fractionalZoom ? {} : { cumulative: !1, interval: 50, maxDelta: 6 }; this.handlers.wheel = new OpenLayers.Handler.MouseWheel(this, { up: this.wheelUp, down: this.wheelDown }, OpenLayers.Util.extend(t, this.mouseWheelOptions)), OpenLayers.Control.PinchZoom && (this.pinchZoom = new OpenLayers.Control.PinchZoom(OpenLayers.Util.extend({ map: this.map }, this.pinchZoomOptions))) }, defaultClick: function (e) { e.lastTouches && 2 == e.lastTouches.length && this.map.zoomOut() }, defaultDblClick: function (e) { this.map.zoomTo(this.map.zoom + 1, e.xy) }, defaultDblRightClick: function (e) { this.map.zoomTo(this.map.zoom - 1, e.xy) }, wheelChange: function (e, t) { this.map.fractionalZoom || (t = Math.round(t)); var n = this.map.getZoom(), i = n + t; i = Math.max(i, 0), (i = Math.min(i, this.map.getNumZoomLevels())) !== n && this.map.zoomTo(i, e.xy) }, wheelUp: function (e, t) { this.wheelChange(e, t || 1) }, wheelDown: function (e, t) { this.wheelChange(e, t || -1) }, disableZoomBox: function () { this.zoomBoxEnabled = !1, this.zoomBox.deactivate() }, enableZoomBox: function () { this.zoomBoxEnabled = !0, this.active && this.zoomBox.activate() }, disableZoomWheel: function () { this.zoomWheelEnabled = !1, this.handlers.wheel.deactivate() }, enableZoomWheel: function () { this.zoomWheelEnabled = !0, this.active && this.handlers.wheel.activate() }, CLASS_NAME: "OpenLayers.Control.Navigation" }), OpenLayers.Layer.WMS = OpenLayers.Class(OpenLayers.Layer.Grid, { DEFAULT_PARAMS: { service: "WMS", version: "1.1.1", request: "GetMap", styles: "", format: "image/jpeg" }, isBaseLayer: !0, encodeBBOX: !1, noMagic: !1, yx: {}, initialize: function (e, t, n, i) { var s = []; n = OpenLayers.Util.upperCaseObject(n), parseFloat(n.VERSION) >= 1.3 && !n.EXCEPTIONS && (n.EXCEPTIONS = "INIMAGE"), s.push(e, t, n, i), OpenLayers.Layer.Grid.prototype.initialize.apply(this, s), OpenLayers.Util.applyDefaults(this.params, OpenLayers.Util.upperCaseObject(this.DEFAULT_PARAMS)), !this.noMagic && this.params.TRANSPARENT && "true" == this.params.TRANSPARENT.toString().toLowerCase() && (null != i && i.isBaseLayer || (this.isBaseLayer = !1), "image/jpeg" == this.params.FORMAT && (this.params.FORMAT = OpenLayers.Util.alphaHack() ? "image/gif" : "image/png")) }, clone: function (e) { return null == e && (e = new OpenLayers.Layer.WMS(this.name, this.url, this.params, this.getOptions())), e = OpenLayers.Layer.Grid.prototype.clone.apply(this, [e]) }, reverseAxisOrder: function () { var e = this.projection.getCode(); return parseFloat(this.params.VERSION) >= 1.3 && !!(this.yx[e] || OpenLayers.Projection.defaults[e] && OpenLayers.Projection.defaults[e].yx) }, getURL: function (e) { e = this.adjustBounds(e); var t = this.getImageSize(), n = {}, i = this.reverseAxisOrder(); return n.BBOX = this.encodeBBOX ? e.toBBOX(null, i) : e.toArray(i), n.WIDTH = t.w, n.HEIGHT = t.h, this.getFullRequestString(n) }, mergeNewParams: function (e) { var t = [OpenLayers.Util.upperCaseObject(e)]; return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, t) }, getFullRequestString: function (e, t) { var n = this.map.getProjectionObject(), i = this.projection && this.projection.equals(n) ? this.projection.getCode() : n.getCode(), s = "none" == i ? null : i; return parseFloat(this.params.VERSION) >= 1.3 ? this.params.CRS = s : this.params.SRS = s, "boolean" == typeof this.params.TRANSPARENT && (e.TRANSPARENT = this.params.TRANSPARENT ? "TRUE" : "FALSE"), OpenLayers.Layer.Grid.prototype.getFullRequestString.apply(this, arguments) }, CLASS_NAME: "OpenLayers.Layer.WMS" }), OpenLayers.Renderer.SVG = OpenLayers.Class(OpenLayers.Renderer.Elements, { xmlns: "http://www.w3.org/2000/svg", xlinkns: "http://www.w3.org/1999/xlink", MAX_PIXEL: 15e3, translationParameters: null, symbolMetrics: null, initialize: function (e) { this.supported() && (OpenLayers.Renderer.Elements.prototype.initialize.apply(this, arguments), this.translationParameters = { x: 0, y: 0 }, this.symbolMetrics = {}) }, supported: function () { var e = "http://www.w3.org/TR/SVG11/feature#"; return document.implementation && (document.implementation.hasFeature("org.w3c.svg", "1.0") || document.implementation.hasFeature(e + "SVG", "1.1") || document.implementation.hasFeature(e + "BasicStructure", "1.1")) }, inValidRange: function (e, t, n) { var i = e + (n ? 0 : this.translationParameters.x), s = t + (n ? 0 : this.translationParameters.y); return i >= -this.MAX_PIXEL && i <= this.MAX_PIXEL && s >= -this.MAX_PIXEL && s <= this.MAX_PIXEL }, setExtent: function (e, t) { var n = OpenLayers.Renderer.Elements.prototype.setExtent.apply(this, arguments), i = this.getResolution(), s = -e.left / i, r = e.top / i; if (t) { this.left = s, this.top = r; var a = "0 0 " + this.size.w + " " + this.size.h; return this.rendererRoot.setAttributeNS(null, "viewBox", a), this.translate(this.xOffset, 0), !0 } var o = this.translate(s - this.left + this.xOffset, r - this.top); return o || this.setExtent(e, !0), n && o }, translate: function (e, t) { if (this.inValidRange(e, t, !0)) { var n = ""; return (e || t) && (n = "translate(" + e + "," + t + ")"), this.root.setAttributeNS(null, "transform", n), this.translationParameters = { x: e, y: t }, !0 } return !1 }, setSize: function (e) { OpenLayers.Renderer.prototype.setSize.apply(this, arguments), this.rendererRoot.setAttributeNS(null, "width", this.size.w), this.rendererRoot.setAttributeNS(null, "height", this.size.h) }, getNodeType: function (e, t) { var n = null; switch (e.CLASS_NAME) { case "OpenLayers.Geometry.Point": n = t.externalGraphic ? "image" : this.isComplexSymbol(t.graphicName) ? "svg" : "circle"; break; case "OpenLayers.Geometry.Rectangle": n = "rect"; break; case "OpenLayers.Geometry.LineString": n = "polyline"; break; case "OpenLayers.Geometry.LinearRing": n = "polygon"; break; case "OpenLayers.Geometry.Polygon": case "OpenLayers.Geometry.Curve": n = "path" }return n }, setStyle: function (e, t, n) { t = t || e._style, n = n || e._options; var i = t.title || t.graphicTitle; if (i) { e.setAttributeNS(null, "title", i); var s = e.getElementsByTagName("title"); if (s.length > 0) s[0].firstChild.textContent = i; else { var r = this.nodeFactory(null, "title"); r.textContent = i, e.appendChild(r) } } var a, o = parseFloat(e.getAttributeNS(null, "r")), l = 1; if ("OpenLayers.Geometry.Point" == e._geometryClass && o) { if (e.style.visibility = "", !1 === t.graphic) e.style.visibility = "hidden"; else if (t.externalGraphic) { a = this.getPosition(e), t.graphicWidth && t.graphicHeight && e.setAttributeNS(null, "preserveAspectRatio", "none"); var h = t.graphicWidth || t.graphicHeight, p = t.graphicHeight || t.graphicWidth; h = h || 2 * t.pointRadius, p = p || 2 * t.pointRadius; var u = null != t.graphicXOffset ? t.graphicXOffset : -.5 * h, y = null != t.graphicYOffset ? t.graphicYOffset : -.5 * p, c = t.graphicOpacity || t.fillOpacity; e.setAttributeNS(null, "x", (a.x + u).toFixed()), e.setAttributeNS(null, "y", (a.y + y).toFixed()), e.setAttributeNS(null, "width", h), e.setAttributeNS(null, "height", p), e.setAttributeNS(this.xlinkns, "xlink:href", t.externalGraphic), e.setAttributeNS(null, "style", "opacity: " + c), e.onclick = OpenLayers.Event.preventDefault } else if (this.isComplexSymbol(t.graphicName)) { var d = 3 * t.pointRadius, f = 2 * d, m = this.importSymbol(t.graphicName); a = this.getPosition(e), l = 3 * this.symbolMetrics[m.id][0] / f; var g = e.parentNode, L = e.nextSibling; g && g.removeChild(e), e.firstChild && e.removeChild(e.firstChild), e.appendChild(m.firstChild.cloneNode(!0)), e.setAttributeNS(null, "viewBox", m.getAttributeNS(null, "viewBox")), e.setAttributeNS(null, "width", f), e.setAttributeNS(null, "height", f), e.setAttributeNS(null, "x", a.x - d), e.setAttributeNS(null, "y", a.y - d), L ? g.insertBefore(e, L) : g && g.appendChild(e) } else e.setAttributeNS(null, "r", t.pointRadius); var v = t.rotation; if ((void 0 !== v || void 0 !== e._rotation) && a) if (e._rotation = v, v |= 0, "svg" !== e.nodeName) e.setAttributeNS(null, "transform", "rotate(" + v + " " + a.x + " " + a.y + ")"); else { var O = this.symbolMetrics[m.id]; e.firstChild.setAttributeNS(null, "transform", "rotate(" + v + " " + O[1] + " " + O[2] + ")") } } return n.isFilled ? (e.setAttributeNS(null, "fill", t.fillColor), e.setAttributeNS(null, "fill-opacity", t.fillOpacity)) : e.setAttributeNS(null, "fill", "none"), n.isStroked ? (e.setAttributeNS(null, "stroke", t.strokeColor), e.setAttributeNS(null, "stroke-opacity", t.strokeOpacity), e.setAttributeNS(null, "stroke-width", t.strokeWidth * l), e.setAttributeNS(null, "stroke-linecap", t.strokeLinecap || "round"), e.setAttributeNS(null, "stroke-linejoin", "round"), t.strokeDashstyle && e.setAttributeNS(null, "stroke-dasharray", this.dashStyle(t, l))) : e.setAttributeNS(null, "stroke", "none"), t.pointerEvents && e.setAttributeNS(null, "pointer-events", t.pointerEvents), null != t.cursor && e.setAttributeNS(null, "cursor", t.cursor), e }, dashStyle: function (e, t) { var n = e.strokeWidth * t, i = e.strokeDashstyle; switch (i) { case "solid": return "none"; case "dot": return [1, 4 * n].join(); case "dash": return [4 * n, 4 * n].join(); case "dashdot": return [4 * n, 4 * n, 1, 4 * n].join(); case "longdash": return [8 * n, 4 * n].join(); case "longdashdot": return [8 * n, 4 * n, 1, 4 * n].join(); default: return OpenLayers.String.trim(i).replace(/\s+/g, ",") } }, createNode: function (e, t) { var n = document.createElementNS(this.xmlns, e); return t && n.setAttributeNS(null, "id", t), n }, nodeTypeCompare: function (e, t) { return t == e.nodeName }, createRenderRoot: function () { var e = this.nodeFactory(this.container.id + "_svgRoot", "svg"); return e.style.display = "block", e }, createRoot: function (e) { return this.nodeFactory(this.container.id + e, "g") }, createDefs: function () { var e = this.nodeFactory(this.container.id + "_defs", "defs"); return this.rendererRoot.appendChild(e), e }, drawPoint: function (e, t) { return this.drawCircle(e, t, 1) }, drawCircle: function (e, t, n) { var i = this.getResolution(), s = (t.x - this.featureDx) / i + this.left, r = this.top - t.y / i; return !!this.inValidRange(s, r) && (e.setAttributeNS(null, "cx", s), e.setAttributeNS(null, "cy", r), e.setAttributeNS(null, "r", n), e) }, drawLineString: function (e, t) { var n = this.getComponentsString(t.components); return !!n.path && (e.setAttributeNS(null, "points", n.path), n.complete ? e : null) }, drawLinearRing: function (e, t) { var n = this.getComponentsString(t.components); return !!n.path && (e.setAttributeNS(null, "points", n.path), n.complete ? e : null) }, drawPolygon: function (e, t) { for (var n, i, s = "", r = !0, a = !0, o = 0, l = t.components.length; o < l; o++)s += " M", (i = (n = this.getComponentsString(t.components[o].components, " ")).path) ? (s += " " + i, a = n.complete && a) : r = !1; return s += " z", !!r && (e.setAttributeNS(null, "d", s), e.setAttributeNS(null, "fill-rule", "evenodd"), a ? e : null) }, drawRectangle: function (e, t) { var n = this.getResolution(), i = (t.x - this.featureDx) / n + this.left, s = this.top - t.y / n; return !!this.inValidRange(i, s) && (e.setAttributeNS(null, "x", i), e.setAttributeNS(null, "y", s), e.setAttributeNS(null, "width", t.width / n), e.setAttributeNS(null, "height", t.height / n), e) }, drawText: function (e, t, n) { var i = !!t.labelOutlineWidth; if (i) { var s = OpenLayers.Util.extend({}, t); s.fontColor = s.labelOutlineColor, s.fontStrokeColor = s.labelOutlineColor, s.fontStrokeWidth = t.labelOutlineWidth, t.labelOutlineOpacity && (s.fontOpacity = t.labelOutlineOpacity), delete s.labelOutlineWidth, this.drawText(e, s, n) } var r = this.getResolution(), a = (n.x - this.featureDx) / r + this.left, o = n.y / r - this.top, l = i ? this.LABEL_OUTLINE_SUFFIX : this.LABEL_ID_SUFFIX, h = this.nodeFactory(e + l, "text"); h.setAttributeNS(null, "x", a), h.setAttributeNS(null, "y", -o), t.fontColor && h.setAttributeNS(null, "fill", t.fontColor), t.fontStrokeColor && h.setAttributeNS(null, "stroke", t.fontStrokeColor), t.fontStrokeWidth && h.setAttributeNS(null, "stroke-width", t.fontStrokeWidth), t.fontOpacity && h.setAttributeNS(null, "opacity", t.fontOpacity), t.fontFamily && h.setAttributeNS(null, "font-family", t.fontFamily), t.fontSize && h.setAttributeNS(null, "font-size", t.fontSize), t.fontWeight && h.setAttributeNS(null, "font-weight", t.fontWeight), t.fontStyle && h.setAttributeNS(null, "font-style", t.fontStyle), !0 === t.labelSelect ? (h.setAttributeNS(null, "pointer-events", "visible"), h._featureId = e) : h.setAttributeNS(null, "pointer-events", "none"); var p = t.labelAlign || OpenLayers.Renderer.defaultSymbolizer.labelAlign; h.setAttributeNS(null, "text-anchor", OpenLayers.Renderer.SVG.LABEL_ALIGN[p[0]] || "middle"), !0 === OpenLayers.IS_GECKO && h.setAttributeNS(null, "dominant-baseline", OpenLayers.Renderer.SVG.LABEL_ALIGN[p[1]] || "central"); for (var u = t.label.split("\n"), y = u.length; h.childNodes.length > y;)h.removeChild(h.lastChild); for (var c = 0; c < y; c++) { var d = this.nodeFactory(e + l + "_tspan_" + c, "tspan"); if (!0 === t.labelSelect && (d._featureId = e, d._geometry = n, d._geometryClass = n.CLASS_NAME), !1 === OpenLayers.IS_GECKO && d.setAttributeNS(null, "baseline-shift", OpenLayers.Renderer.SVG.LABEL_VSHIFT[p[1]] || "-35%"), d.setAttribute("x", a), 0 == c) { var f = OpenLayers.Renderer.SVG.LABEL_VFACTOR[p[1]]; null == f && (f = -.5), d.setAttribute("dy", f * (y - 1) + "em") } else d.setAttribute("dy", "1em"); d.textContent = "" === u[c] ? " " : u[c], d.parentNode || h.appendChild(d) } h.parentNode || this.textRoot.appendChild(h) }, getComponentsString: function (e, t) { for (var n, i, s = [], r = !0, a = e.length, o = [], l = 0; l < a; l++)i = e[l], s.push(i), (n = this.getShortString(i)) ? o.push(n) : (l > 0 && this.getShortString(e[l - 1]) && o.push(this.clipLine(e[l], e[l - 1])), l < a - 1 && this.getShortString(e[l + 1]) && o.push(this.clipLine(e[l], e[l + 1])), r = !1); return { path: o.join(t || ","), complete: r } }, clipLine: function (e, t) { if (t.equals(e)) return ""; var n, i = this.getResolution(), s = this.MAX_PIXEL - this.translationParameters.x, r = this.MAX_PIXEL - this.translationParameters.y, a = (t.x - this.featureDx) / i + this.left, o = this.top - t.y / i, l = (e.x - this.featureDx) / i + this.left, h = this.top - e.y / i; return (l < -s || l > s) && (n = (h - o) / (l - a), h = o + ((l = l < 0 ? -s : s) - a) * n), (h < -r || h > r) && (n = (l - a) / (h - o), l = a + ((h = h < 0 ? -r : r) - o) * n), l + "," + h }, getShortString: function (e) { var t = this.getResolution(), n = (e.x - this.featureDx) / t + this.left, i = this.top - e.y / t; return !!this.inValidRange(n, i) && n + "," + i }, getPosition: function (e) { return { x: parseFloat(e.getAttributeNS(null, "cx")), y: parseFloat(e.getAttributeNS(null, "cy")) } }, importSymbol: function (e) { this.defs || (this.defs = this.createDefs()); var t = this.container.id + "-" + e, n = document.getElementById(t); if (null != n) return n; var i = OpenLayers.Renderer.symbol[e]; if (!i) throw new Error(e + " is not a valid symbol name"); var s = this.nodeFactory(t, "symbol"), r = this.nodeFactory(null, "polygon"); s.appendChild(r); for (var a, o, l = new OpenLayers.Bounds(Number.MAX_VALUE, Number.MAX_VALUE, 0, 0), h = [], p = 0; p < i.length; p += 2)a = i[p], o = i[p + 1], l.left = Math.min(l.left, a), l.bottom = Math.min(l.bottom, o), l.right = Math.max(l.right, a), l.top = Math.max(l.top, o), h.push(a, ",", o); r.setAttributeNS(null, "points", h.join(" ")); var u = l.getWidth(), y = l.getHeight(), c = [l.left - u, l.bottom - y, 3 * u, 3 * y]; return s.setAttributeNS(null, "viewBox", c.join(" ")), this.symbolMetrics[t] = [Math.max(u, y), l.getCenterLonLat().lon, l.getCenterLonLat().lat], this.defs.appendChild(s), s }, getFeatureIdFromEvent: function (e) { var t = OpenLayers.Renderer.Elements.prototype.getFeatureIdFromEvent.apply(this, arguments); if (!t) { var n = e.target; t = n.parentNode && n != this.rendererRoot ? n.parentNode._featureId : void 0 } return t }, CLASS_NAME: "OpenLayers.Renderer.SVG" }), OpenLayers.Renderer.SVG.LABEL_ALIGN = { l: "start", r: "end", b: "bottom", t: "hanging" }, OpenLayers.Renderer.SVG.LABEL_VSHIFT = { t: "-70%", b: "0" }, OpenLayers.Renderer.SVG.LABEL_VFACTOR = { t: 0, b: -1 }, OpenLayers.Renderer.SVG.preventDefault = function (e) { OpenLayers.Event.preventDefault(e) }, OpenLayers.Popup = OpenLayers.Class({ events: null, id: "", lonlat: null, div: null, contentSize: null, size: null, contentHTML: null, backgroundColor: "", opacity: "", border: "", contentDiv: null, groupDiv: null, closeDiv: null, autoSize: !1, minSize: null, maxSize: null, displayClass: "olPopup", contentDisplayClass: "olPopupContent", padding: 0, disableFirefoxOverflowHack: !1, fixPadding: function () { "number" == typeof this.padding && (this.padding = new OpenLayers.Bounds(this.padding, this.padding, this.padding, this.padding)) }, panMapIfOutOfView: !1, keepInMap: !1, closeOnMove: !1, map: null, initialize: function (e, t, n, i, s, r) { null == e && (e = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_")), this.id = e, this.lonlat = t, this.contentSize = null != n ? n : new OpenLayers.Size(OpenLayers.Popup.WIDTH, OpenLayers.Popup.HEIGHT), null != i && (this.contentHTML = i), this.backgroundColor = OpenLayers.Popup.COLOR, this.opacity = OpenLayers.Popup.OPACITY, this.border = OpenLayers.Popup.BORDER, this.div = OpenLayers.Util.createDiv(this.id, null, null, null, null, null, "hidden"), this.div.className = this.displayClass; var a = this.id + "_GroupDiv"; this.groupDiv = OpenLayers.Util.createDiv(a, null, null, null, "relative", null, "hidden"); e = this.div.id + "_contentDiv"; this.contentDiv = OpenLayers.Util.createDiv(e, null, this.contentSize.clone(), null, "relative"), this.contentDiv.className = this.contentDisplayClass, this.groupDiv.appendChild(this.contentDiv), this.div.appendChild(this.groupDiv), s && this.addCloseBox(r), this.registerEvents() }, destroy: function () { this.id = null, this.lonlat = null, this.size = null, this.contentHTML = null, this.backgroundColor = null, this.opacity = null, this.border = null, this.closeOnMove && this.map && this.map.events.unregister("movestart", this, this.hide), this.events.destroy(), this.events = null, this.closeDiv && (OpenLayers.Event.stopObservingElement(this.closeDiv), this.groupDiv.removeChild(this.closeDiv)), this.closeDiv = null, this.div.removeChild(this.groupDiv), this.groupDiv = null, null != this.map && this.map.removePopup(this), this.map = null, this.div = null, this.autoSize = null, this.minSize = null, this.maxSize = null, this.padding = null, this.panMapIfOutOfView = null }, draw: function (e) { return null == e && null != this.lonlat && null != this.map && (e = this.map.getLayerPxFromLonLat(this.lonlat)), this.closeOnMove && this.map.events.register("movestart", this, this.hide), this.disableFirefoxOverflowHack || "firefox" != OpenLayers.BROWSER_NAME || (this.map.events.register("movestart", this, function () { var e = document.defaultView.getComputedStyle(this.contentDiv, null).getPropertyValue("overflow"); "hidden" != e && (this.contentDiv._oldOverflow = e, this.contentDiv.style.overflow = "hidden") }), this.map.events.register("moveend", this, function () { var e = this.contentDiv._oldOverflow; e && (this.contentDiv.style.overflow = e, this.contentDiv._oldOverflow = null) })), this.moveTo(e), this.autoSize || this.size || this.setSize(this.contentSize), this.setBackgroundColor(), this.setOpacity(), this.setBorder(), this.setContentHTML(), this.panMapIfOutOfView && this.panIntoView(), this.div }, updatePosition: function () { if (this.lonlat && this.map) { var e = this.map.getLayerPxFromLonLat(this.lonlat); e && this.moveTo(e) } }, moveTo: function (e) { null != e && null != this.div && (this.div.style.left = e.x + "px", this.div.style.top = e.y + "px") }, visible: function () { return OpenLayers.Element.visible(this.div) }, toggle: function () { this.visible() ? this.hide() : this.show() }, show: function () { this.div.style.display = "", this.panMapIfOutOfView && this.panIntoView() }, hide: function () { this.div.style.display = "none" }, setSize: function (e) { this.size = e.clone(); var t = this.getContentDivPadding(), n = t.left + t.right, i = t.top + t.bottom; (this.fixPadding(), n += this.padding.left + this.padding.right, i += this.padding.top + this.padding.bottom, this.closeDiv) && (n += parseInt(this.closeDiv.style.width) + t.right); this.size.w += n, this.size.h += i, "msie" == OpenLayers.BROWSER_NAME && (this.contentSize.w += t.left + t.right, this.contentSize.h += t.bottom + t.top), null != this.div && (this.div.style.width = this.size.w + "px", this.div.style.height = this.size.h + "px"), null != this.contentDiv && (this.contentDiv.style.width = e.w + "px", this.contentDiv.style.height = e.h + "px") }, updateSize: function () { var e = "<div class='" + this.contentDisplayClass + "'>" + this.contentDiv.innerHTML + "</div>", t = this.map ? this.map.div : document.body, n = OpenLayers.Util.getRenderedDimensions(e, null, { displayClass: this.displayClass, containerElement: t }), i = this.getSafeContentSize(n), s = null; if (i.equals(n)) s = n; else { var r = { w: i.w < n.w ? i.w : null, h: i.h < n.h ? i.h : null }; if (r.w && r.h) s = i; else { var a = OpenLayers.Util.getRenderedDimensions(e, r, { displayClass: this.contentDisplayClass, containerElement: t }); if ("hidden" != OpenLayers.Element.getStyle(this.contentDiv, "overflow") && a.equals(i)) { var o = OpenLayers.Util.getScrollbarWidth(); r.w ? a.h += o : a.w += o } s = this.getSafeContentSize(a) } } this.setSize(s) }, setBackgroundColor: function (e) { null != e && (this.backgroundColor = e), null != this.div && (this.div.style.backgroundColor = this.backgroundColor) }, setOpacity: function (e) { null != e && (this.opacity = e), null != this.div && (this.div.style.opacity = this.opacity, this.div.style.filter = "alpha(opacity=" + 100 * this.opacity + ")") }, setBorder: function (e) { null != e && (this.border = e), null != this.div && (this.div.style.border = this.border) }, setContentHTML: function (e) { null != e && (this.contentHTML = e), null != this.contentDiv && null != this.contentHTML && this.contentHTML != this.contentDiv.innerHTML && (this.contentDiv.innerHTML = this.contentHTML, this.autoSize && (this.registerImageListeners(), this.updateSize())) }, registerImageListeners: function () { for (var e = function () { null !== this.popup.id && (this.popup.updateSize(), this.popup.visible() && this.popup.panMapIfOutOfView && this.popup.panIntoView(), OpenLayers.Event.stopObserving(this.img, "load", this.img._onImgLoad)) }, t = this.contentDiv.getElementsByTagName("img"), n = 0, i = t.length; n < i; n++) { var s = t[n]; if (0 == s.width || 0 == s.height) { var r = { popup: this, img: s }; s._onImgLoad = OpenLayers.Function.bind(e, r), OpenLayers.Event.observe(s, "load", s._onImgLoad) } } }, getSafeContentSize: function (e) { var t = e.clone(), n = this.getContentDivPadding(), i = n.left + n.right, s = n.top + n.bottom; (this.fixPadding(), i += this.padding.left + this.padding.right, s += this.padding.top + this.padding.bottom, this.closeDiv) && (i += parseInt(this.closeDiv.style.width) + n.right); if (this.minSize && (t.w = Math.max(t.w, this.minSize.w - i), t.h = Math.max(t.h, this.minSize.h - s)), this.maxSize && (t.w = Math.min(t.w, this.maxSize.w - i), t.h = Math.min(t.h, this.maxSize.h - s)), this.map && this.map.size) { var r = 0, a = 0; if (this.keepInMap && !this.panMapIfOutOfView) { var o = this.map.getPixelFromLonLat(this.lonlat); switch (this.relativePosition) { case "tr": r = o.x, a = this.map.size.h - o.y; break; case "tl": r = this.map.size.w - o.x, a = this.map.size.h - o.y; break; case "bl": r = this.map.size.w - o.x, a = o.y; break; case "br": r = o.x, a = o.y; break; default: r = o.x, a = this.map.size.h - o.y } } var l = this.map.size.h - this.map.paddingForPopups.top - this.map.paddingForPopups.bottom - s - a, h = this.map.size.w - this.map.paddingForPopups.left - this.map.paddingForPopups.right - i - r; t.w = Math.min(t.w, h), t.h = Math.min(t.h, l) } return t }, getContentDivPadding: function () { var e = this._contentDivPadding; return e || (null == this.div.parentNode && (this.div.style.display = "none", document.body.appendChild(this.div)), e = new OpenLayers.Bounds(OpenLayers.Element.getStyle(this.contentDiv, "padding-left"), OpenLayers.Element.getStyle(this.contentDiv, "padding-bottom"), OpenLayers.Element.getStyle(this.contentDiv, "padding-right"), OpenLayers.Element.getStyle(this.contentDiv, "padding-top")), this._contentDivPadding = e, this.div.parentNode == document.body && (document.body.removeChild(this.div), this.div.style.display = "")), e }, addCloseBox: function (e) { this.closeDiv = OpenLayers.Util.createDiv(this.id + "_close", null, { w: 17, h: 17 }), this.closeDiv.className = "olPopupCloseBox"; var t = this.getContentDivPadding(); this.closeDiv.style.right = t.right + "px", this.closeDiv.style.top = t.top + "px", this.groupDiv.appendChild(this.closeDiv); var n = e || function (e) { this.hide(), OpenLayers.Event.stop(e) }; OpenLayers.Event.observe(this.closeDiv, "touchend", OpenLayers.Function.bindAsEventListener(n, this)), OpenLayers.Event.observe(this.closeDiv, "click", OpenLayers.Function.bindAsEventListener(n, this)) }, panIntoView: function () { var e = this.map.getSize(), t = this.map.getViewPortPxFromLayerPx(new OpenLayers.Pixel(parseInt(this.div.style.left), parseInt(this.div.style.top))), n = t.clone(); t.x < this.map.paddingForPopups.left ? n.x = this.map.paddingForPopups.left : t.x + this.size.w > e.w - this.map.paddingForPopups.right && (n.x = e.w - this.map.paddingForPopups.right - this.size.w), t.y < this.map.paddingForPopups.top ? n.y = this.map.paddingForPopups.top : t.y + this.size.h > e.h - this.map.paddingForPopups.bottom && (n.y = e.h - this.map.paddingForPopups.bottom - this.size.h); var i = t.x - n.x, s = t.y - n.y; this.map.pan(i, s) }, registerEvents: function () { this.events = new OpenLayers.Events(this, this.div, null, !0), this.events.on({ mousedown: this.onmousedown, mousemove: this.onmousemove, mouseup: this.onmouseup, click: this.onclick, mouseout: this.onmouseout, dblclick: this.ondblclick, touchstart: function (e) { OpenLayers.Event.stop(e, !0) }, scope: this }) }, onmousedown: function (e) { this.mousedown = !0, OpenLayers.Event.stop(e, !0) }, onmousemove: function (e) { this.mousedown && OpenLayers.Event.stop(e, !0) }, onmouseup: function (e) { this.mousedown && (this.mousedown = !1, OpenLayers.Event.stop(e, !0)) }, onclick: function (e) { OpenLayers.Event.stop(e, !0) }, onmouseout: function (e) { this.mousedown = !1 }, ondblclick: function (e) { OpenLayers.Event.stop(e, !0) }, CLASS_NAME: "OpenLayers.Popup" }), OpenLayers.Popup.WIDTH = 200, OpenLayers.Popup.HEIGHT = 200, OpenLayers.Popup.COLOR = "white", OpenLayers.Popup.OPACITY = 1, OpenLayers.Popup.BORDER = "0px", OpenLayers.Popup.Anchored = OpenLayers.Class(OpenLayers.Popup, { relativePosition: null, keepInMap: !0, anchor: null, initialize: function (e, t, n, i, s, r, a) { var o = [e, t, n, i, r, a]; OpenLayers.Popup.prototype.initialize.apply(this, o), this.anchor = null != s ? s : { size: new OpenLayers.Size(0, 0), offset: new OpenLayers.Pixel(0, 0) } }, destroy: function () { this.anchor = null, this.relativePosition = null, OpenLayers.Popup.prototype.destroy.apply(this, arguments) }, show: function () { this.updatePosition(), OpenLayers.Popup.prototype.show.apply(this, arguments) }, moveTo: function (e) { var t = this.relativePosition; this.relativePosition = this.calculateRelativePosition(e), OpenLayers.Popup.prototype.moveTo.call(this, this.calculateNewPx(e)), this.relativePosition != t && this.updateRelativePosition() }, setSize: function (e) { if (OpenLayers.Popup.prototype.setSize.apply(this, arguments), this.lonlat && this.map) { var t = this.map.getLayerPxFromLonLat(this.lonlat); this.moveTo(t) } }, calculateRelativePosition: function (e) { var t = this.map.getLonLatFromLayerPx(e), n = this.map.getExtent().determineQuadrant(t); return OpenLayers.Bounds.oppositeQuadrant(n) }, updateRelativePosition: function () { }, calculateNewPx: function (e) { var t = e.offset(this.anchor.offset), n = this.size || this.contentSize, i = "t" == this.relativePosition.charAt(0); t.y += i ? -n.h : this.anchor.size.h; var s = "l" == this.relativePosition.charAt(1); return t.x += s ? -n.w : this.anchor.size.w, t }, CLASS_NAME: "OpenLayers.Popup.Anchored" }), OpenLayers.Popup.Framed = OpenLayers.Class(OpenLayers.Popup.Anchored, { imageSrc: null, imageSize: null, isAlphaImage: !1, positionBlocks: null, blocks: null, fixedRelativePosition: !1, initialize: function (e, t, n, i, s, r, a) { OpenLayers.Popup.Anchored.prototype.initialize.apply(this, arguments), this.fixedRelativePosition && (this.updateRelativePosition(), this.calculateRelativePosition = function (e) { return this.relativePosition }), this.contentDiv.style.position = "absolute", this.contentDiv.style.zIndex = 1, r && (this.closeDiv.style.zIndex = 1), this.groupDiv.style.position = "absolute", this.groupDiv.style.top = "0px", this.groupDiv.style.left = "0px", this.groupDiv.style.height = "100%", this.groupDiv.style.width = "100%" }, destroy: function () { this.imageSrc = null, this.imageSize = null, this.isAlphaImage = null, this.fixedRelativePosition = !1, this.positionBlocks = null; for (var e = 0; e < this.blocks.length; e++) { var t = this.blocks[e]; t.image && t.div.removeChild(t.image), t.image = null, t.div && this.groupDiv.removeChild(t.div), t.div = null } this.blocks = null, OpenLayers.Popup.Anchored.prototype.destroy.apply(this, arguments) }, setBackgroundColor: function (e) { }, setBorder: function () { }, setOpacity: function (e) { }, setSize: function (e) { OpenLayers.Popup.Anchored.prototype.setSize.apply(this, arguments), this.updateBlocks() }, updateRelativePosition: function () { if (this.padding = this.positionBlocks[this.relativePosition].padding, this.closeDiv) { var e = this.getContentDivPadding(); this.closeDiv.style.right = e.right + this.padding.right + "px", this.closeDiv.style.top = e.top + this.padding.top + "px" } this.updateBlocks() }, calculateNewPx: function (e) { var t = OpenLayers.Popup.Anchored.prototype.calculateNewPx.apply(this, arguments); return t = t.offset(this.positionBlocks[this.relativePosition].offset) }, createBlocks: function () { this.blocks = []; var e = null; for (var t in this.positionBlocks) { e = t; break } for (var n = this.positionBlocks[e], i = 0; i < n.blocks.length; i++) { var s = {}; this.blocks.push(s); var r = this.id + "_FrameDecorationDiv_" + i; s.div = OpenLayers.Util.createDiv(r, null, null, null, "absolute", null, "hidden", null); var a = this.id + "_FrameDecorationImg_" + i, o = this.isAlphaImage ? OpenLayers.Util.createAlphaImageDiv : OpenLayers.Util.createImage; s.image = o(a, null, this.imageSize, this.imageSrc, "absolute", null, null, null), s.div.appendChild(s.image), this.groupDiv.appendChild(s.div) } }, updateBlocks: function () { if (this.blocks || this.createBlocks(), this.size && this.relativePosition) { for (var e = this.positionBlocks[this.relativePosition], t = 0; t < e.blocks.length; t++) { var n = e.blocks[t], i = this.blocks[t], s = n.anchor.left, r = n.anchor.bottom, a = n.anchor.right, o = n.anchor.top, l = isNaN(n.size.w) ? this.size.w - (a + s) : n.size.w, h = isNaN(n.size.h) ? this.size.h - (r + o) : n.size.h; i.div.style.width = (l < 0 ? 0 : l) + "px", i.div.style.height = (h < 0 ? 0 : h) + "px", i.div.style.left = null != s ? s + "px" : "", i.div.style.bottom = null != r ? r + "px" : "", i.div.style.right = null != a ? a + "px" : "", i.div.style.top = null != o ? o + "px" : "", i.image.style.left = n.position.x + "px", i.image.style.top = n.position.y + "px" } this.contentDiv.style.left = this.padding.left + "px", this.contentDiv.style.top = this.padding.top + "px" } }, CLASS_NAME: "OpenLayers.Popup.Framed" }), OpenLayers.Format = OpenLayers.Class({ options: null, externalProjection: null, internalProjection: null, data: null, keepData: !1, initialize: function (e) { OpenLayers.Util.extend(this, e), this.options = e }, destroy: function () { }, read: function (e) { throw new Error("Read not implemented.") }, write: function (e) { throw new Error("Write not implemented.") }, CLASS_NAME: "OpenLayers.Format" }), OpenLayers.Format.JSON = OpenLayers.Class(OpenLayers.Format, { indent: "    ", space: " ", newline: "\n", level: 0, pretty: !1, nativeJSON: !(!window.JSON || "function" != typeof JSON.parse || "function" != typeof JSON.stringify), read: function (json, filter) { var object; if (this.nativeJSON) object = JSON.parse(json, filter); else try { if (/^[\],:{}\s]*$/.test(json.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, "")) && (object = eval("(" + json + ")"), "function" == typeof filter)) { function walk(e, t) { if (t && "object" == typeof t) for (var n in t) t.hasOwnProperty(n) && (t[n] = walk(n, t[n])); return filter(e, t) } object = walk("", object) } } catch (e) { } return this.keepData && (this.data = object), object }, write: function (e, t) { this.pretty = !!t; var n = null, i = typeof e; if (this.serialize[i]) try { n = !this.pretty && this.nativeJSON ? JSON.stringify(e) : this.serialize[i].apply(this, [e]) } catch (e) { OpenLayers.Console.error("Trouble serializing: " + e) } return n }, writeIndent: function () { var e = []; if (this.pretty) for (var t = 0; t < this.level; ++t)e.push(this.indent); return e.join("") }, writeNewline: function () { return this.pretty ? this.newline : "" }, writeSpace: function () { return this.pretty ? this.space : "" }, serialize: { object: function (e) { if (null == e) return "null"; if (e.constructor == Date) return this.serialize.date.apply(this, [e]); if (e.constructor == Array) return this.serialize.array.apply(this, [e]); var t, n, i, s = ["{"]; this.level += 1; var r = !1; for (t in e) e.hasOwnProperty(t) && (n = OpenLayers.Format.JSON.prototype.write.apply(this, [t, this.pretty]), i = OpenLayers.Format.JSON.prototype.write.apply(this, [e[t], this.pretty]), null != n && null != i && (r && s.push(","), s.push(this.writeNewline(), this.writeIndent(), n, ":", this.writeSpace(), i), r = !0)); return this.level -= 1, s.push(this.writeNewline(), this.writeIndent(), "}"), s.join("") }, array: function (e) { var t, n = ["["]; this.level += 1; for (var i = 0, s = e.length; i < s; ++i)null != (t = OpenLayers.Format.JSON.prototype.write.apply(this, [e[i], this.pretty])) && (i > 0 && n.push(","), n.push(this.writeNewline(), this.writeIndent(), t)); return this.level -= 1, n.push(this.writeNewline(), this.writeIndent(), "]"), n.join("") }, string: function (e) { var t = { "\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }; return /["\\\x00-\x1f]/.test(e) ? '"' + e.replace(/([\x00-\x1f\\"])/g, function (e, n) { var i = t[n]; return i || (i = n.charCodeAt(), "\\u00" + Math.floor(i / 16).toString(16) + (i % 16).toString(16)) }) + '"' : '"' + e + '"' }, number: function (e) { return isFinite(e) ? String(e) : "null" }, boolean: function (e) { return String(e) }, date: function (e) { function t(e) { return e < 10 ? "0" + e : e } return '"' + e.getFullYear() + "-" + t(e.getMonth() + 1) + "-" + t(e.getDate()) + "T" + t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + '"' } }, CLASS_NAME: "OpenLayers.Format.JSON" }), OpenLayers.Format.GeoJSON = OpenLayers.Class(OpenLayers.Format.JSON, { ignoreExtraDims: !1, read: function (e, t, n) { t = t || "FeatureCollection"; var i = null, s = null; if (s = "string" == typeof e ? OpenLayers.Format.JSON.prototype.read.apply(this, [e, n]) : e) { if ("string" != typeof s.type) OpenLayers.Console.error("Bad GeoJSON - no type: " + e); else if (this.isValidType(s, t)) switch (t) { case "Geometry": try { i = this.parseGeometry(s) } catch (e) { OpenLayers.Console.error(e) } break; case "Feature": try { (i = this.parseFeature(s)).type = "Feature" } catch (e) { OpenLayers.Console.error(e) } break; case "FeatureCollection": switch (i = [], s.type) { case "Feature": try { i.push(this.parseFeature(s)) } catch (e) { i = null, OpenLayers.Console.error(e) } break; case "FeatureCollection": for (var r = 0, a = s.features.length; r < a; ++r)try { i.push(this.parseFeature(s.features[r])) } catch (e) { i = null, OpenLayers.Console.error(e) } break; default: try { var o = this.parseGeometry(s); i.push(new OpenLayers.Feature.Vector(o)) } catch (e) { i = null, OpenLayers.Console.error(e) } } } } else OpenLayers.Console.error("Bad JSON: " + e); return i }, isValidType: function (e, t) { var n = !1; switch (t) { case "Geometry": -1 == OpenLayers.Util.indexOf(["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "Box", "GeometryCollection"], e.type) ? OpenLayers.Console.error("Unsupported geometry type: " + e.type) : n = !0; break; case "FeatureCollection": n = !0; break; default: e.type == t ? n = !0 : OpenLayers.Console.error("Cannot convert types from " + e.type + " to " + t) }return n }, parseFeature: function (e) { var t, n, i, s; i = e.properties ? e.properties : {}, s = e.geometry && e.geometry.bbox || e.bbox; try { n = this.parseGeometry(e.geometry) } catch (e) { throw e } return t = new OpenLayers.Feature.Vector(n, i), s && (t.bounds = OpenLayers.Bounds.fromArray(s)), e.id && (t.fid = e.id), t }, parseGeometry: function (e) { if (null == e) return null; var t, n = !1; if ("GeometryCollection" == e.type) { if (!OpenLayers.Util.isArray(e.geometries)) throw "GeometryCollection must have geometries array: " + e; for (var i = e.geometries.length, s = new Array(i), r = 0; r < i; ++r)s[r] = this.parseGeometry.apply(this, [e.geometries[r]]); t = new OpenLayers.Geometry.Collection(s), n = !0 } else { if (!OpenLayers.Util.isArray(e.coordinates)) throw "Geometry must have coordinates array: " + e; if (!this.parseCoords[e.type.toLowerCase()]) throw "Unsupported geometry type: " + e.type; try { t = this.parseCoords[e.type.toLowerCase()].apply(this, [e.coordinates]) } catch (e) { throw e } } return this.internalProjection && this.externalProjection && !n && t.transform(this.externalProjection, this.internalProjection), t }, parseCoords: { point: function (e) { if (0 == this.ignoreExtraDims && 2 != e.length) throw "Only 2D points are supported: " + e; return new OpenLayers.Geometry.Point(e[0], e[1]) }, multipoint: function (e) { for (var t = [], n = null, i = 0, s = e.length; i < s; ++i) { try { n = this.parseCoords.point.apply(this, [e[i]]) } catch (e) { throw e } t.push(n) } return new OpenLayers.Geometry.MultiPoint(t) }, linestring: function (e) { for (var t = [], n = null, i = 0, s = e.length; i < s; ++i) { try { n = this.parseCoords.point.apply(this, [e[i]]) } catch (e) { throw e } t.push(n) } return new OpenLayers.Geometry.LineString(t) }, multilinestring: function (e) { for (var t = [], n = null, i = 0, s = e.length; i < s; ++i) { try { n = this.parseCoords.linestring.apply(this, [e[i]]) } catch (e) { throw e } t.push(n) } return new OpenLayers.Geometry.MultiLineString(t) }, polygon: function (e) { for (var t, n, i = [], s = 0, r = e.length; s < r; ++s) { try { n = this.parseCoords.linestring.apply(this, [e[s]]) } catch (e) { throw e } t = new OpenLayers.Geometry.LinearRing(n.components), i.push(t) } return new OpenLayers.Geometry.Polygon(i) }, multipolygon: function (e) { for (var t = [], n = null, i = 0, s = e.length; i < s; ++i) { try { n = this.parseCoords.polygon.apply(this, [e[i]]) } catch (e) { throw e } t.push(n) } return new OpenLayers.Geometry.MultiPolygon(t) }, box: function (e) { if (2 != e.length) throw "GeoJSON box coordinates must have 2 elements"; return new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing([new OpenLayers.Geometry.Point(e[0][0], e[0][1]), new OpenLayers.Geometry.Point(e[1][0], e[0][1]), new OpenLayers.Geometry.Point(e[1][0], e[1][1]), new OpenLayers.Geometry.Point(e[0][0], e[1][1]), new OpenLayers.Geometry.Point(e[0][0], e[0][1])])]) } }, write: function (e, t) { var n = { type: null }; if (OpenLayers.Util.isArray(e)) { n.type = "FeatureCollection"; var i = e.length; n.features = new Array(i); for (var s = 0; s < i; ++s) { var r = e[s]; if (!r instanceof OpenLayers.Feature.Vector) throw "FeatureCollection only supports collections of features: " + r; n.features[s] = this.extract.feature.apply(this, [r]) } } else 0 == e.CLASS_NAME.indexOf("OpenLayers.Geometry") ? n = this.extract.geometry.apply(this, [e]) : e instanceof OpenLayers.Feature.Vector && (n = this.extract.feature.apply(this, [e]), e.layer && e.layer.projection && (n.crs = this.createCRSObject(e))); return OpenLayers.Format.JSON.prototype.write.apply(this, [n, t]) }, createCRSObject: function (e) { var t = e.layer.projection.toString(), n = {}; if (t.match(/epsg:/i)) { var i = parseInt(t.substring(t.indexOf(":") + 1)); n = 4326 == i ? { type: "name", properties: { name: "urn:ogc:def:crs:OGC:1.3:CRS84" } } : { type: "name", properties: { name: "EPSG:" + i } } } return n }, extract: { feature: function (e) { var t = this.extract.geometry.apply(this, [e.geometry]), n = { type: "Feature", properties: e.attributes, geometry: t }; return null != e.fid && (n.id = e.fid), n }, geometry: function (e) { if (null == e) return null; this.internalProjection && this.externalProjection && (e = e.clone()).transform(this.internalProjection, this.externalProjection); var t = e.CLASS_NAME.split(".")[2], n = this.extract[t.toLowerCase()].apply(this, [e]); return "Collection" == t ? { type: "GeometryCollection", geometries: n } : { type: t, coordinates: n } }, point: function (e) { return [e.x, e.y] }, multipoint: function (e) { for (var t = [], n = 0, i = e.components.length; n < i; ++n)t.push(this.extract.point.apply(this, [e.components[n]])); return t }, linestring: function (e) { for (var t = [], n = 0, i = e.components.length; n < i; ++n)t.push(this.extract.point.apply(this, [e.components[n]])); return t }, multilinestring: function (e) { for (var t = [], n = 0, i = e.components.length; n < i; ++n)t.push(this.extract.linestring.apply(this, [e.components[n]])); return t }, polygon: function (e) { for (var t = [], n = 0, i = e.components.length; n < i; ++n)t.push(this.extract.linestring.apply(this, [e.components[n]])); return t }, multipolygon: function (e) { for (var t = [], n = 0, i = e.components.length; n < i; ++n)t.push(this.extract.polygon.apply(this, [e.components[n]])); return t }, collection: function (e) { for (var t = e.components.length, n = new Array(t), i = 0; i < t; ++i)n[i] = this.extract.geometry.apply(this, [e.components[i]]); return n } }, CLASS_NAME: "OpenLayers.Format.GeoJSON" }), OpenLayers.Layer.Google.v3 = { DEFAULTS: { sphericalMercator: !0, projection: "EPSG:900913" }, animationEnabled: !0, loadMapObject: function () { var e; this.type || (this.type = google.maps.MapTypeId.ROADMAP); var t = OpenLayers.Layer.Google.cache[this.map.id]; if (t) e = t.mapObject, ++t.count; else { var n = this.map.getCenter(), i = document.createElement("div"); i.className = "olForeignContainer", i.style.width = "100%", i.style.height = "100%", e = new google.maps.Map(i, { center: n ? new google.maps.LatLng(n.lat, n.lon) : new google.maps.LatLng(0, 0), zoom: this.map.getZoom() || 0, mapTypeId: this.type, disableDefaultUI: !0, keyboardShortcuts: !1, draggable: !1, disableDoubleClickZoom: !0, scrollwheel: !1, streetViewControl: !1 }); var s = document.createElement("div"); s.style.width = "100%", s.style.height = "100%", e.controls[google.maps.ControlPosition.TOP_LEFT].push(s), t = { googleControl: s, mapObject: e, count: 1 }, OpenLayers.Layer.Google.cache[this.map.id] = t } this.mapObject = e, this.setGMapVisibility(this.visibility) }, onMapResize: function () { this.visibility && google.maps.event.trigger(this.mapObject, "resize") }, setGMapVisibility: function (e) { var t = OpenLayers.Layer.Google.cache[this.map.id], n = this.map; if (t) { for (var i, s = this.type, r = n.layers, a = r.length - 1; a >= 0; --a)if ((i = r[a]) instanceof OpenLayers.Layer.Google && !0 === i.visibility && !0 === i.inRange) { s = i.type, e = !0; break } var o = this.mapObject.getDiv(); if (!0 === e) { if (o.parentNode !== n.div) if (t.rendered) n.div.appendChild(o), t.googleControl.appendChild(n.viewPortDiv), google.maps.event.trigger(this.mapObject, "resize"); else { var l = this; google.maps.event.addListenerOnce(this.mapObject, "tilesloaded", function () { t.rendered = !0, l.setGMapVisibility(l.getVisibility()), l.moveTo(l.map.getCenter()) }) } this.mapObject.setMapTypeId(s) } else t.googleControl.hasChildNodes() && (n.div.appendChild(n.viewPortDiv), n.div.removeChild(o)) } }, getMapContainer: function () { return this.mapObject.getDiv() }, getMapObjectBoundsFromOLBounds: function (e) { var t = null; if (null != e) { var n = this.sphericalMercator ? this.inverseMercator(e.bottom, e.left) : new OpenLayers.LonLat(e.bottom, e.left), i = this.sphericalMercator ? this.inverseMercator(e.top, e.right) : new OpenLayers.LonLat(e.top, e.right); t = new google.maps.LatLngBounds(new google.maps.LatLng(n.lat, n.lon), new google.maps.LatLng(i.lat, i.lon)) } return t }, getMapObjectLonLatFromMapObjectPixel: function (e) { var t = this.map.getSize(), n = this.getLongitudeFromMapObjectLonLat(this.mapObject.center), i = this.getLatitudeFromMapObjectLonLat(this.mapObject.center), s = this.map.getResolution(), r = e.x - t.w / 2, a = e.y - t.h / 2, o = new OpenLayers.LonLat(n + r * s, i - a * s); return this.wrapDateLine && (o = o.wrapDateLine(this.maxExtent)), this.getMapObjectLonLatFromLonLat(o.lon, o.lat) }, getMapObjectPixelFromMapObjectLonLat: function (e) { var t = this.getLongitudeFromMapObjectLonLat(e), n = this.getLatitudeFromMapObjectLonLat(e), i = this.map.getResolution(), s = this.map.getExtent(); return this.getMapObjectPixelFromXY(1 / i * (t - s.left), 1 / i * (s.top - n)) }, setMapObjectCenter: function (e, t) { if (!1 === this.animationEnabled && t != this.mapObject.zoom) { var n = this.getMapContainer(); google.maps.event.addListenerOnce(this.mapObject, "idle", function () { n.style.visibility = "" }), n.style.visibility = "hidden" } this.mapObject.setOptions({ center: e, zoom: t }) }, getMapObjectZoomFromMapObjectBounds: function (e) { return this.mapObject.getBoundsZoomLevel(e) }, getMapObjectLonLatFromLonLat: function (e, t) { var n; if (this.sphericalMercator) { var i = this.inverseMercator(e, t); n = new google.maps.LatLng(i.lat, i.lon) } else n = new google.maps.LatLng(t, e); return n }, getMapObjectPixelFromXY: function (e, t) { return new google.maps.Point(e, t) } }, OpenLayers.ProxyHost = "", OpenLayers.Request || (OpenLayers.Request = {}), OpenLayers.Util.extend(OpenLayers.Request, { DEFAULT_CONFIG: { method: "GET", url: window.location.href, async: !0, user: void 0, password: void 0, params: null, proxy: OpenLayers.ProxyHost, headers: {}, data: null, callback: function () { }, success: null, failure: null, scope: null }, URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/, events: new OpenLayers.Events(this), makeSameOrigin: function (e, t) { var n = 0 !== e.indexOf("http"), i = !n && e.match(this.URL_SPLIT_REGEX); if (i) { var s = window.location; n = i[1] == s.protocol && i[3] == s.hostname; var r = i[4], a = s.port; (80 != r && "" != r || "80" != a && "" != a) && (n = n && r == a) } return n || t && (e = "function" == typeof t ? t(e) : t + encodeURIComponent(e)), e }, issue: function (e) { var t = OpenLayers.Util.extend(this.DEFAULT_CONFIG, { proxy: OpenLayers.ProxyHost }); (e = e || {}).headers = e.headers || {}, (e = OpenLayers.Util.applyDefaults(e, t)).headers = OpenLayers.Util.applyDefaults(e.headers, t.headers); var n, i = !1; for (n in e.headers) e.headers.hasOwnProperty(n) && "x-requested-with" === n.toLowerCase() && (i = !0); !1 === i && (e.headers["X-Requested-With"] = "XMLHttpRequest"); var s = new OpenLayers.Request.XMLHttpRequest, r = OpenLayers.Util.urlAppend(e.url, OpenLayers.Util.getParameterString(e.params || {})); for (var a in r = OpenLayers.Request.makeSameOrigin(r, e.proxy), s.open(e.method, r, e.async, e.user, e.password), e.headers) s.setRequestHeader(a, e.headers[a]); var o = this.events, l = this; return s.onreadystatechange = function () { s.readyState == OpenLayers.Request.XMLHttpRequest.DONE && (!1 !== o.triggerEvent("complete", { request: s, config: e, requestUrl: r }) && l.runCallbacks({ request: s, config: e, requestUrl: r })) }, !1 === e.async ? s.send(e.data) : window.setTimeout(function () { 0 !== s.readyState && s.send(e.data) }, 0), s }, runCallbacks: function (e) { var t, n, i = e.request, s = e.config, r = s.scope ? OpenLayers.Function.bind(s.callback, s.scope) : s.callback; s.success && (t = s.scope ? OpenLayers.Function.bind(s.success, s.scope) : s.success), s.failure && (n = s.scope ? OpenLayers.Function.bind(s.failure, s.scope) : s.failure), "file:" == OpenLayers.Util.createUrlObject(s.url).protocol && i.responseText && (i.status = 200), r(i), (!i.status || i.status >= 200 && i.status < 300) && (this.events.triggerEvent("success", e), t && t(i)), i.status && (i.status < 200 || i.status >= 300) && (this.events.triggerEvent("failure", e), n && n(i)) }, GET: function (e) { return e = OpenLayers.Util.extend(e, { method: "GET" }), OpenLayers.Request.issue(e) }, POST: function (e) { return (e = OpenLayers.Util.extend(e, { method: "POST" })).headers = e.headers ? e.headers : {}, "CONTENT-TYPE" in OpenLayers.Util.upperCaseObject(e.headers) || (e.headers["Content-Type"] = "application/xml"), OpenLayers.Request.issue(e) }, PUT: function (e) { return (e = OpenLayers.Util.extend(e, { method: "PUT" })).headers = e.headers ? e.headers : {}, "CONTENT-TYPE" in OpenLayers.Util.upperCaseObject(e.headers) || (e.headers["Content-Type"] = "application/xml"), OpenLayers.Request.issue(e) }, DELETE: function (e) { return e = OpenLayers.Util.extend(e, { method: "DELETE" }), OpenLayers.Request.issue(e) }, HEAD: function (e) { return e = OpenLayers.Util.extend(e, { method: "HEAD" }), OpenLayers.Request.issue(e) }, OPTIONS: function (e) { return e = OpenLayers.Util.extend(e, { method: "OPTIONS" }), OpenLayers.Request.issue(e) } }), function () { var e = window.XMLHttpRequest, t = !!window.controllers, n = window.document.all && !window.opera, i = n && window.navigator.userAgent.match(/MSIE 7.0/); function s() { this._object = e && !i ? new e : new window.ActiveXObject("Microsoft.XMLHTTP"), this._listeners = [] } function r() { return new s } function a(e) { r.onreadystatechange && r.onreadystatechange.apply(e), e.dispatchEvent({ type: "readystatechange", bubbles: !1, cancelable: !1, timeStamp: new Date + 0 }) } function o(e) { try { e.responseText = e._object.responseText } catch (e) { } try { e.responseXML = function (e) { var t = e.responseXML, i = e.responseText; return n && i && t && !t.documentElement && e.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/) && ((t = new window.ActiveXObject("Microsoft.XMLDOM")).async = !1, t.validateOnParse = !1, t.loadXML(i)), t && (n && 0 != t.parseError || !t.documentElement || t.documentElement && "parsererror" == t.documentElement.tagName) ? null : t }(e._object) } catch (e) { } try { e.status = e._object.status } catch (e) { } try { e.statusText = e._object.statusText } catch (e) { } } function l(e) { e._object.onreadystatechange = new window.Function } r.prototype = s.prototype, t && e.wrapped && (r.wrapped = e.wrapped), r.UNSENT = 0, r.OPENED = 1, r.HEADERS_RECEIVED = 2, r.LOADING = 3, r.DONE = 4, r.prototype.readyState = r.UNSENT, r.prototype.responseText = "", r.prototype.responseXML = null, r.prototype.status = 0, r.prototype.statusText = "", r.prototype.priority = "NORMAL", r.prototype.onreadystatechange = null, r.onreadystatechange = null, r.onopen = null, r.onsend = null, r.onabort = null, r.prototype.open = function (e, i, s, h, p) { delete this._headers, arguments.length < 3 && (s = !0), this._async = s; var u, y = this, c = this.readyState; n && s && (u = function () { c != r.DONE && (l(y), y.abort()) }, window.attachEvent("onunload", u)), r.onopen && r.onopen.apply(this, arguments), arguments.length > 4 ? this._object.open(e, i, s, h, p) : arguments.length > 3 ? this._object.open(e, i, s, h) : this._object.open(e, i, s), this.readyState = r.OPENED, a(this), this._object.onreadystatechange = function () { t && !s || (y.readyState = y._object.readyState, o(y), y._aborted ? y.readyState = r.UNSENT : (y.readyState == r.DONE && (delete y._data, l(y), n && s && window.detachEvent("onunload", u)), c != y.readyState && a(y), c = y.readyState)) } }, r.prototype.send = function (e) { r.onsend && r.onsend.apply(this, arguments), arguments.length || (e = null), e && e.nodeType && (e = window.XMLSerializer ? (new window.XMLSerializer).serializeToString(e) : e.xml, this._headers["Content-Type"] || this._object.setRequestHeader("Content-Type", "application/xml")), this._data = e, function (e) { if (e._object.send(e._data), t && !e._async) for (e.readyState = r.OPENED, o(e); e.readyState < r.DONE;)if (e.readyState++ , a(e), e._aborted) return }(this) }, r.prototype.abort = function () { r.onabort && r.onabort.apply(this, arguments), this.readyState > r.UNSENT && (this._aborted = !0), this._object.abort(), l(this), this.readyState = r.UNSENT, delete this._data }, r.prototype.getAllResponseHeaders = function () { return this._object.getAllResponseHeaders() }, r.prototype.getResponseHeader = function (e) { return this._object.getResponseHeader(e) }, r.prototype.setRequestHeader = function (e, t) { return this._headers || (this._headers = {}), this._headers[e] = t, this._object.setRequestHeader(e, t) }, r.prototype.addEventListener = function (e, t, n) { for (var i, s = 0; i = this._listeners[s]; s++)if (i[0] == e && i[1] == t && i[2] == n) return; this._listeners.push([e, t, n]) }, r.prototype.removeEventListener = function (e, t, n) { for (var i, s = 0; (i = this._listeners[s]) && (i[0] != e || i[1] != t || i[2] != n); s++); i && this._listeners.splice(s, 1) }, r.prototype.dispatchEvent = function (e) { var t = { type: e.type, target: this, currentTarget: this, eventPhase: 2, bubbles: e.bubbles, cancelable: e.cancelable, timeStamp: e.timeStamp, stopPropagation: function () { }, preventDefault: function () { }, initEvent: function () { } }; "readystatechange" == t.type && this.onreadystatechange && (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [t]); for (var n, i = 0; n = this._listeners[i]; i++)n[0] != t.type || n[2] || (n[1].handleEvent || n[1]).apply(this, [t]) }, r.prototype.toString = function () { return "[object XMLHttpRequest]" }, r.toString = function () { return "[XMLHttpRequest]" }, window.Function.prototype.apply || (window.Function.prototype.apply = function (e, t) { t || (t = []), e.__func = this, e.__func(t[0], t[1], t[2], t[3], t[4]), delete e.__func }), OpenLayers.Request || (OpenLayers.Request = {}), OpenLayers.Request.XMLHttpRequest = r }(), OpenLayers.Filter.Comparison = OpenLayers.Class(OpenLayers.Filter, { type: null, property: null, value: null, matchCase: !0, lowerBoundary: null, upperBoundary: null, initialize: function (e) { OpenLayers.Filter.prototype.initialize.apply(this, [e]), this.type === OpenLayers.Filter.Comparison.LIKE && void 0 === e.matchCase && (this.matchCase = null) }, evaluate: function (e) { e instanceof OpenLayers.Feature.Vector && (e = e.attributes); var t, n = !1, i = e[this.property]; switch (this.type) { case OpenLayers.Filter.Comparison.EQUAL_TO: t = this.value, n = this.matchCase || "string" != typeof i || "string" != typeof t ? i == t : i.toUpperCase() == t.toUpperCase(); break; case OpenLayers.Filter.Comparison.NOT_EQUAL_TO: t = this.value, n = this.matchCase || "string" != typeof i || "string" != typeof t ? i != t : i.toUpperCase() != t.toUpperCase(); break; case OpenLayers.Filter.Comparison.LESS_THAN: n = i < this.value; break; case OpenLayers.Filter.Comparison.GREATER_THAN: n = i > this.value; break; case OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO: n = i <= this.value; break; case OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO: n = i >= this.value; break; case OpenLayers.Filter.Comparison.BETWEEN: n = i >= this.lowerBoundary && i <= this.upperBoundary; break; case OpenLayers.Filter.Comparison.LIKE: n = new RegExp(this.value, "gi").test(i); break; case OpenLayers.Filter.Comparison.IS_NULL: n = null === i }return n }, value2regex: function (e, t, n) { if ("." == e) throw new Error("'.' is an unsupported wildCard character for OpenLayers.Filter.Comparison"); return e = e || "*", t = t || ".", n = n || "!", this.value = this.value.replace(new RegExp("\\" + n + "(.|$)", "g"), "\\$1"), this.value = this.value.replace(new RegExp("\\" + t, "g"), "."), this.value = this.value.replace(new RegExp("\\" + e, "g"), ".*"), this.value = this.value.replace(new RegExp("\\\\.\\*", "g"), "\\" + e), this.value = this.value.replace(new RegExp("\\\\\\.", "g"), "\\" + t), this.value }, regex2value: function () { var e = this.value; return e = (e = (e = (e = (e = e.replace(/!/g, "!!")).replace(/(\\)?\\\./g, function (e, t) { return t ? e : "!." })).replace(/(\\)?\\\*/g, function (e, t) { return t ? e : "!*" })).replace(/\\\\/g, "\\")).replace(/\.\*/g, "*") }, clone: function () { return OpenLayers.Util.extend(new OpenLayers.Filter.Comparison, this) }, CLASS_NAME: "OpenLayers.Filter.Comparison" }), OpenLayers.Filter.Comparison.EQUAL_TO = "==", OpenLayers.Filter.Comparison.NOT_EQUAL_TO = "!=", OpenLayers.Filter.Comparison.LESS_THAN = "<", OpenLayers.Filter.Comparison.GREATER_THAN = ">", OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO = "<=", OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=", OpenLayers.Filter.Comparison.BETWEEN = "..", OpenLayers.Filter.Comparison.LIKE = "~", OpenLayers.Filter.Comparison.IS_NULL = "NULL", OpenLayers.Popup.FramedCloud = OpenLayers.Class(OpenLayers.Popup.Framed, { contentDisplayClass: "olFramedCloudPopupContent", autoSize: !0, panMapIfOutOfView: !0, imageSize: new OpenLayers.Size(1276, 736), isAlphaImage: !1, fixedRelativePosition: !1, positionBlocks: { tl: { offset: new OpenLayers.Pixel(44, 0), padding: new OpenLayers.Bounds(8, 40, 8, 9), blocks: [{ size: new OpenLayers.Size("auto", "auto"), anchor: new OpenLayers.Bounds(0, 51, 22, 0), position: new OpenLayers.Pixel(0, 0) }, { size: new OpenLayers.Size(22, "auto"), anchor: new OpenLayers.Bounds(null, 50, 0, 0), position: new OpenLayers.Pixel(-1238, 0) }, { size: new OpenLayers.Size("auto", 19), anchor: new OpenLayers.Bounds(0, 32, 22, null), position: new OpenLayers.Pixel(0, -631) }, { size: new OpenLayers.Size(22, 18), anchor: new OpenLayers.Bounds(null, 32, 0, null), position: new OpenLayers.Pixel(-1238, -632) }, { size: new OpenLayers.Size(81, 35), anchor: new OpenLayers.Bounds(null, 0, 0, null), position: new OpenLayers.Pixel(0, -688) }] }, tr: { offset: new OpenLayers.Pixel(-45, 0), padding: new OpenLayers.Bounds(8, 40, 8, 9), blocks: [{ size: new OpenLayers.Size("auto", "auto"), anchor: new OpenLayers.Bounds(0, 51, 22, 0), position: new OpenLayers.Pixel(0, 0) }, { size: new OpenLayers.Size(22, "auto"), anchor: new OpenLayers.Bounds(null, 50, 0, 0), position: new OpenLayers.Pixel(-1238, 0) }, { size: new OpenLayers.Size("auto", 19), anchor: new OpenLayers.Bounds(0, 32, 22, null), position: new OpenLayers.Pixel(0, -631) }, { size: new OpenLayers.Size(22, 19), anchor: new OpenLayers.Bounds(null, 32, 0, null), position: new OpenLayers.Pixel(-1238, -631) }, { size: new OpenLayers.Size(81, 35), anchor: new OpenLayers.Bounds(0, 0, null, null), position: new OpenLayers.Pixel(-215, -687) }] }, bl: { offset: new OpenLayers.Pixel(45, 0), padding: new OpenLayers.Bounds(8, 9, 8, 40), blocks: [{ size: new OpenLayers.Size("auto", "auto"), anchor: new OpenLayers.Bounds(0, 21, 22, 32), position: new OpenLayers.Pixel(0, 0) }, { size: new OpenLayers.Size(22, "auto"), anchor: new OpenLayers.Bounds(null, 21, 0, 32), position: new OpenLayers.Pixel(-1238, 0) }, { size: new OpenLayers.Size("auto", 21), anchor: new OpenLayers.Bounds(0, 0, 22, null), position: new OpenLayers.Pixel(0, -629) }, { size: new OpenLayers.Size(22, 21), anchor: new OpenLayers.Bounds(null, 0, 0, null), position: new OpenLayers.Pixel(-1238, -629) }, { size: new OpenLayers.Size(81, 33), anchor: new OpenLayers.Bounds(null, null, 0, 0), position: new OpenLayers.Pixel(-101, -674) }] }, br: { offset: new OpenLayers.Pixel(-44, 0), padding: new OpenLayers.Bounds(8, 9, 8, 40), blocks: [{ size: new OpenLayers.Size("auto", "auto"), anchor: new OpenLayers.Bounds(0, 21, 22, 32), position: new OpenLayers.Pixel(0, 0) }, { size: new OpenLayers.Size(22, "auto"), anchor: new OpenLayers.Bounds(null, 21, 0, 32), position: new OpenLayers.Pixel(-1238, 0) }, { size: new OpenLayers.Size("auto", 21), anchor: new OpenLayers.Bounds(0, 0, 22, null), position: new OpenLayers.Pixel(0, -629) }, { size: new OpenLayers.Size(22, 21), anchor: new OpenLayers.Bounds(null, 0, 0, null), position: new OpenLayers.Pixel(-1238, -629) }, { size: new OpenLayers.Size(81, 33), anchor: new OpenLayers.Bounds(0, null, null, 0), position: new OpenLayers.Pixel(-311, -674) }] } }, minSize: new OpenLayers.Size(105, 10), maxSize: new OpenLayers.Size(1200, 660), initialize: function (e, t, n, i, s, r, a) { this.imageSrc = OpenLayers.Util.getImageLocation("cloud-popup-relative.png"), OpenLayers.Popup.Framed.prototype.initialize.apply(this, arguments), this.contentDiv.className = this.contentDisplayClass }, CLASS_NAME: "OpenLayers.Popup.FramedCloud" }), OpenLayers.Rule = OpenLayers.Class({ id: null, name: null, title: null, description: null, context: null, filter: null, elseFilter: !1, symbolizer: null, symbolizers: null, minScaleDenominator: null, maxScaleDenominator: null, initialize: function (e) { this.symbolizer = {}, OpenLayers.Util.extend(this, e), this.symbolizers && delete this.symbolizer, this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_") }, destroy: function () { for (var e in this.symbolizer) this.symbolizer[e] = null; this.symbolizer = null, delete this.symbolizers }, evaluate: function (e) { var t = this.getContext(e), n = !0; if (this.minScaleDenominator || this.maxScaleDenominator) var i = e.layer.map.getScale(); return this.minScaleDenominator && (n = i >= OpenLayers.Style.createLiteral(this.minScaleDenominator, t)), n && this.maxScaleDenominator && (n = i < OpenLayers.Style.createLiteral(this.maxScaleDenominator, t)), n && this.filter && (n = "OpenLayers.Filter.FeatureId" == this.filter.CLASS_NAME ? this.filter.evaluate(e) : this.filter.evaluate(t)), n }, getContext: function (e) { var t = this.context; return t || (t = e.attributes || e.data), "function" == typeof this.context && (t = this.context(e)), t }, clone: function () { var e = OpenLayers.Util.extend({}, this); if (this.symbolizers) { var t = this.symbolizers.length; e.symbolizers = new Array(t); for (var n = 0; n < t; ++n)e.symbolizers[n] = this.symbolizers[n].clone() } else { var i, s; for (var r in e.symbolizer = {}, this.symbolizer) "object" === (s = typeof (i = this.symbolizer[r])) ? e.symbolizer[r] = OpenLayers.Util.extend({}, i) : "string" === s && (e.symbolizer[r] = i) } return e.filter = this.filter && this.filter.clone(), e.context = this.context && OpenLayers.Util.extend({}, this.context), new OpenLayers.Rule(e) }, CLASS_NAME: "OpenLayers.Rule" }), OpenLayers.Renderer.VML = OpenLayers.Class(OpenLayers.Renderer.Elements, { xmlns: "urn:schemas-microsoft-com:vml", symbolCache: {}, offset: null, initialize: function (e) { if (this.supported()) { if (!document.namespaces.olv) { document.namespaces.add("olv", this.xmlns); for (var t = document.createStyleSheet(), n = ["shape", "rect", "oval", "fill", "stroke", "imagedata", "group", "textbox"], i = 0, s = n.length; i < s; i++)t.addRule("olv\\:" + n[i], "behavior: url(#default#VML); position: absolute; display: inline-block;") } OpenLayers.Renderer.Elements.prototype.initialize.apply(this, arguments) } }, supported: function () { return !!document.namespaces }, setExtent: function (e, t) { var n = OpenLayers.Renderer.Elements.prototype.setExtent.apply(this, arguments), i = this.getResolution(), s = e.left / i | 0, r = e.top / i - this.size.h | 0; t || !this.offset ? (this.offset = { x: s, y: r }, s = 0, r = 0) : (s -= this.offset.x, r -= this.offset.y); var a = s - this.xOffset + " " + r; this.root.coordorigin = a; for (var o, l = [this.root, this.vectorRoot, this.textRoot], h = 0, p = l.length; h < p; ++h) { o = l[h]; var u = this.size.w + " " + this.size.h; o.coordsize = u } return this.root.style.flip = "y", n }, setSize: function (e) { OpenLayers.Renderer.prototype.setSize.apply(this, arguments); for (var t, n = [this.rendererRoot, this.root, this.vectorRoot, this.textRoot], i = this.size.w + "px", s = this.size.h + "px", r = 0, a = n.length; r < a; ++r)(t = n[r]).style.width = i, t.style.height = s }, getNodeType: function (e, t) { var n = null; switch (e.CLASS_NAME) { case "OpenLayers.Geometry.Point": n = t.externalGraphic ? "olv:rect" : this.isComplexSymbol(t.graphicName) ? "olv:shape" : "olv:oval"; break; case "OpenLayers.Geometry.Rectangle": n = "olv:rect"; break; case "OpenLayers.Geometry.LineString": case "OpenLayers.Geometry.LinearRing": case "OpenLayers.Geometry.Polygon": case "OpenLayers.Geometry.Curve": n = "olv:shape" }return n }, setStyle: function (e, t, n, i) { t = t || e._style, n = n || e._options; var s = t.fillColor, r = t.title || t.graphicTitle; if (r && (e.title = r), "OpenLayers.Geometry.Point" === e._geometryClass) if (t.externalGraphic) { n.isFilled = !0; var a = t.graphicWidth || t.graphicHeight, o = t.graphicHeight || t.graphicWidth; a = a || 2 * t.pointRadius, o = o || 2 * t.pointRadius; var l = this.getResolution(), h = null != t.graphicXOffset ? t.graphicXOffset : -.5 * a, p = null != t.graphicYOffset ? t.graphicYOffset : -.5 * o; e.style.left = ((i.x - this.featureDx) / l - this.offset.x + h | 0) + "px", e.style.top = (i.y / l - this.offset.y - (p + o) | 0) + "px", e.style.width = a + "px", e.style.height = o + "px", e.style.flip = "y", s = "none", n.isStroked = !1 } else if (this.isComplexSymbol(t.graphicName)) { var u = this.importSymbol(t.graphicName); e.path = u.path, e.coordorigin = u.left + "," + u.bottom; var y = u.size; e.coordsize = y + "," + y, this.drawCircle(e, i, t.pointRadius), e.style.flip = "y" } else this.drawCircle(e, i, t.pointRadius); n.isFilled ? e.fillcolor = s : e.filled = "false"; var c = e.getElementsByTagName("fill"), d = 0 == c.length ? null : c[0]; n.isFilled ? (d || (d = this.createNode("olv:fill", e.id + "_fill")), d.opacity = t.fillOpacity, "OpenLayers.Geometry.Point" === e._geometryClass && t.externalGraphic && (t.graphicOpacity && (d.opacity = t.graphicOpacity), d.src = t.externalGraphic, d.type = "frame", t.graphicWidth && t.graphicHeight || (d.aspect = "atmost")), d.parentNode != e && e.appendChild(d)) : d && e.removeChild(d); var f = t.rotation; void 0 === f && void 0 === e._rotation || (e._rotation = f, t.externalGraphic ? (this.graphicRotate(e, h, p, t), d.opacity = 0) : "OpenLayers.Geometry.Point" === e._geometryClass && (e.style.rotation = f || 0)); var m = e.getElementsByTagName("stroke"), g = 0 == m.length ? null : m[0]; return n.isStroked ? (g || (g = this.createNode("olv:stroke", e.id + "_stroke"), e.appendChild(g)), g.on = !0, g.color = t.strokeColor, g.weight = t.strokeWidth + "px", g.opacity = t.strokeOpacity, g.endcap = "butt" == t.strokeLinecap ? "flat" : t.strokeLinecap || "round", t.strokeDashstyle && (g.dashstyle = this.dashStyle(t))) : (e.stroked = !1, g && (g.on = !1)), "inherit" != t.cursor && null != t.cursor && (e.style.cursor = t.cursor), e }, graphicRotate: function (e, t, n, i) { var s, r, a = (i = i || e._style).rotation || 0; if (!i.graphicWidth || !i.graphicHeight) { var o = new Image; return o.onreadystatechange = OpenLayers.Function.bind(function () { "complete" != o.readyState && "interactive" != o.readyState || (s = o.width / o.height, r = Math.max(2 * i.pointRadius, i.graphicWidth || 0, i.graphicHeight || 0), t *= s, i.graphicWidth = r * s, i.graphicHeight = r, this.graphicRotate(e, t, n, i)) }, this), void (o.src = i.externalGraphic) } r = Math.max(i.graphicWidth, i.graphicHeight), s = i.graphicWidth / i.graphicHeight; var l = Math.round(i.graphicWidth || r * s), h = Math.round(i.graphicHeight || r); e.style.width = l + "px", e.style.height = h + "px"; var p = document.getElementById(e.id + "_image"); p || (p = this.createNode("olv:imagedata", e.id + "_image"), e.appendChild(p)), p.style.width = l + "px", p.style.height = h + "px", p.src = i.externalGraphic, p.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='', sizingMethod='scale')"; var u = a * Math.PI / 180, y = Math.sin(u), c = Math.cos(u), d = "progid:DXImageTransform.Microsoft.Matrix(M11=" + c + ",M12=" + -y + ",M21=" + y + ",M22=" + c + ",SizingMethod='auto expand')\n", f = i.graphicOpacity || i.fillOpacity; f && 1 != f && (d += "progid:DXImageTransform.Microsoft.BasicImage(opacity=" + f + ")\n"), e.style.filter = d; var m = new OpenLayers.Geometry.Point(-t, -n), g = new OpenLayers.Bounds(0, 0, l, h).toGeometry(); g.rotate(i.rotation, m); var L = g.getBounds(); e.style.left = Math.round(parseInt(e.style.left) + L.left) + "px", e.style.top = Math.round(parseInt(e.style.top) - L.bottom) + "px" }, postDraw: function (e) { e.style.visibility = "visible"; var t = e._style.fillColor, n = e._style.strokeColor; "none" == t && e.fillcolor != t && (e.fillcolor = t), "none" == n && e.strokecolor != n && (e.strokecolor = n) }, setNodeDimension: function (e, t) { var n = t.getBounds(); if (n) { var i = this.getResolution(), s = new OpenLayers.Bounds((n.left - this.featureDx) / i - this.offset.x | 0, n.bottom / i - this.offset.y | 0, (n.right - this.featureDx) / i - this.offset.x | 0, n.top / i - this.offset.y | 0); e.style.left = s.left + "px", e.style.top = s.top + "px", e.style.width = s.getWidth() + "px", e.style.height = s.getHeight() + "px", e.coordorigin = s.left + " " + s.top, e.coordsize = s.getWidth() + " " + s.getHeight() } }, dashStyle: function (e) { var t = e.strokeDashstyle; switch (t) { case "solid": case "dot": case "dash": case "dashdot": case "longdash": case "longdashdot": return t; default: var n = t.split(/[ ,]/); return 2 == n.length ? 1 * n[0] >= 2 * n[1] ? "longdash" : 1 == n[0] || 1 == n[1] ? "dot" : "dash" : 4 == n.length ? 1 * n[0] >= 2 * n[1] ? "longdashdot" : "dashdot" : "solid" } }, createNode: function (e, t) { var n = document.createElement(e); return t && (n.id = t), n.unselectable = "on", n.onselectstart = OpenLayers.Function.False, n }, nodeTypeCompare: function (e, t) { var n = t, i = n.indexOf(":"); -1 != i && (n = n.substr(i + 1)); var s = e.nodeName; return -1 != (i = s.indexOf(":")) && (s = s.substr(i + 1)), n == s }, createRenderRoot: function () { return this.nodeFactory(this.container.id + "_vmlRoot", "div") }, createRoot: function (e) { return this.nodeFactory(this.container.id + e, "olv:group") }, drawPoint: function (e, t) { return this.drawCircle(e, t, 1) }, drawCircle: function (e, t, n) { if (!isNaN(t.x) && !isNaN(t.y)) { var i = this.getResolution(); e.style.left = ((t.x - this.featureDx) / i - this.offset.x | 0) - n + "px", e.style.top = (t.y / i - this.offset.y | 0) - n + "px"; var s = 2 * n; return e.style.width = s + "px", e.style.height = s + "px", e } return !1 }, drawLineString: function (e, t) { return this.drawLine(e, t, !1) }, drawLinearRing: function (e, t) { return this.drawLine(e, t, !0) }, drawLine: function (e, t, n) { this.setNodeDimension(e, t); for (var i, s, r, a = this.getResolution(), o = t.components.length, l = new Array(o), h = 0; h < o; h++)s = ((i = t.components[h]).x - this.featureDx) / a - this.offset.x | 0, r = i.y / a - this.offset.y | 0, l[h] = " " + s + "," + r + " l "; var p = n ? " x e" : " e"; return e.path = "m" + l.join("") + p, e }, drawPolygon: function (e, t) { this.setNodeDimension(e, t); var n, i, s, r, a, o, l, h, p, u, y = this.getResolution(), c = []; for (n = 0, i = t.components.length; n < i; n++) { for (c.push("m"), r = 0 === n, a = null, o = null, l = 0, h = (s = t.components[n].components).length; l < h; l++)u = " " + (((p = s[l]).x - this.featureDx) / y - this.offset.x | 0) + "," + (p.y / y - this.offset.y | 0), c.push(u), 0 == l && c.push(" l"), r || (a ? a != u && (o ? o != u && (r = !0) : o = u) : a = u); c.push(r ? " x " : " ") } return c.push("e"), e.path = c.join(""), e }, drawRectangle: function (e, t) { var n = this.getResolution(); return e.style.left = ((t.x - this.featureDx) / n - this.offset.x | 0) + "px", e.style.top = (t.y / n - this.offset.y | 0) + "px", e.style.width = (t.width / n | 0) + "px", e.style.height = (t.height / n | 0) + "px", e }, drawText: function (e, t, n) { var i = this.nodeFactory(e + this.LABEL_ID_SUFFIX, "olv:rect"), s = this.nodeFactory(e + this.LABEL_ID_SUFFIX + "_textbox", "olv:textbox"), r = this.getResolution(); i.style.left = ((n.x - this.featureDx) / r - this.offset.x | 0) + "px", i.style.top = (n.y / r - this.offset.y | 0) + "px", i.style.flip = "y", s.innerText = t.label, "inherit" != t.cursor && null != t.cursor && (s.style.cursor = t.cursor), t.fontColor && (s.style.color = t.fontColor), t.fontOpacity && (s.style.filter = "alpha(opacity=" + 100 * t.fontOpacity + ")"), t.fontFamily && (s.style.fontFamily = t.fontFamily), t.fontSize && (s.style.fontSize = t.fontSize), t.fontWeight && (s.style.fontWeight = t.fontWeight), t.fontStyle && (s.style.fontStyle = t.fontStyle), !0 === t.labelSelect && (i._featureId = e, s._featureId = e, s._geometry = n, s._geometryClass = n.CLASS_NAME), s.style.whiteSpace = "nowrap", s.inset = "1px,0px,0px,0px", i.parentNode || (i.appendChild(s), this.textRoot.appendChild(i)); var a = t.labelAlign || "cm"; 1 == a.length && (a += "m"); var o = s.clientWidth * OpenLayers.Renderer.VML.LABEL_SHIFT[a.substr(0, 1)], l = s.clientHeight * OpenLayers.Renderer.VML.LABEL_SHIFT[a.substr(1, 1)]; i.style.left = parseInt(i.style.left) - o - 1 + "px", i.style.top = parseInt(i.style.top) + l + "px" }, moveRoot: function (e) { var t = this.map.getLayer(e.container.id); t instanceof OpenLayers.Layer.Vector.RootContainer && (t = this.map.getLayer(this.container.id)), t && t.renderer.clear(), OpenLayers.Renderer.Elements.prototype.moveRoot.apply(this, arguments), t && t.redraw() }, importSymbol: function (e) { var t = this.container.id + "-" + e, n = this.symbolCache[t]; if (n) return n; var i = OpenLayers.Renderer.symbol[e]; if (!i) throw new Error(e + " is not a valid symbol name"); for (var s = new OpenLayers.Bounds(Number.MAX_VALUE, Number.MAX_VALUE, 0, 0), r = ["m"], a = 0; a < i.length; a += 2) { var o = i[a], l = i[a + 1]; s.left = Math.min(s.left, o), s.bottom = Math.min(s.bottom, l), s.right = Math.max(s.right, o), s.top = Math.max(s.top, l), r.push(o), r.push(l), 0 == a && r.push("l") } r.push("x e"); var h = r.join(" "), p = (s.getWidth() - s.getHeight()) / 2; return p > 0 ? (s.bottom = s.bottom - p, s.top = s.top + p) : (s.left = s.left + p, s.right = s.right - p), n = { path: h, size: s.getWidth(), left: s.left, bottom: s.bottom }, this.symbolCache[t] = n, n }, CLASS_NAME: "OpenLayers.Renderer.VML" }), OpenLayers.Renderer.VML.LABEL_SHIFT = { l: 0, c: .5, r: 1, t: 0, m: .5, b: 1 }, OpenLayers.Protocol = OpenLayers.Class({ format: null, options: null, autoDestroy: !0, defaultFilter: null, initialize: function (e) { e = e || {}, OpenLayers.Util.extend(this, e), this.options = e }, mergeWithDefaultFilter: function (e) { return e && this.defaultFilter ? new OpenLayers.Filter.Logical({ type: OpenLayers.Filter.Logical.AND, filters: [this.defaultFilter, e] }) : e || this.defaultFilter || void 0 }, destroy: function () { this.options = null, this.format = null }, read: function (e) { (e = e || {}).filter = this.mergeWithDefaultFilter(e.filter) }, create: function () { }, update: function () { }, delete: function () { }, commit: function () { }, abort: function (e) { }, createCallback: function (e, t, n) { return OpenLayers.Function.bind(function () { e.apply(this, [t, n]) }, this) }, CLASS_NAME: "OpenLayers.Protocol" }), OpenLayers.Protocol.Response = OpenLayers.Class({ code: null, requestType: null, last: !0, features: null, data: null, reqFeatures: null, priv: null, error: null, initialize: function (e) { OpenLayers.Util.extend(this, e) }, success: function () { return this.code > 0 }, CLASS_NAME: "OpenLayers.Protocol.Response" }), OpenLayers.Protocol.Response.SUCCESS = 1, OpenLayers.Protocol.Response.FAILURE = 0, OpenLayers.Protocol.HTTP = OpenLayers.Class(OpenLayers.Protocol, { url: null, headers: null, params: null, callback: null, scope: null, readWithPOST: !1, updateWithPOST: !1, deleteWithPOST: !1, wildcarded: !1, srsInBBOX: !1, initialize: function (e) { if (e = e || {}, this.params = {}, this.headers = {}, OpenLayers.Protocol.prototype.initialize.apply(this, arguments), !this.filterToParams && OpenLayers.Format.QueryStringFilter) { var t = new OpenLayers.Format.QueryStringFilter({ wildcarded: this.wildcarded, srsInBBOX: this.srsInBBOX }); this.filterToParams = function (e, n) { return t.write(e, n) } } }, destroy: function () { this.params = null, this.headers = null, OpenLayers.Protocol.prototype.destroy.apply(this) }, read: function (e) { OpenLayers.Protocol.prototype.read.apply(this, arguments), (e = e || {}).params = OpenLayers.Util.applyDefaults(e.params, this.options.params), (e = OpenLayers.Util.applyDefaults(e, this.options)).filter && this.filterToParams && (e.params = this.filterToParams(e.filter, e.params)); var t = void 0 !== e.readWithPOST ? e.readWithPOST : this.readWithPOST, n = new OpenLayers.Protocol.Response({ requestType: "read" }); if (t) { var i = e.headers || {}; i["Content-Type"] = "application/x-www-form-urlencoded", n.priv = OpenLayers.Request.POST({ url: e.url, callback: this.createCallback(this.handleRead, n, e), data: OpenLayers.Util.getParameterString(e.params), headers: i }) } else n.priv = OpenLayers.Request.GET({ url: e.url, callback: this.createCallback(this.handleRead, n, e), params: e.params, headers: e.headers }); return n }, handleRead: function (e, t) { this.handleResponse(e, t) }, create: function (e, t) { t = OpenLayers.Util.applyDefaults(t, this.options); var n = new OpenLayers.Protocol.Response({ reqFeatures: e, requestType: "create" }); return n.priv = OpenLayers.Request.POST({ url: t.url, callback: this.createCallback(this.handleCreate, n, t), headers: t.headers, data: this.format.write(e) }), n }, handleCreate: function (e, t) { this.handleResponse(e, t) }, update: function (e, t) { var n = (t = t || {}).url || e.url || this.options.url + "/" + e.fid; t = OpenLayers.Util.applyDefaults(t, this.options); var i = new OpenLayers.Protocol.Response({ reqFeatures: e, requestType: "update" }), s = this.updateWithPOST ? "POST" : "PUT"; return i.priv = OpenLayers.Request[s]({ url: n, callback: this.createCallback(this.handleUpdate, i, t), headers: t.headers, data: this.format.write(e) }), i }, handleUpdate: function (e, t) { this.handleResponse(e, t) }, delete: function (e, t) { var n = (t = t || {}).url || e.url || this.options.url + "/" + e.fid; t = OpenLayers.Util.applyDefaults(t, this.options); var i = new OpenLayers.Protocol.Response({ reqFeatures: e, requestType: "delete" }), s = this.deleteWithPOST ? "POST" : "DELETE", r = { url: n, callback: this.createCallback(this.handleDelete, i, t), headers: t.headers }; return this.deleteWithPOST && (r.data = this.format.write(e)), i.priv = OpenLayers.Request[s](r), i }, handleDelete: function (e, t) { this.handleResponse(e, t) }, handleResponse: function (e, t) { var n = e.priv; t.callback && (n.status >= 200 && n.status < 300 ? ("delete" != e.requestType && (e.features = this.parseFeatures(n)), e.code = OpenLayers.Protocol.Response.SUCCESS) : e.code = OpenLayers.Protocol.Response.FAILURE, t.callback.call(t.scope, e)) }, parseFeatures: function (e) { var t = e.responseXML; return t && t.documentElement || (t = e.responseText), !t || t.length <= 0 ? null : this.format.read(t) }, commit: function (e, t) { t = OpenLayers.Util.applyDefaults(t, this.options); var n = [], i = 0, s = {}; s[OpenLayers.State.INSERT] = [], s[OpenLayers.State.UPDATE] = [], s[OpenLayers.State.DELETE] = []; for (var r, a, o = [], l = 0, h = e.length; l < h; ++l)(a = s[(r = e[l]).state]) && (a.push(r), o.push(r)); var p = (s[OpenLayers.State.INSERT].length > 0 ? 1 : 0) + s[OpenLayers.State.UPDATE].length + s[OpenLayers.State.DELETE].length, u = !0, y = new OpenLayers.Protocol.Response({ reqFeatures: o }); function c(e) { this.callUserCallback(e, t), u = u && e.success(), ++i >= p && t.callback && (y.code = u ? OpenLayers.Protocol.Response.SUCCESS : OpenLayers.Protocol.Response.FAILURE, t.callback.apply(t.scope, [y])) } var d = s[OpenLayers.State.INSERT]; d.length > 0 && n.push(this.create(d, OpenLayers.Util.applyDefaults({ callback: function (e) { for (var t = e.features ? e.features.length : 0, n = new Array(t), i = 0; i < t; ++i)n[i] = e.features[i].fid; y.insertIds = n, c.apply(this, [e]) }, scope: this }, t.create))); for (l = (d = s[OpenLayers.State.UPDATE]).length - 1; l >= 0; --l)n.push(this.update(d[l], OpenLayers.Util.applyDefaults({ callback: c, scope: this }, t.update))); for (l = (d = s[OpenLayers.State.DELETE]).length - 1; l >= 0; --l)n.push(this.delete(d[l], OpenLayers.Util.applyDefaults({ callback: c, scope: this }, t.delete))); return n }, abort: function (e) { e && e.priv.abort() }, callUserCallback: function (e, t) { var n = t[e.requestType]; n && n.callback && n.callback.call(n.scope, e) }, CLASS_NAME: "OpenLayers.Protocol.HTTP" }), OpenLayers.Control.LayerSwitcher = OpenLayers.Class(OpenLayers.Control, { layerStates: null, layersDiv: null, baseLayersDiv: null, baseLayers: null, dataLbl: null, dataLayersDiv: null, dataLayers: null, minimizeDiv: null, maximizeDiv: null, ascending: !0, initialize: function (e) { OpenLayers.Control.prototype.initialize.apply(this, arguments), this.layerStates = [] }, destroy: function () { this.clearLayersArray("base"), this.clearLayersArray("data"), this.map.events.un({ buttonclick: this.onButtonClick, addlayer: this.redraw, changelayer: this.redraw, removelayer: this.redraw, changebaselayer: this.redraw, scope: this }), this.events.unregister("buttonclick", this, this.onButtonClick), OpenLayers.Control.prototype.destroy.apply(this, arguments) }, setMap: function (e) { OpenLayers.Control.prototype.setMap.apply(this, arguments), this.map.events.on({ addlayer: this.redraw, changelayer: this.redraw, removelayer: this.redraw, changebaselayer: this.redraw, scope: this }), this.outsideViewport ? (this.events.attachToElement(this.div), this.events.register("buttonclick", this, this.onButtonClick)) : this.map.events.register("buttonclick", this, this.onButtonClick) }, draw: function () { return OpenLayers.Control.prototype.draw.apply(this), this.loadContents(), this.outsideViewport || this.minimizeControl(), this.redraw(), this.div }, onButtonClick: function (e) { var t = e.buttonElement; t === this.minimizeDiv ? this.minimizeControl() : t === this.maximizeDiv ? this.maximizeControl() : t._layerSwitcher === this.id && (t.for && (t = document.getElementById(t.for)), t.disabled || ("radio" == t.type ? (t.checked = !0, this.map.setBaseLayer(this.map.getLayer(t._layer))) : (t.checked = !t.checked, this.updateMap()))) }, clearLayersArray: function (e) { this[e + "LayersDiv"].innerHTML = "", this[e + "Layers"] = [] }, checkRedraw: function () { if (!this.layerStates.length || this.map.layers.length != this.layerStates.length) return !0; for (var e = 0, t = this.layerStates.length; e < t; e++) { var n = this.layerStates[e], i = this.map.layers[e]; if (n.name != i.name || n.inRange != i.inRange || n.id != i.id || n.visibility != i.visibility) return !0 } return !1 }, redraw: function () { if (!this.checkRedraw()) return this.div; this.clearLayersArray("base"), this.clearLayersArray("data"); var e = !1, t = !1, n = this.map.layers.length; this.layerStates = new Array(n); for (var i = 0; i < n; i++) { var s = this.map.layers[i]; this.layerStates[i] = { name: s.name, visibility: s.visibility, inRange: s.inRange, id: s.id } } var r = this.map.layers.slice(); this.ascending || r.reverse(); for (i = 0, n = r.length; i < n; i++) { var a = (s = r[i]).isBaseLayer; if (s.displayInLayerSwitcher) { a ? t = !0 : e = !0; var o = a ? s == this.map.baseLayer : s.getVisibility(), l = document.createElement("input"), h = OpenLayers.Util.createUniqueID(this.id + "_input_"); l.id = h, l.name = a ? this.id + "_baseLayers" : s.name, l.type = a ? "radio" : "checkbox", l.value = s.name, l.checked = o, l.defaultChecked = o, l.className = "olButton", l._layer = s.id, l._layerSwitcher = this.id, a || s.inRange || (l.disabled = !0); var p = document.createElement("label"); p.for = l.id, OpenLayers.Element.addClass(p, "labelSpan olButton"), p._layer = s.id, p._layerSwitcher = this.id, a || s.inRange || (p.style.color = "gray"), p.innerHTML = s.name, p.style.verticalAlign = a ? "bottom" : "baseline"; var u = document.createElement("br"); (a ? this.baseLayers : this.dataLayers).push({ layer: s, inputElem: l, labelSpan: p }); var y = a ? this.baseLayersDiv : this.dataLayersDiv; y.appendChild(l), y.appendChild(p), y.appendChild(u) } } return this.dataLbl.style.display = e ? "" : "none", this.baseLbl.style.display = t ? "" : "none", this.div }, updateMap: function () { for (var e = 0, t = this.baseLayers.length; e < t; e++) { (n = this.baseLayers[e]).inputElem.checked && this.map.setBaseLayer(n.layer, !1) } for (e = 0, t = this.dataLayers.length; e < t; e++) { var n; (n = this.dataLayers[e]).layer.setVisibility(n.inputElem.checked) } }, maximizeControl: function (e) { this.div.style.width = "", this.div.style.height = "", this.showControls(!1), null != e && OpenLayers.Event.stop(e) }, minimizeControl: function (e) { this.div.style.width = "0px", this.div.style.height = "0px", this.showControls(!0), null != e && OpenLayers.Event.stop(e) }, showControls: function (e) { this.maximizeDiv.style.display = e ? "" : "none", this.minimizeDiv.style.display = e ? "none" : "", this.layersDiv.style.display = e ? "none" : "" }, loadContents: function () { this.layersDiv = document.createElement("div"), this.layersDiv.id = this.id + "_layersDiv", OpenLayers.Element.addClass(this.layersDiv, "layersDiv"), this.baseLbl = document.createElement("div"), this.baseLbl.innerHTML = OpenLayers.i18n("Base Layer"), OpenLayers.Element.addClass(this.baseLbl, "baseLbl"), this.baseLayersDiv = document.createElement("div"), OpenLayers.Element.addClass(this.baseLayersDiv, "baseLayersDiv"), this.dataLbl = document.createElement("div"), this.dataLbl.innerHTML = OpenLayers.i18n("Overlays"), OpenLayers.Element.addClass(this.dataLbl, "dataLbl"), this.dataLayersDiv = document.createElement("div"), OpenLayers.Element.addClass(this.dataLayersDiv, "dataLayersDiv"), this.ascending ? (this.layersDiv.appendChild(this.baseLbl), this.layersDiv.appendChild(this.baseLayersDiv), this.layersDiv.appendChild(this.dataLbl), this.layersDiv.appendChild(this.dataLayersDiv)) : (this.layersDiv.appendChild(this.dataLbl), this.layersDiv.appendChild(this.dataLayersDiv), this.layersDiv.appendChild(this.baseLbl), this.layersDiv.appendChild(this.baseLayersDiv)), this.div.appendChild(this.layersDiv); var e = OpenLayers.Util.getImageLocation("layer-switcher-maximize.png"); this.maximizeDiv = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_MaximizeDiv", null, null, e, "absolute"), OpenLayers.Element.addClass(this.maximizeDiv, "maximizeDiv olButton"), this.maximizeDiv.style.display = "none", this.div.appendChild(this.maximizeDiv); e = OpenLayers.Util.getImageLocation("layer-switcher-minimize.png"); this.minimizeDiv = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_MinimizeDiv", null, null, e, "absolute"), OpenLayers.Element.addClass(this.minimizeDiv, "minimizeDiv olButton"), this.minimizeDiv.style.display = "none", this.div.appendChild(this.minimizeDiv) }, CLASS_NAME: "OpenLayers.Control.LayerSwitcher" });