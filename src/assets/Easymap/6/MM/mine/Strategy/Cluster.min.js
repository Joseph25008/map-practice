EzMap.Strategy.Cluster = OpenLayers.Class(OpenLayers.Strategy, { distance: 20, threshold: null, features: null, clusters: null, clustering: !1, markerLayerName: "", markers: null, map: null, mm: null, gmarker: null, resolution: null, activate: function () { this.map || (this.map = this.layer.map), this.markerLayerName = "MM_STRATEGY_CLUSTER_MARKERS_" + this.map.layers.length, this.markers = new OpenLayers.Layer.Markers(this.markerLayerName), this.map.addLayer(this.markers); var t = OpenLayers.Strategy.prototype.activate.call(this); return t && this.layer.events.on({ beforefeaturesadded: this.cacheFeatures, featuresremoved: this.clearCache, moveend: this.cluster, scope: this }), t }, deactivate: function () { var t = this.map.getLayersByName(this.markerLayerName); if (t.length >= 1) { var e = this.map.getLayersByName(this.markerLayerName)[0]; this.map.removeLayer(e) } var r = OpenLayers.Strategy.prototype.deactivate.call(this); return r && (this.clearCache(), this.layer.events.un({ beforefeaturesadded: this.cacheFeatures, featuresremoved: this.clearCache, moveend: this.cluster, scope: this })), r }, cacheFeatures: function (t) { var e = !0; return this.clustering || (this.clearCache(), this.features = t.features, this.cluster(), e = !1), e }, clearCache: function () { this.clustering || (this.features = null) }, cluster: function (t) { this.gmarker.isCusterZoom && (this.map.getZoom() >= this.gmarker.zoom ? this.distance = -1 : this.distance = this.gmarker.distance); for (var e = this.map.getExtent(), r = [], s = 0; s < this.features.length; ++s) { var i = this.features[s]; N = i.geometry.x, z = i.geometry.y, N < e.left || N > e.right || z < e.bottom || z > e.top || r.push(i) } if ((!t || 1 == t.zoomChanged || 0 == t.zoomChanged) && this.features) { var a = this.layer.map.getResolution(); if (a != this.resolution || a == this.resolution || !this.clustersExist()) { this.resolution = a; for (var i, o, h, l = [], s = 0; s < r.length; ++s) if (i = r[s], i.geometry) { o = !1; for (var n = l.length - 1; n >= 0; --n) if (h = l[n], this.shouldCluster(h, i)) { this.addToCluster(h, i), o = !0; break } o || l.push(this.createCluster(r[s])) } this.clustering = !0, this.layer.removeAllFeatures(); for (var s = this.markers.markers.length - 1; s >= 0; s--) this.markers.removeMarker(this.markers.markers[s]); if (this.clustering = !1, l.length > 0) { if (this.threshold > 1) { var u = l.slice(); l = []; for (var m, s = 0, g = u.length; g > s; ++s) m = u[s], m.attributes.count < this.threshold ? Array.prototype.push.apply(l, m.cluster) : l.push(m) } this.clustering = !0, this.layer.addFeatures(l); var c = 0, p = ("<div><img src='" + this.mm.root + "imgs/icon03.png'/></div>", "<div style='position:absolute;left:0px;top:0px;'>{0}</div>"), d = "<div style='color:white;font-size:10px;font-weight:bold;position:absolute;left:20px;top:20px;z-index:1;'>{0}</div>"; d = "<div class='GIS_CLUSTER_HTML_DIV' style='left:-29px;top:-29px;width:58px;height:58px;line-height:58px;text-align:center;margin-left:auto;margin-right:auto;padding-left:auto;padding-right:auto;color:white;font-size:10px;font-weight:bold;position:absolute;z-index:1;'>{0}</div>"; var f = d, y = d, v = d, k = 100, L = 20, C = "<img src='" + this.mm.root + "imgs/nuclear-y.png' width='58' height='58'/>", x = "<img src='" + this.mm.root + "imgs/nuclear-b.png' width='58' height='58'/>", w = "<img src='" + this.mm.root + "imgs/nuclear-g.png' width='58' height='58'/>", M = this.gmarker.role; null != M && (EzMap.Tools.isNumber(M.high) && (k = M.high), EzMap.Tools.isNumber(M.medium) && (L = M.medium), M.picHigh && (C = M.picHigh), M.picMedium && (x = M.picMedium), M.picLow && (w = M.picLow), M.texttagHigh && (f = M.texttagHigh), M.texttagHigh && (y = M.texttagMedium), M.texttagHigh && (v = M.texttagLow)); for (var b = "", S = "", E = "", N = 0, z = 0, e = 0, O = null, s = 0; s < l.length; s++) if (e = this.map.getExtent(), N = l[s].geometry.x, z = l[s].geometry.y, !(N < e.left || N > e.right || z < e.bottom || z > e.top)) { !l[s].cluster || l[s].cluster.length <= 1 ? S = null == l[s].dgmarker.iconObject ? l[s].dgmarker.htmlstr : "<img src='" + l[s].dgmarker.iconObject.image.src + "'/>" : (c = l[s].cluster.length, L >= c ? (b = String.format(p, w, 46), E = v) : c > L && k >= c ? (b = String.format(p, x, 58), E = y) : (b = String.format(p, C, 62), E = f), S = "<div>" + E + b + "</div>", S = String.format(S, c)), O = l[s].geometry.getBounds().getCenterLonLat(), b = new EzMap.HtmlStr(S, this.mm), b.imageDiv.className = s; var G = new OpenLayers.Marker(new OpenLayers.LonLat(O.lon, O.lat), b); G.events.on({ click: function (t) { if (null != this.gmarker.click) { var e = this.getCluster(t), r = this.getGroup(t); this.gmarker.click(e, r) } }, mouseover: function (t) { if (null != this.gmarker.mouseover) { var e = this.getCluster(t), r = this.getGroup(t); this.gmarker.mouseover(e, r) } }, mouseout: function (t) { if (null != this.gmarker.mouseout) { var e = this.getCluster(t), r = this.getGroup(t); this.gmarker.mouseout(e, r) } }, mousedown: function (t) { if (null != this.gmarker.mousedown) { var e = this.getCluster(t), r = this.getGroup(t); this.gmarker.mousedown(e, r) } }, scope: this }), this.markers.addMarker(G) } this.clustering = !1 } this.clusters = l } } }, getGroup: function (t) { var e = t.element.className, r = this.clusters[e], s = this.mm.toWGS84(r.geometry.x, r.geometry.y), i = {}; return i.x = s.lon, i.y = s.lat, i }, getCluster: function (t) { var e = t.element.className, r = this.clusters[e], s = []; if (r.cluster) for (var i = 0; i < r.cluster.length; i++) s.push(r.cluster[i].dgmarker); else s.push(r.dgmarker); return s }, clustersExist: function () { var t = !1; if (this.clusters && this.clusters.length > 0 && this.clusters.length == this.layer.features.length) { t = !0; for (var e = 0; e < this.clusters.length; ++e) if (this.clusters[e] != this.layer.features[e]) { t = !1; break } } return t }, shouldCluster: function (t, e) { var r = t.geometry.getBounds().getCenterLonLat(), s = e.geometry.getBounds().getCenterLonLat(), i = Math.sqrt(Math.pow(r.lon - s.lon, 2) + Math.pow(r.lat - s.lat, 2)) / this.resolution; return i <= this.distance }, addToCluster: function (t, e) { t.cluster.push(e), t.attributes.count += 1 }, createCluster: function (t) { var e = t.geometry.getBounds().getCenterLonLat(), r = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Point(e.lon, e.lat), { count: 1 }); return r.cluster = [t], r }, CLASS_NAME: "MM.Strategy.Cluster" });