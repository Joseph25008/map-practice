EzMap.Format.KML = OpenLayers.Class(OpenLayers.Format.KML, { initialize: function (e) { this.regExes = { trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+|\t+/, trimComma: /\s*,\s*/g, kmlColor: /(\w{2})(\w{2})(\w{2})(\w{2})/, kmlIconPalette: /root:\/\/icons\/palette-(\d+)(\.\w+)/, straightBracket: /\$\[(.*?)\]/g }, this.externalProjection = new OpenLayers.Projection("EPSG:4326"), OpenLayers.Format.XML.prototype.initialize.apply(this, [e]) }, parseFeature: function (e) { for (var t, r, n, s, a = ["MultiGeometry", "Polygon", "LineString", "Point"], i = 0, l = a.length; l > i; ++i) if (t = a[i], this.internalns = e.namespaceURI ? e.namespaceURI : this.kmlns, r = this.getElementsByTagNameNS(e, this.internalns, t), r.length > 0) { var s = this.parseGeometry[t.toLowerCase()]; s ? (n = s.apply(this, [r[0]]), this.internalProjection && this.externalProjection && n.transform(this.externalProjection, this.internalProjection)) : console.error("Unsupported geometry type: " + t); break } var o; this.extractAttributes && (o = this.parseAttributes(e)); var y = new OpenLayers.Feature.Vector(n, o), p = e.getAttribute("id") || e.getAttribute("name"); return null != p && (y.fid = p), y.type = t, y }, parseFeatures: function (e, t) { for (var r = [], n = 0, s = e.length; s > n; n++) { var a = e[n], i = this.parseFeature.apply(this, [a]); if (i) { if (this.extractStyles && i.attributes && i.attributes.styleUrl && (i.style = this.getStyle(i.attributes.styleUrl, t), i.attributes.name && i.attributes.name.length >= 1 && ("MultiGeometry" == i.type || "Polygon" == i.type || "Point" == i.type) && (this.labelVisible && 1 == this.labelVisible && (i.style.label = i.attributes.name), i.style.fontWeight = "bold", i.style.fontColor = "#3C89C5", i.style.fontSize = "13px", i.style.labelAlign = "cm", i.style.pointRadius = 0, i.style.labelXOffset = 0, i.style.labelYOffset = 0, i.style.labelSelect = !0, i.style.labelOutlineColor = "#ffffff", i.style.labelOutlineWidth = 2)), this.extractStyles) { var l = this.getElementsByTagNameNS(a, "*", "Style")[0]; if (l) { var o = this.parseStyle(l); o && (i.style = OpenLayers.Util.extend(i.style, o)) } } if (this.extractTracks) { var y = this.getElementsByTagNameNS(a, this.namespaces.gx, "Track"); if (y && y.length > 0) { var p = y[0], h = { features: [], feature: i }; this.readNode(p, h), h.features.length > 0 && r.push.apply(r, h.features) } } else r.push(i) } else console.error("Bad Placemark: " + n) } this.features = this.features.concat(r) }, parseGeometry: { point: function (e) { var t = this.getElementsByTagNameNS(e, this.internalns, "coordinates"), r = []; if (t.length > 0) { var n = t[0].firstChild.nodeValue; n = n.replace(this.regExes.removeSpace, ""), r = n.split(",") } var s = null; return r.length > 1 ? (2 == r.length && (r[2] = null), s = new OpenLayers.Geometry.Point(r[0], r[1], r[2])) : console.error("Bad coordinate string: " + n), s }, linestring: function (e, t) { var r = this.getElementsByTagNameNS(e, this.internalns, "coordinates"), n = null; if (r.length > 0) { var s = this.getChildValue(r[0]); s = s.replace(this.regExes.trimSpace, ""), s = s.replace(this.regExes.trimComma, ","); for (var a, i, l = s.split(this.regExes.splitSpace), o = l.length, y = new Array(o), p = 0; s && s.length >= 1 && o > p; ++p) a = l[p].split(","), i = a.length, i > 1 ? (2 == a.length && (a[2] = null), y[p] = new OpenLayers.Geometry.Point(a[0], a[1], a[2])) : console.error("Bad LineString point coordinates: " + l[p]); o ? n = t ? new OpenLayers.Geometry.LinearRing(y) : new OpenLayers.Geometry.LineString(y) : console.error("Bad LineString coordinates: " + s) } return n }, polygon: function (e) { var t = this.getElementsByTagNameNS(e, this.internalns, "LinearRing"), r = t.length, n = new Array(r); if (r > 0) for (var s, a = 0, i = t.length; i > a; ++a) s = this.parseGeometry.linestring.apply(this, [t[a], !0]), s ? n[a] = s : console.error("Bad LinearRing geometry: " + a); return new OpenLayers.Geometry.Polygon(n) }, multigeometry: function (e) { for (var t, r, n = [], s = e.childNodes, a = 0, i = s.length; i > a; ++a) if (t = s[a], 1 == t.nodeType) { var l = t.prefix ? t.nodeName.split(":")[1] : t.nodeName, r = this.parseGeometry[l.toLowerCase()]; r && n.push(r.apply(this, [t])) } return new OpenLayers.Geometry.Collection(n) } }, CLASS_NAME: "MM.Format.KML" });