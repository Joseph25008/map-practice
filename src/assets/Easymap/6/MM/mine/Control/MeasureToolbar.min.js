EzMap.Control.MeasureToolbar = OpenLayers.Class(OpenLayers.Control.Panel, { iconProxy: "", measureCallbacks: null, citeCompliant: !1, mm: null, layer: null, markerLayer: null, nav: null, point: null, path: null, polygon: null, circle: null, rectangle: null, drawRval: [], drawRobj: null, rfunc: null, afunc: null, useControl: null, useControlName: "", mouseEvent: null, initialize: function (e, t) { this.mm = e, OpenLayers.Control.Panel.prototype.initialize.apply(this, [t]); var n = OpenLayers.Util.getParameters(window.location.href).renderer; n = n ? [n] : OpenLayers.Layer.Vector.prototype.renderers, this.nav = new OpenLayers.Control.Navigation({ id: "_MeasureToolbar_NAV_" }), this.mm.map.addControl(this.nav), this.layer = new OpenLayers.Layer.Vector("_MM_LAYER_MEASURE_", { styleMap: this.getStyleMap(), rendererOptions: { zIndexing: !0 } }), this.markerLayer = new OpenLayers.Layer.Markers("_MM_MARKERS_MEASURE_"), this.mm.map.addLayers([this.layer, this.markerLayer]); var r = this, a = { persist: !0, callbacks: { done: function (e, t) { r.rfunc_handler(r, e) }, point: function (e, t) { r.afunc_handler(r, e, event) }, move: function (e, t) { r.afunc_handler(r, e, event) } }, handlerOptions: { freehand: !1 } }; this.path = new OpenLayers.Control.DrawFeature(this.layer, OpenLayers.Handler.Path, a), this.polygon = new OpenLayers.Control.DrawFeature(this.layer, OpenLayers.Handler.Polygon, a), this.circle = new OpenLayers.Control.DrawFeature(this.layer, OpenLayers.Handler.RegularPolygon, a), this.rectangle = new OpenLayers.Control.DrawFeature(this.layer, OpenLayers.Handler.RegularPolygon, a), this.circle.handler.setOptions({ sides: parseInt(120) }), this.rectangle.handler.setOptions({ sides: parseInt(4) }); var o = { point: new OpenLayers.Control.DrawFeature(this.layer, OpenLayers.Handler.Point), path: this.path, polygon: this.polygon, circle: this.circle, rectangle: this.rectangle, box: new OpenLayers.Control.DrawFeature(this.layer, OpenLayers.Handler.RegularPolygon, { handlerOptions: { sides: 4, irregular: !0 } }) }; for (var s in o) this.mm.map.addControl(o[s]) }, clearMarker: function () { }, clearDrawLastOne: function () { if (this.layer.features.length >= 1) { var e = this.layer.features[this.layer.features.length - 1]; this.layer.removeFeatures(e) } }, clearDraw: function () { this.layer.removeAllFeatures(); for (var e = this.markerLayer.markers.length - 1; e >= 0; e--) this.markerLayer.removeMarker(this.markerLayer.markers[e]); var t = null; document.getElementById("MM_Control_MeasureToolbar_DrawResult") && (t = document.getElementById("MM_Control_MeasureToolbar_DrawResult"), document.body.removeChild(t)) }, setActiveControl: function (e, t, n) { null == t && null == n ? (this.rfunc = this.defaultRFunc, this.afunc = this.defaultAFunc) : (this.rfunc = t, this.afunc = n), this.drawRval = [], this.path.active && this.path.deactivate(), this.polygon.active && this.polygon.deactivate(), this.circle.active && this.circle.deactivate(), this.rectangle.active && this.rectangle.deactivate(); var r = null; switch (e) { case "NAV": break; case "polyline": r = this.path; break; case "polygon": r = this.polygon; break; case "circle": r = this.circle; break; case "rectangle": r = this.rectangle } this.useControlName = e, r.activate(), null != r && (this.useControl = r) }, getDistanceFromLatLonInM: function (e, t, n, r) { function a(e) { return e * (Math.PI / 180) } var o = a(n - e), s = a(r - t), l = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(a(e)) * Math.cos(a(n)) * Math.sin(s / 2) * Math.sin(s / 2); return 1e3 * (6371 * (2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)))) }, rfunc_handler: function (e, t) { this.drawRval = []; switch (e.useControlName) { case "polyline": i = null; if (t.components.length >= 1) { i = t.components; for (h = 0; h < i.length; h++) { var n = i[h].x, r = i[h].y, a = this.mm.toCoord(n, r), o = new window.dgXY(a.lon, a.lat); this.drawRval.push(o) } } (b = {}).measure = t.getGeodesicLength(new OpenLayers.Projection("EPSG:900913")), this.drawRobj = b, points = i; var s = new OpenLayers.Geometry.LineString(points), l = new OpenLayers.Feature.Vector(s); e.layer.addFeatures([l]); break; case "polygon": case "rectangle": if (!t.components) return; if (t.components.length <= 0) return; for (var i = t.components[0].components, c = [], h = 0; h < i.length; h++) { var n = i[h].x, r = i[h].y, a = this.mm.toCoord(n, r), o = new window.dgXY(a.lon, a.lat); this.drawRval.push(o); p = new OpenLayers.Geometry.Point(a.lon, a.lat); c.push(p) } var u = new OpenLayers.Geometry.LinearRing(c), p = new OpenLayers.Geometry.Polygon([u]); (b = {}).measure = p.getGeodesicArea(new OpenLayers.Projection("EPSG:4326")), this.drawRobj = b, points = i; var u = new OpenLayers.Geometry.LinearRing(points), y = new OpenLayers.Geometry.Polygon([u]), l = new OpenLayers.Feature.Vector(y); e.layer.addFeatures([l]); break; case "circle": if (!t.components) return; if (t.components.length <= 0) return; for (var i = t.components[0].components, c = [], h = 0; h < i.length; h++) { var n = i[h].x, r = i[h].y, a = this.mm.toCoord(n, r), o = new window.dgXY(a.lon, a.lat); this.drawRval.push(o); p = new OpenLayers.Geometry.Point(a.lon, a.lat); c.push(p) } var u = new OpenLayers.Geometry.LinearRing(c), p = new OpenLayers.Geometry.Polygon([u]), m = new OpenLayers.Geometry.LinearRing(t.components[0].components), d = new OpenLayers.Geometry.Polygon([m]), g = new OpenLayers.Feature.Vector(d, null).geometry.getBounds(), w = g.left, f = g.bottom, v = g.right, L = (w + v) / 2, O = (f + g.top) / 2, M = new OpenLayers.Geometry.Point(L, O), C = new OpenLayers.Geometry.Point(v, O), R = new OpenLayers.Geometry.LineString([M, C]), _ = Math.round(R.getLength()).toString(), b = {}; b.measure = t.getArea(new OpenLayers.Projection("EPSG:900913")), b.radius = _, b.center = e.mm.toWGS84(L, O), b.start = e.mm.toWGS84(L, O), b.end = e.mm.toWGS84(v, O), this.drawRobj = b, points = i; var u = new OpenLayers.Geometry.LinearRing(points), y = new OpenLayers.Geometry.Polygon([u]), l = new OpenLayers.Feature.Vector(y); e.layer.addFeatures([l]) } e.deactivate(), e.defaultRFunc == e.rfunc ? e.rfunc(e, event, t) : e.rfunc && e.rfunc(null); var P = null; document.getElementById("MM_Control_MeasureToolbar_DrawResult") && (P = document.getElementById("MM_Control_MeasureToolbar_DrawResult"), document.body.removeChild(P)) }, afunc_handler: function (e, t) { switch (this.drawRval = [], e.useControlName) { case "polyline": if (t.parent.components.length >= 1) for (var n = t.parent.components, r = 0; r < n.length; r++) { var a = n[r].x, o = n[r].y, s = this.mm.toCoord(a, o), l = new window.dgXY(s.lon, s.lat); this.drawRval.push(l) } (L = {}).measure = t.parent.getGeodesicLength(new OpenLayers.Projection("EPSG:900913")), this.drawRobj = L; break; case "polygon": case "rectangle": if (t.parent.components.length <= 0) return; if (this.drawRval = [], t.parent.components.length >= 1) for (var n = t.parent.components, r = 0; r < n.length; r++) { var a = n[r].x, o = n[r].y, s = this.mm.toCoord(a, o), l = new window.dgXY(s.lon, s.lat); this.drawRval.push(l) } (L = {}).measure = t.parent.getGeodesicArea(new OpenLayers.Projection("EPSG:900913")), L.measure = Math.abs(L.measure), this.drawRobj = L; break; case "circle": if (t.components[0].components.length <= 0) return; if (t.components[0].components.length >= 1) for (var n = t.components[0].components, r = 0; r < n.length; r++) { var a = n[r].x, o = n[r].y, s = this.mm.toCoord(a, o), l = new window.dgXY(s.lon, s.lat); this.drawRval.push(l) } var i = new OpenLayers.Geometry.LinearRing(t.components[0].components), c = new OpenLayers.Geometry.Polygon([i]), h = new OpenLayers.Feature.Vector(c, null).geometry.getBounds(), u = h.left, p = h.bottom, y = h.right, m = (u + y) / 2, d = (p + h.top) / 2, g = new OpenLayers.Geometry.Point(m, d), w = new OpenLayers.Geometry.Point(y, d), f = new OpenLayers.Geometry.LineString([g, w]), v = Math.round(f.getLength()).toString(); try { v = parseFloat(v) } catch (e) { } var L = {}; L.measure = t.getGeodesicArea(new OpenLayers.Projection("EPSG:900913")), L.measure = Math.abs(L.measure), L.radius = v, L.center = e.mm.toWGS84(m, d), L.start = e.mm.toWGS84(m, d), L.end = e.mm.toWGS84(y, d), this.drawRobj = L } "undefined" == typeof event ? e.afunc && e.afunc() : e.afunc && e.afunc(event) }, measuring: function (e, t, n, r) { }, defaultRFunc: function (e, t, n) { if (n && !(n.components.length <= 0)) { var r = null; switch (this.useControlName) { case "polyline": r = n.components; break; case "polygon": case "circle": case "rectangle": r = n.components[0].components } for (var a = 0, o = 0, s = 0; s < r.length; s++) a += r[s].x, o += r[s].y; a /= r.length, o /= r.length; var l = e.mm.toWGS84(a, o), i = new EzMap.HtmlStr("<div style='width:320px;font-weight:bold;color:red;font-size:13px;text-shadow: 0px 0 white, 0 1px white, 1px 0 white, 0 -1px white;'>" + e.getMeasureFormat(e.drawRobj) + "</div>", e.mm), c = new OpenLayers.Marker(e.mm.fromWGS84(l.lon, l.lat), i); e.markerLayer.addMarker(c) } }, defaultAFunc: function (e) { return }, getMeasureFormat: function (e) { if (e) { var t = ""; switch (this.useControlName) { case "polyline": e.measure >= 1e3 ? (t = "km", e.measure = e.measure / 1e3) : t = "m"; break; case "polygon": case "circle": case "rectangle": e.measure >= 1e6 ? (t = "km", e.measure = e.measure / 1e6) : t = "m" } switch (t) { case "m": t = _$EZMAP.UNIT_M; break; case "km": t = _$EZMAP.UNIT_KM } var n = parseInt(1e3 * parseFloat(e.measure)) / 1e3; switch (this.useControlName) { case "polyline": return _$EZMAP.UNIT_DISTANCE + "&nbsp;" + n + t; case "polygon": case "circle": case "rectangle": return _$EZMAP.UNIT_AREA + "&nbsp;" + n + _$EZMAP.UNIT_SQUARE + t } } }, deactivate: function () { this.useControl && 1 == this.useControl.active && this.useControl.deactivate(), 1 == this.path.active && this.path.deactivate(), 1 == this.polygon.active && this.polygon.deactivate(), 1 == this.circle.active && this.circle.deactivate(), 1 == this.rectangle.active && this.rectangle.deactivate() }, hidden: function (e) { e }, getStyle: function () { var e = { pointRadius: 4, graphicName: "square", fillColor: "white", fillOpacity: 1, strokeWidth: 1, strokeOpacity: 1, strokeColor: "#333333" }, t = { strokeWidth: 3, strokeOpacity: 1, strokeColor: "#666666", strokeDashstyle: "dash" }, n = { strokeWidth: 3, strokeOpacity: 1, strokeColor: "#666666", fillColor: "#ffffff", fillOpacity: .5, strokeDashstyle: "dash" }; this.mm.lineStyle && (t = this.mm.lineStyle), this.mm.polygonStyle && (n = this.mm.polygonStyle); var r = { Point: e, Line: t, Polygon: n }, a = new OpenLayers.Style; return a.addRules([new OpenLayers.Rule({ symbolizer: r })]), a }, getStyleMap: function () { return new OpenLayers.StyleMap({ default: this.getStyle(), delete: this.getStyle(), select: this.getStyle(), temporary: this.getStyle() }) }, draw: function () { var e = OpenLayers.Control.Panel.prototype.draw.apply(this, arguments); return null === this.defaultControl && (this.defaultControl = this.controls[0]), this.map.getControlsBy("id", "_MeasureToolbar_NAV_")[0].disableZoomBox(), this.map.getControlsBy("id", "_MeasureToolbar_NAV_")[0].disableZoomWheel(), e }, isActive: function () { try { return map.mm.measure.useControl.active } catch (e) { return !1 } }, getControlName: function () { try { return map.mm.measure.useControlName } catch (e) { return "" } }, CLASS_NAME: "EzMap.Control.MeasureToolbar" });